---
title: 编译/链接原理及其在开发中之体现
date: 2023-12-01
tags:
- [C语言]
categories:
- [嵌入式]
description: 讲述个人对C工程编译链接的一些浅薄见解，不涉及深层的编译原理；此外，也记录在开发中所遇到的与编译、链接相关的知识及其应用
---


## 构建C工程中的一些疑惑解答

- #include ".c"文件 可行吗？
- GNU C是个啥？其编译跟ARM CC有哪些方面的区别？
- 链接脚本与汇编源文件、C源文件的联系

---
- 四字节对齐：要求数据的存放起始地址必须是4的倍数
作用：
1、数据结构按照4字节对齐，使得处理器更有效访问，32位系统可以一次读完一个4字节长度变量
2、某些硬件要求数据需要在特定的边界上对齐，否则可能出现异常
    如STM32，Flash的写入、DMA访问、结构体成员、线程栈PSP、**指针变量**都需要考虑字节对齐
3、结构体本身没有4字节对齐，进行特定的跳转读取，可能导致异常

---

## 与编译链接相关之实用小知识

### printf重定向至串口

开发调试时可以通过printf进行信息打印输出，但是通常编译器默认将printf重定向至屏幕，可以通过重定向至串口来输出：
- `printf`是C标准库用于格式化输出到标准输出(stdout)的函数，其在**C标准库里内会调用到接口`_write`，该接口是个弱函数，默认实现是输出至屏幕**。
- 那么用户可以自行实现`_write`函数，将数据输出至串口。编译器链接时会链接到用户自行实现的`_write`函数，而非默认的弱符号修饰的`_write`函数。

当然，不同C库的实现方式也不同，这里以`gcc nano`为例。（其它C库如 ARM-microlib，或者 newlib 等，其重定向时不一定为重写`_write`函数，可能是`_io_putchar`函数、`_putchar`函数等）
```c
int _write(int fd, char* data, int len)
{
    drv_uart_write(DEV_UART1, (uint8_t *)data, len);    // 由开发者自行实现此接口
    return len;
}
```


## 非典型知识

### .a静态库文件和.o目标文件


**.o文件格式：** 格式由目标体系结构决定，通常为`ELF`
- 文件头：记录了文件的类型、大小、目标体系结构、编译器版本等
- 代码段：包含了函数的代码，如操作码、数据段、代码段
- 数据段：包含了函数的静态数据，如全局变量、静态变量
- 符号表：记录了.o文件中所有符号的名称和地址，其可以是函数、变量、常量等
- 重定位表：记录了.o文件之间相互引用的符号的地址
  >如：如果一个.o文件中有一个函数foo()，另一个.o文件中有一个变量a，而变量a的值由函数foo()返回，则需要在两个.o文件之间建立重定位关系


**.a文件格式：** 静态库文件，由多个.o文件链接而成
- .o文件的列表
- 符号表：记录了文件中所有符号的名称和地址。符号可以是函数、变量、常量等
- 重定位表：用于记录两个文件之间相互引用的符号的地址

>程序链接时，链接器会根据.a文件中的符号表和重定位表，将.a文件中的代码和数据链接到程序中


**nm命令**：用于查看目标文件（.o文件）和库文件（.a文件）中的符号表**（-a：显示所有符号，-g：显示符号类型、地址、符号表中索引，-r：显示符号的重定位信息）**
> nm XXX.a

**objdump命令**：objdump命令用于反汇编目标文件（.o文件）和库文件（.a文件）**（-d：反汇编代码段，-s：显示数据段，-t：显示符号表）**
> objdump -t 1.o

**readelf命令**：readelf命令用于查看目标文件（.o文件）和库文件（.a文件）的文件头、代码段、数据段等信息（-h：显示文件头信息，-S：显示代码段信息，-D：显示数据段信息）
> readelf -h XXX.a


---
## C程序开发注意点

### 头文件包含
- 避免冗余的头文件包含，只有当用到时才添加其头文件
- 头文件在预处理阶段会被复制到源文件中，过多包含不必要头文件会使得编译时间增加
- 头文件中定义了相同变量、函数等，可能会引起不必要的冲突；或会使得链接器产出些潜在的错误链接问题
- 尽量不要在头文件中包含头文件


### 修改编译优化级别

- 改变编译等级可能会导致程序运行出错
    - 提高优化级别时出错，可考虑以下：
        >程序中没有放置正确的内存屏障，优化导致的乱序执行可能有问题
        部分代码设计需要严谨考虑时序性
        可能会忽略了链接脚本中指定的四字节对齐
    - 降低优化级别时出错：
        >线程的堆栈可能偏小，导致栈溢出

- 修改编译等级后导致运行出错的问题排查思路



## C编译过程

编译器的主要工作流程如下：
>源程序(source code)→预处理器(preprocessor)→编译器(compiler)→汇编程序(assembler)→目标程序(object code)→连接器(链接器，Linker)→可执行程序(executables)


- 配置
- 确定标准库和头文件位置
- 确定依赖关系
- 头文件预编译
- 预处理
- 编译
- 链接
- 安装



## 参考站点


