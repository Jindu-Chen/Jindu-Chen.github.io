---
title: C语言知识点记录
date: 2023-12-04 10:04:15
tags:
categories:
- [C语言]
description: 记录、总结在嵌入式开发中遇到的C知识点
---


- 段的详解
  - 常规的段：代码段、数据段、BSS段、堆、栈
  - init段、符号表段、重定位段、调试信息段、通过attribute指定的段
    可通过编程将指定的函数链接到指定的段，如init段，实现在main前的初始化，等一系列自定义操作
  - 链接器在链接过程中会自动生成特殊的符号，用于代表各段的首尾地址
    如：段名init_array，那么相应的会有`__init_array_start`或者`__start_init_array`表示该段的首地址，`__init_array_end`或`__stop_init_array`表示该段的末尾地址，不同编译器的表示方式有区别


## 预处理

- 重复宏定义？
宏定义的本质是替换，如果同一个宏名定义了两个不同的量，则在编译时可能会替换两次，最终输出的为最后一次宏定义处理的值


## 关键字

- \_\_attribute\_\_ 关键字
    - \_\_attribute\_\_((weak))
    - \_\_attribute\_\_((constructor))
    - \_\_attribute\_\_((\_\_used\_\_)) 告知编译器：即使修饰的对象在编译过程中没有被引用，也要保留
    - \_\_attribute\_\_((\_\_section\_\_("my_section"))) 表示将修饰的对象放在名为`my_section`的段中
      在C文件中编程，一般可以通过特殊的符号来获取attribute声明的段的首末地址，其由链接器在链接过程中自动定义<br>
        示例1：
        ```
        #define  __used  __attribute__((__used__))

        typedef void (*initcall_t)(void);

        #define __define_initcall(fn) \
            static const initcall_t __initcall_##fn##id __used \
            __attribute__((__section__("initcall_system_init"))) = fn; 

        #define INIT_SYSTEM_EXPORT(fn)      __define_initcall(fn)
        
        ```
        应用示例2：定义系列 赋值为函数指针的静态常量，将其声明到指定的段中
        ```
        extern char __start_my_section[];
        extern char __stop_my_section[];

        char *start = __start_my_section;
        char *end = __stop_my_section;

        typedef void (*func_ptr)(void);

        for (func_ptr *f = (func_ptr *)__start_my_section; f < (func_ptr *)__stop_my_section; ++f) {
            (*f)();
        }
        ```

## 变量

- 静态局部变量，能被外界所访问吗？
>将其地址传递出去即可，因为静态变量的地址在编译时已经确定，其生存在整个程序运行期间


## 函数

- switch case
>当在case语句内定义变量时，需要在case语句内 加花括号限定变量的作用域，否则编译会报错



