---
title: 嵌入式开发之命令行调试-Shell全剖析
date: 2024-02-08
tags:
categories:
- [MCU]
- [嵌入式]
description: 日常在嵌入式软件开发中的调试方法包括有在线调试、日志打印、Shell 交互、BackTrace 等，其中 Shell 能够以命令行交互的方式直接访问系统信息或者执行功能函数，是辅助开发的调试利器之一，本文主要记录、总结个人对嵌入式 Shell 的应用、理解及原理分析。
---


## 前言

本人初次接触命令行调试，还是在大学时初学正点原子 STM32 教程，其提供了一个软件组件用于调试：（**只要你在串口输入相应的函数名，单片机就能执行相应的函数**），当时真的惊为天人，觉得这种调试方法很神奇也很有意思。

那时不了解什么是命令行，什么是Shell，也没有能力或者精力去了解其原理实现，即使那软件组件并不具备一个 Shell 的完整功能，但也足以震惊初学STM32点灯的我

随着开发经历多起来，日常Linux Shell、PowerShell、嵌入式Shell 等等各种什么 Shell 的字眼充斥耳边，本人也对 Shell 这个词有了新的理解，因此也就写下这篇文章，主要为总结和升华个人对嵌入式 Shell 的应用及理解，当然也包括其它的一些方面，或者说在研读源码过程中，能够学习到一些编程方式/方法/思想，那就更好不过了


## 命令行概述

官方百科：Shell，即命令行解释器，是计算机操作系统的一种用户界面，用户可以通过Shell与操作系统进行交互，输入命令来执行各种操作、控制系统的各种功能。Bash、Windows CMD、PowerShell等都是属于命令行解释器

那么嵌入式Shell也是同理，只不过用户是使用上位机串口软件输入命令与嵌入式设备进行交互而已（通常是通过UART串口与外界交互，但其实也可以将输入输出流设置到其它外设上，如蓝牙BLE透传、TCP/IP等）

比如在Linux Shell中，用户在命令行界面输入如`ls cd touch gcc make`等这些命令，使得Shell解释器会调用相对应名称的可执行程序，当然了通常输入命令还可以附带参数，这就跟C函数也有入口参数一样。
> 换句话说，命令就是可执行程序，其就是一个被封装好的功能函数。

<br>

另外，命令行能够直接调用这些可执行程序，是因为它们的绝对路径被声明到环境变量路径中了，这样使得Shell解释器能够找到它们
> 所以，不管是在Linux，还是Windows中，环境变量都是个重要概念

<br>

---

下面主要以 Letter-Shell、RT-Thread FinSH 控制台为例，讲述嵌入式Shell的应用及原理分析


## 引出命令行函数原理

从通俗的角度来说，命令行调用就相当于：用户向设备发送一个指令，这个指令约定好跟一个指定操作有着映射关系，于是设备收到该指令后，去查询并执行其对应映射的操作。

就 Letter-Shell 为例（其它嵌入式Shell同理），通常移植完成后，其引出命令行的代码如下：
```c
void cmd_test(void) {
    printf("Hello world ! \\n");
}
SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), cmdTest, cmd_test, test cmd);
```
如上，当在Shell中输入`cmdTest`时，程序则会调用执行`cmd_test()`函数，而`test cmd`则是命令的说明部分。


其主要是通过定义`SHELL_EXPORT_CMD`宏，将函数添加到shell的可执行命令列表中，该宏涉及预处理和链接特性，其实现如下：
```c
#define SHELL_EXPORT_CMD(_attr, _name, _func, _desc) \\
const char shellCmd##_name[] = #_name; \\
const char shellDesc##_name[] = #_desc; \\
SHELL_USED const ShellCommand \\
shellCommand##_name SHELL_SECTION(\"shellCommand\") = \\
{ \\
    .attr.value = _attr, \\
    .data.cmd.name = shellCmd##_name, \\
    .data.cmd.function = (int (*)())_func, \\
    .data.cmd.desc = shellDesc##_name \\
}
```
这个宏接受四个参数：_attr、_name、_func和_desc，分别代表命令的属性、命令名、函数和描述。这个宏的作用是生成一个 ShellCommand 类型的全局变量，这个变量会被放在一个特殊的段（shellCommand）中。

上述代码详细解释如下：
- `SHELL_USED`即`__attribute__((used))`，指示编译器不要优化这个变量
- `SHELL_USED const ShellCommand \\`中的`ShellCommand`是一个结构体（联合体）变量类型，其元素包含命令的属性、命令名、函数指针、或者存放按键键值、用户名、用户密码等等信息
- `SHELL_SECTION(\"shellCommand\")`即`__attribute__((section(shellCommand)))`，指示将定义的这个结构体变量声明到这个段中

在链接阶段，链接器会将同一段中的所有变量放在一起，形成一个数组。这样，Shell就可以通过遍历这个数组来获取所有的命令，如下：

不同的编译器特性不一样，但程序都是通过获取**这个段的首末地址**，然后在输入命令时，轮询这个段并执行相应的命令
```c
    // 以下为针对不同编译器，声明外部链接器中给段定义好的 段 的首末地址变量
    #if defined(__CC_ARM) || (defined(__ARMCC_VERSION) && __ARMCC_VERSION >= 6000000)
        extern const unsigned int shellCommand$$Base;
        extern const unsigned int shellCommand$$Limit;
    #elif defined(__ICCARM__) || defined(__ICCRX__)
        #pragma section="shellCommand"
    #elif defined(__GNUC__)
        extern const unsigned int _shell_command_start;
        extern const unsigned int _shell_command_end;
    #endif


    // 以下为记录 shellCommand 段的首末地址，并计算出有多少个命令
    #if defined(__CC_ARM) || (defined(__ARMCC_VERSION) && __ARMCC_VERSION >= 6000000)
        shell->commandList.base = (ShellCommand *)(&shellCommand$$Base);
        shell->commandList.count = ((unsigned int)(&shellCommand$$Limit)
                                - (unsigned int)(&shellCommand$$Base))
                                / sizeof(ShellCommand);

    #elif defined(__ICCARM__) || defined(__ICCRX__)
        shell->commandList.base = (ShellCommand *)(__section_begin("shellCommand"));
        shell->commandList.count = ((unsigned int)(__section_end("shellCommand"))
                                - (unsigned int)(__section_begin("shellCommand")))
                                / sizeof(ShellCommand);
    #elif defined(__GNUC__)
        shell->commandList.base = (ShellCommand *)(&_shell_command_start);
        shell->commandList.count = ((unsigned int)(&_shell_command_end)
                                - (unsigned int)(&_shell_command_start))
                                / sizeof(ShellCommand);
```

其中，如果是在GCC编译环境下，那么需要在链接脚本中加入以下代码，以使得C源程序能够获取`ShellCommand`的首末地址，不然程序编译会报错
```
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(4);

  _shell_command_start = .;
  KEEP (*(shellCommand))
  _shell_command_end = .;
  } >FLASH
```


综上所述，引出命令行的原理是：通过一个宏，定义一个全局结构体变量（其包含要引出的命令函数及其相关属性信息），并将该变量声明到一个指定的段中。Shell在接受外界命令时，会轮询这个段内的所有结构体变量，找到对应的命令函数指针并执行调用。



### 命令行解析

 

```
void shellTaskPoll(void)
{
	shellTask((void *)&shell);
}
```

```
void shellTask(void *param)
{
    Shell *shell = (Shell *)param;
    char data;
#if SHELL_TASK_WHILE == 1
    while(1)
    {
#endif
        if (shell->read && shell->read(&data, 1) == 1)
        {
            shellHandler(shell, data);
        }
#if SHELL_TASK_WHILE == 1
    }
#endif
}
```

在 Letter_Shell 中，其对所有的命令行函数解析，都会记录下`argc`和`argv[]`，最终在调用时，才会根据先前宏定义声明的函数类型进行 函数指针 + 参数 的强制指向调用

#### main 类型函数

```c
    if (command->attr.attrs.type == SHELL_TYPE_CMD_MAIN)
    {
        shellRemoveParamQuotes(shell);
        returnValue = command->data.cmd.function(shell->parser.paramCount,
                                                 shell->parser.param);
        if (!command->attr.attrs.disableReturn)
        {
            shellWriteReturnValue(shell, returnValue);
        }
    }
```

#### 普通函数

入参

```c
int shellExtRun(Shell *shell, ShellCommand *command, int argc, char *argv[])
{
    unsigned int params[SHELL_PARAMETER_MAX_NUMBER] = {0};
    int paramNum = command->attr.attrs.paramNum > (argc - 1) ? 
        command->attr.attrs.paramNum : (argc - 1);
    for (int i = 0; i < argc - 1; i++)
    {
        params[i] = shellExtParsePara(shell, argv[i + 1]);
    }
    switch (paramNum)
    {
#if SHELL_PARAMETER_MAX_NUMBER >= 1
    case 0:
        return command->data.cmd.function();
        // break;
#endif /** SHELL_PARAMETER_MAX_NUMBER >= 1 */
#if SHELL_PARAMETER_MAX_NUMBER >= 2
    case 1:
        return command->data.cmd.function(params[0]);
        // break;
#endif /** SHELL_PARAMETER_MAX_NUMBER >= 2 */
    
    // ......
    }
}
```

### 命令函数


### 命令表

### 键值



## Shell 附加功能

### 密码设置


### 实时操作系统下获取当前线程运行状态

### 线程栈最大使用率

### CPU空闲率


### 日志输出

颜色的标准配置

日志等级



## Shell 移植适配

此处不过多赘述


## 注意项及疑惑解答

### 实际应用中避免串口回环，导致函数陷入死循环

换行，tab等标准功能 参照Shell

串口软件之按键键值映射，参照SecureCRT

多端输出

### 声明的命令行函数接受任何类型的参数并返回int型

在 Letter_Shell 中，其使用的仍然是旧式声明，（如`int foo();`）

此旧式声明只是阻止编译器检查参数类型和数量，但假如传入的参数不符合函数定义中的要求，则导致未定义行为

旧式的声明/定义已经在新的 C2x 标准草案中被移除了。此后，`int foo(); `等价于 `int foo(void);` 。


## 参考站点

- [letter shell 3.x](https://github.com/NevermindZZT/letter-shell/blob/master/README.md)
- [letter-shell | 一个功能强大的嵌入式shell](https://zhuanlan.zhihu.com/p/128960695)
- [C基础 -- SHELL_EXPORT_CMD(_attr, _name, _func, _desc)宏注册函数详解](https://blog.csdn.net/jisuanji111111/article/details/126719491)

