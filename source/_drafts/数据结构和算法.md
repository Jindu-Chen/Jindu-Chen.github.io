---
title: 数据结构与算法学习笔记
date: 2024-01-01
tags:
categories:
- [C语言]
description: 本文主要记录个人对数据结构与算法的学习过程，包括但不限于相关概念的官方描述、个人的理解、以及C语言的实现等。
---



## 前言




## 复杂度分析

复杂度描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势

“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。

复杂度反映了算法运行效率与输入数据体量之间的关系

复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”


## 排序算法

### 快速排序

**思想：** 基于分治策略，选择数组中的某个元素作为基准数，将一个较长的数组分成两个较短的子数组，满足：“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。而后再对子数组进行相同的操作，直到数组中的元素个数为1，此时数组已排序。

**算法流程：** 
1. 选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。

```c
/* 元素交换 */
void swap(int nums[], int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
/* 哨兵划分 */
int partition(int nums[], int left, int right) {
    // 以 nums[left] 为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= nums[left]) {
        j--; // 从右向左找首个小于基准数的元素
        }
    
        while (i < j && nums[i] <= nums[left]) {
            i++; // 从左向右找首个大于基准数的元素
        }
        
        // 交换这两个元素
        swap(nums, i, j);
    }
    
    // 将基准数交换至两子数组的分界线
    swap(nums, i, left);
    
    // 返回基准数的索引
    return i;
}
```

## 参考站点


- [hello， 算法](https://github.com/krahets/hello-algo)

