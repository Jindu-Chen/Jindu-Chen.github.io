---
title: 嵌入式软件设计之消息交互--观察者模式
date:
tags:
- [设计模式]
categories:
- [设计模式]
description: 早就听过设计模式、也阅览过不少设计模式相关的文章，相信即使是未曾了解过设计模式的嵌入式软件工程师，或多或少的都在日常开发中应用到相关的设计思想，因此，写下本文，以总结本人对观察者模式（嵌入式软件开发中一种较为重要的设计模式）的理解。
---


## 前言

状态模式就不多说了，毕竟状态机是嵌入式开发中最常见、必要的软件设计方法。

当然了，常用的设计模式还包括有适配器模式、命令模式等等。

在嵌入式MCU软件开发过程中，对于稍微较大一点的工程都不可避免地会涉及到模块化设计、分层设计等，实时操作系统可以通过消息队列、事件等内核组件实现模块间交互，如果在裸机开发过程中又如何实现模块间信息交互并尽可能保证实时性呢？

观察者模式也叫：发布-订阅模式

## 实际开发应用分析


如：在按键示例中，按键事件可以当作被观察者，受按键触发的其它操作为观察者，当轮询检测到按键按下时，调用所有观察者回调函数

如：温度监控

如：状态变化


## 示例代码实现

```c
#include <stdio.h>

// 定义观察者接口
typedef void (*Observer)(void *data);

// 定义被观察者结构体
typedef struct Subject {
    // 观察者列表
    Observer *observers;
    // 观察者数量
    int observer_count;
    // 数据
    void *data;

    // 添加观察者
    void add_observer(struct Subject *subject, Observer observer) {
        subject->observers[subject->observer_count++] = observer;
    }

    // 删除观察者
    void remove_observer(struct Subject *subject, Observer observer) {
        for (int i = 0; i < subject->observer_count; i++) {
            if (subject->observers[i] == observer) {
                subject->observers[i] = subject->observers[subject->observer_count - 1];
                subject->observer_count--;
                break;
            }
        }
    }

    // 通知所有观察者
    void notify_observers(struct Subject *subject) {
        for (int i = 0; i < subject->observer_count; i++) {
            subject->observers[i](subject->data);
        }
    }
} Subject;

// 定义观察者结构体
typedef struct Observer {
    // 观察者回调函数
    void (*callback)(void *data);

    // 构造函数
    Observer(void (*callback)(void *data)) {
        this->callback = callback;
    }
} Observer;

// 定义一个示例
void observer1(void *data) {
    printf("Observer1 received data: %d\n", *(int *)data);
}

void observer2(void *data) {
    printf("Observer2 received data: %d\n", *(int *)data);
}

int main() {
    // 创建被观察者
    Subject subject;
    subject.observers = malloc(sizeof(Observer) * 10);
    subject.observer_count = 0;
    subject.data = malloc(sizeof(int));

    // 添加观察者
    Observer observer1(observer1);
    subject.add_observer(&subject, observer1);

    Observer observer2(observer2);
    subject.add_observer(&subject, observer2);

    // 设置数据
    *(int *)subject.data = 10;

    // 通知所有观察者
    subject.notify_observers(&subject);

    // 删除观察者
    subject.remove_observer(&subject, observer1);

    // 再次设置数据
    *(int *)subject.data = 20;

    // 通知所有观察者
    subject.notify_observers(&subject);

    return 0;
}
```

## 参考站点






