<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【RTOS】多核系统下的临界区保护设计以及案例分析</title>
      <link href="/2024/11/26/%E3%80%90RTOS%E3%80%91%E5%A4%9A%E6%A0%B8%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BF%9D%E6%8A%A4%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/11/26/%E3%80%90RTOS%E3%80%91%E5%A4%9A%E6%A0%B8%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BF%9D%E6%8A%A4%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要分为以下三个部分：</p><ul><li>简单介绍临界区的概念以及保护机制，并说明单核系统与多核系统的相关设计差异</li><li>讲述<code>701-142/701-143beta2-音箱SDK</code>开发中碰到的<strong>两个共性问题案例</strong>（其均是<strong>多核系统下的临界区保护设计缺陷</strong>所引起的）</li><li>总述多核系统下的线程调度策略，以及其临界区保护设计</li></ul><h2 id="临界区概念简述"><a href="#临界区概念简述" class="headerlink" title="临界区概念简述"></a>临界区概念简述</h2><p><strong>临界区代码：</strong> 涉及共享资源（如外设、全局变量&#x2F;指针、buffer等）访问的代码区</p><p>以下情况，可能会导致数据不一致，或不可预知的问题</p><ul><li>一个线程在执行临界区代码中，被更高优先级线程抢占执行</li><li>一个线程在执行临界区代码中，被中断抢占执行</li><li>一个中断在执行临界区代码中，被更高优先级中断抢占执行</li><li>cpu0与cpu1双核，同时在执行临界区代码</li></ul><p>因此，在多线程、多核心编程开发中，尤其要注意临界区保护设计！</p><p><strong>重点：在嵌入式开发中，相当一部分的概率性问题，是由于临界区保护设计缺陷所引起的！</strong></p><hr><p>另，与临界区相关的几个概念如下：</p><p><strong>不可重入函数：</strong> 如果函数在未完成执行前被再次调用，会导致数据不一致或其它不可预知的问题。此类型函数有如下特征：</p><ul><li>函数内部使用静态变量</li><li>函数内部修改全局变量（访问、修改 其它线程会使用到的变量）</li><li>存在操作依赖于外部状态、外部变量</li></ul><p>实际开发中，存在相当多的不可重入函数，必须要在上述第二第三点处，添加临界区保护。</p><br><p><strong>线程安全函数：</strong> 可以被多线程同时调用的函数，如<code>memcpy</code>、<code>memset</code>等C库函数，如可以反复同时调用而不影响系统正常的通用API</p><ul><li>不使用函数内部静态变量</li><li>通常由外界调用者传入其私有参数指针，避免<strong>数据竞争</strong></li></ul><hr><h3 id="临界区保护机制"><a href="#临界区保护机制" class="headerlink" title="临界区保护机制"></a>临界区保护机制</h3><p><strong>禁用中断（local_irq_disable）：</strong> 适用于单核系统的中断与线程间保护</p><ul><li>禁用硬件中断访问共享资源，同时也禁用了系统调度器进行线程调度</li><li>但在多核系统中，特指<strong>禁用注册在当前核的中断</strong>，而不是禁用全局中断</li></ul><p><strong>自旋锁（spin_lock）：</strong> 专门为多核系统设计的一种临界区保护方式</p><ul><li>自旋等待：当前cpu核 查询到 锁被另一个cpu核持有，其会在原地等待，直到锁被释放</li><li>不会触发系统调度器调度，避免了线程上下文切换的开销</li><li>适用于持有时间非常短的临界区锁，因为长时间的自旋会浪费CPU资源</li></ul><p><strong>互斥锁（mutex）：</strong> 多线程间保护</p><ul><li>不能用于中断，只能用于线程与线程之间的临界区保护</li></ul><p><strong>信号量（Sem）：</strong> </p><p><strong>原子操作（Atomic）：</strong> </p><hr><h2 id="多核系统-临界区保护设计缺陷案例分析"><a href="#多核系统-临界区保护设计缺陷案例分析" class="headerlink" title="多核系统-临界区保护设计缺陷案例分析"></a>多核系统-临界区保护设计缺陷案例分析</h2><h3 id="中断与线程访问共享指针变量——概率死机"><a href="#中断与线程访问共享指针变量——概率死机" class="headerlink" title="中断与线程访问共享指针变量——概率死机"></a>中断与线程访问共享指针变量——概率死机</h3><h4 id="701-142-143-iis输入-相关缺陷代码描述"><a href="#701-142-143-iis输入-相关缺陷代码描述" class="headerlink" title="701-142&#x2F;143-iis输入-相关缺陷代码描述"></a>701-142&#x2F;143-iis输入-相关缺陷代码描述</h4><p><img src="/../pictures/%E3%80%90RTOS%E3%80%91iis-dma%E4%B8%AD%E6%96%AD%E4%B8%8E%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%AD%BB%E6%9C%BA.png" alt="701-142/143-iis输入临界区代码"></p><p>以上<code>IIS-DMA-IN</code>是在<code>alink_isr</code>中断内调用的，以上禁用中断代码为通过<code>audio_dec</code>线程调用的</p><ul><li><code>alink_isr</code>中断，注册在cpu0<blockquote><p>audio_link.c -&gt; <code>request_irq(IRQ_ALINK0_IDX, 3, alink0_dma_isr, 0);</code>，即注册在<code>cpu-&gt;core0</code></p></blockquote></li><li>从<code>task_table.c</code>可知，线程<code>audio_dec</code>运行在cpu1核（固定核心调度的前提下）</li></ul><br><p><strong>问题：</strong> 在配置IIS输入48KHz，压测出现了概率死机，打印如下，底层<strong>判断为野指针访问断言</strong>：<br><img src="/../pictures/%E3%80%90RTOS%E3%80%91iis-%E8%BE%93%E5%85%A548KHz-%E6%AD%BB%E6%9C%BA%E6%96%AD%E8%A8%80%E9%87%8E%E6%8C%87%E9%92%88.png" alt="alt text"></p><h4 id="问题原因分析"><a href="#问题原因分析" class="headerlink" title="问题原因分析"></a>问题原因分析</h4><p>死机原因解析为：</p><ul><li>解码线程运行在<code>cpu1</code>核，执行<code>local_irq_disable</code>禁用<strong>cpu1对应的中断</strong></li><li>解码线程进入临界区，将<code>audio-&gt;track</code>指针变量释放，但还没重新赋值</li><li>此时注册在<code>cpu0</code>核的<code>alink_iis_dma</code>中断函数触发，并行访问<code>audio-&gt;track</code>指针 —— 导致了野指针访问断言死机</li></ul><p>示意图如下：<br><img src="/../pictures/%E3%80%90RTOS%E3%80%91%E5%A4%9A%E6%A0%B8%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%E7%A4%BA%E6%84%8F.png" alt="【RTOS】多核竞争问题示意"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>改为<code>spin_lock</code>自旋锁，<strong>锁住多核</strong>，保证<code>audio-&gt;track</code>指针变量的访问安全</p><p><img src="/../pictures/%E3%80%90RTOS%E3%80%91iis-dma%E4%B8%8E%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B%E6%B7%BB%E5%8A%A0%E8%87%AA%E6%97%8B%E9%94%81-%E9%94%81%E4%BD%8F%E5%A4%9A%E6%A0%B8.png" alt="iis-dma与解码线程添加自旋锁-锁住多核"></p><hr><h3 id="中断与线程操作共享fifo——发射声音卡顿"><a href="#中断与线程操作共享fifo——发射声音卡顿" class="headerlink" title="中断与线程操作共享fifo——发射声音卡顿"></a>中断与线程操作共享fifo——发射声音卡顿</h3><h4 id="701-142-143-发射器-相关缺陷代码描述"><a href="#701-142-143-发射器-相关缺陷代码描述" class="headerlink" title="701-142&#x2F;143-发射器-相关缺陷代码描述"></a>701-142&#x2F;143-发射器-相关缺陷代码描述</h4><p>缺陷代码位于<code>IIS输入-蓝牙发射</code>音频流之间的<code>audio_bt_emitter_hw.c-&gt;audio_bt_emitter_hw_output()</code>节点</p><blockquote><p>此节点位于 MIXER 后，蓝牙发射sbc编码前，是一个用<code>硬件定时器回调</code>模拟硬件发射的<code>fifo</code>临界区<br>解码线程的音频数据流写入<code>bt_emitter_fifo</code><br>定时器中断触发从<code>bt_emitter_fifo</code>取数，推送到编码线程</p></blockquote><p><img src="/../pictures/%E3%80%90RTOS%E3%80%91%E8%93%9D%E7%89%99%E5%8F%91%E5%B0%84%E5%99%A8%E6%A8%A1%E6%8B%9F%E7%A1%AC%E4%BB%B6fifo%E8%8A%82%E7%82%B9.png" alt="音频流模拟硬件fifo节点"></p><p>以下为该音频节点临界区设计缺陷代码节选：<br><img src="/../pictures/%E3%80%90RTOS%E3%80%91%E8%93%9D%E7%89%99%E5%8F%91%E5%B0%84-%E6%A8%A1%E6%8B%9F%E7%A1%AC%E4%BB%B6fifo%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81.png" alt="蓝牙发射-模拟硬件fifo问题代码"></p><h4 id="问题原因分析-1"><a href="#问题原因分析-1" class="headerlink" title="问题原因分析"></a>问题原因分析</h4><ul><li><strong>没有对fifo操作做临界区保护</strong></li><li><code>audio_bt_emitter_hw_output</code>不止被一个线程独立调用，存在概率重入风险</li></ul><p>线程在操作fifo，写数据、更新写指针过程中， 硬件中断触发读取临界区fifo，误将刚写入的数据清零 —— 导致了发射出去的音频，有不间断的零数据。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><em>部分修改示意如下：</em></p><ul><li>非线程安全函数，添加防重入设计</li><li>多核下，中断与线程涉及的临界区fifo代码，添加自旋锁保护</li></ul><p><img src="/../pictures/%E3%80%90RTOS%E3%80%91%E8%93%9D%E7%89%99%E5%8F%91%E5%B0%84%E5%99%A8%E6%B7%BB%E5%8A%A0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E4%BF%AE%E5%A4%8D.png" alt="蓝牙发射器添加临界区代码保护修复"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="JL701N-多核系统的调度策略"><a href="#JL701N-多核系统的调度策略" class="headerlink" title="JL701N-多核系统的调度策略"></a>JL701N-多核系统的调度策略</h3><p>……暂略</p><h3 id="临界区保护设计要点"><a href="#临界区保护设计要点" class="headerlink" title="临界区保护设计要点"></a>临界区保护设计要点</h3><ul><li><p>从单核系统上移植功能代码到多核系统，要着重<strong>注意修改临界区保护方式</strong></p></li><li><p>尽量避免设计不可重入函数，对于可能被多线程共同调用的不可重入函数，一定要加临界区保护措施</p></li><li><p>异步通信，尤要谨慎注意设计</p><blockquote><p>如，线程某重要操作，依赖于异步定时器所检测的事件。优先考虑通过RTOS-信号量或事件来处理，而不是共享全局变量的设计方式</p></blockquote></li><li><p>临界区代码设计避免执行耗时过长</p></li><li><p>自旋锁一定要成对使用、禁止嵌套调用，否则会出现死锁现象，<strong>谨慎、规范设计</strong></p></li></ul><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="JL701N-实时系统启动调度过程"><a href="#JL701N-实时系统启动调度过程" class="headerlink" title="JL701N-实时系统启动调度过程"></a>JL701N-实时系统启动调度过程</h3><p>……</p><p>先启动cpu0，再启动cpu1</p><p>系统调度器时基中断依赖于cpu0，禁用了cpu0，也相当于禁用了全局线程调度，但不能禁止cpu1起中断</p><h3 id="固定cpu核心调度"><a href="#固定cpu核心调度" class="headerlink" title="固定cpu核心调度"></a>固定cpu核心调度</h3><p>701-143beta2版本默认是随机核心调度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层定义了 weak 弱函数，上层重写函数可决定核心调度方式</span></span><br><span class="line">u8 <span class="title function_">OSAfiinityConfig</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OSAfiinityConfig fuck&gt;&gt;&gt;&gt;&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//1：固定核；0：随机分配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://192.168.8.109/main/html/4%20-%20%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/%E5%9C%A8%E8%81%8C%E5%9F%B9%E8%AE%AD/4%E5%9B%BA%E4%BB%B6%E4%BA%94%E9%83%A8/14.%E5%A4%9A%E6%A0%B8%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D.html#l14">多核系统介绍-临界区保护之自旋锁</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> 嵌入式 </category>
          
          <category> 杰理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【蓝牙】分析仪使用及基本蓝牙数据包解析</title>
      <link href="/2024/10/22/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E5%88%86%E6%9E%90%E4%BB%AA%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/22/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E5%88%86%E6%9E%90%E4%BB%AA%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>未完待续…</strong></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文以<code>EllisysBluetoothAnalyzer</code>工具为基础，主要介绍蓝牙数据包抓包分析。</p><p>学习使用蓝牙分析仪以及能够进行<strong>基本的数据包解析</strong>，有助于加快问题诊断与解决</p><ul><li>分析蓝牙空中数据包流程，判断蓝牙实际状态是否符合程序设计预期</li><li>识别、排查通信问题，如丢包、重传、延迟等</li><li>界定问题对象，通过抓包分析是手机还是设备端的流程&#x2F;兼容设计问题；比如音乐无声、音量同步、SIRI开关等</li></ul><h2 id="蓝牙分析仪工具配置与使用"><a href="#蓝牙分析仪工具配置与使用" class="headerlink" title="蓝牙分析仪工具配置与使用"></a>蓝牙分析仪工具配置与使用</h2><p>主要分为以下几点：</p><ul><li>硬件接好线后，上位机软件执行<code>Record</code>开始搜索监听</li><li>上位机配置过滤、选择指定目标设备进行监听</li><li>通过设备端或者手机端等方法，获取到目标设备蓝牙链路的Linkkey，在上位机<code>Security-&gt;Link Key</code>选项卡中输入Linkkey完成解密</li><li>保证正确解密以及抓包数据质量，通常需要抓取到设备之间从断开-&gt;连接-&gt;执行相应复现操作的全过程。</li></ul><h3 id="搜索、过滤与监听"><a href="#搜索、过滤与监听" class="headerlink" title="搜索、过滤与监听"></a>搜索、过滤与监听</h3><p>配置工具搜索监听目标设备</p><blockquote><p>添加监听的目标，设备与手机</p></blockquote><p>暂略</p><h3 id="Linkkey的获取与配置解密"><a href="#Linkkey的获取与配置解密" class="headerlink" title="Linkkey的获取与配置解密"></a>Linkkey的获取与配置解密</h3><p>经典蓝牙的数据包在传输过程中通常是加密的，以防止数据被未经授权的第三方窃听。在进行蓝牙通信问题的诊断时，需要查看具体的通信数据包内容，以确定问题的原因。例如，如果出现丢包、重传、延迟等问题，通过解密后的数据包可以更准确地定位问题。因此，需要使用 Linkkey 来解密数据包，从而获取明文内容。</p><p>Linkkey 是<strong>经典蓝牙</strong>用于加密和认证的重要安全参数，长度为16个字节（128位），用于保护蓝牙设备之间的通信安全。</p><blockquote><p>示例如：01 23 45 67 89 AB CD EF 01 23 45 67 89 AB CD EF</p></blockquote><p>Linkkey的获取：<br>从手机端获取 &#x2F;data&#x2F;misc&#x2F;bluedroid&#x2F;bt_config.conf<br>从设备端获取，根据厂商设计，可以通过调试接口获取。</p><p>比如，杰理方案的<code>LinkKey</code>串口打印获取如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u8 *<span class="title function_">get_last_device_connect_linkkey</span><span class="params">(u16 *len)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_ENABLE</span></span><br><span class="line">        <span class="keyword">extern</span> u8 *<span class="title function_">get_last_device_connect_linkkey</span><span class="params">(u16 *len)</span>;</span><br><span class="line">        u8 *test_linkkey;</span><br><span class="line">        u16 test_linkkey_len = <span class="number">16</span>;</span><br><span class="line">        test_linkkey = get_last_device_connect_linkkey(&amp;test_linkkey_len);</span><br><span class="line">        <span class="keyword">if</span>(test_linkkey)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;test_linkkey================\n&quot;</span>);</span><br><span class="line">            put_buf(test_linkkey, test_linkkey_len);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>将以上代码粘贴到sdk的任一可触发调用的位置即可（如通过按键触发调用），在蓝牙连接后，调用上述代码，则会打印当前最新连接设备对应的LinkKey。</p><p>上位机配置<code>LinkKey</code>解密：暂略</p><h3 id="蓝牙数据抓包质量要求"><a href="#蓝牙数据抓包质量要求" class="headerlink" title="蓝牙数据抓包质量要求"></a>蓝牙数据抓包质量要求</h3><p>如何为有效数据包？</p><p>需要从连接过程、回连过程抓起</p><p>保证数据包解包正确，无错包。如何判断为有效解密？</p><p>一个<strong>正确的蓝牙抓包解密示例如下：</strong><br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E5%88%86%E6%9E%90%E4%BB%AA%E6%8A%93%E5%8C%85%E6%AD%A3%E7%A1%AE%E7%A4%BA%E6%84%8F.png" alt="alt text"></p><h2 id="蓝牙数据包简单说明"><a href="#蓝牙数据包简单说明" class="headerlink" title="蓝牙数据包简单说明"></a>蓝牙数据包简单说明</h2><h3 id="蓝牙基带数据包格式与类型解析"><a href="#蓝牙基带数据包格式与类型解析" class="headerlink" title="蓝牙基带数据包格式与类型解析"></a>蓝牙基带数据包格式与类型解析</h3><p><strong>问：什么是协议栈？</strong><br><strong>答曰：协议栈其实就是一堆代码。</strong></p><p>所有的蓝牙通信（无论高层配置文件、低层控制等），通过层层封装，最终都是通过 <code>Packet</code> 包的形式进行发送和接收，从而实现空中数据传输。</p><blockquote><p>从软件角度来看，蓝牙抓包分析，即通过这些空中数据包，逆向推导并分析双方的软件设计流程。</p></blockquote><p>包结构组成：<code>ACCESS CODE + HEADER + PAYLOAD</code></p><ul><li>ACCESS CODE：蓝牙数据包的前导部分，用于同步接收方的时钟，并标识一个新数据包的开始。</li><li>HEADER：指示数据包的类型，例如连接请求、断开连接、数据传输等；指示数据包的有效载荷（Payload）的长度；包含发送方和接收方的地址信息；包含如流量控制、错误检测等控制信息。</li><li>PAYLOAD：有效载荷（Payload）是数据包的实际数据部分，携带实际的内容，如音频流、文件传输、控制命令等。</li></ul><table><thead><tr><th align="center">ACCESS CODE</th><th align="center">HEADER</th><th align="center">PAYLOAD</th></tr></thead><tbody><tr><td align="center">68&#x2F;72 字节</td><td align="center">54 字节</td><td align="center">0~2745 字节</td></tr></tbody></table><p><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E5%88%86%E6%9E%90%E4%BB%AA%E6%8A%93%E5%8C%85%E7%B1%BB%E5%9E%8B%E5%B1%82%E6%AC%A1.png" alt="alt text"></p><p>基带数据包有数据分组、语音分组、公共分组</p><p>其中，公共分组包含如下几种类型包：</p><ul><li><strong>ID Packet</strong>：用于蓝牙设备的寻呼、查询与响应。只有ACCESSCODE的packet。inquiry msg就是一个ID Packet。</li><li><strong>NULL Packet</strong>：只有ACCESS CODE和HEADER。一般来说他是用来返回链路信<br>息的，比如什么rx buffer状态，或者ARQN之类的。他不需要对端的确认。</li><li><strong>POLL Packet</strong>：和NULL Packet类似，比较大的差别就在于它需要对端回确认信息。注意tws从机不能回POLL Packet？。比如，设备在手机端音频停止后，可能会一直发POLL包，确认手机端情况，但会增加功耗？</li><li><strong>FHS Packet</strong>：包含了发送的clk信息和address信息，在page等开始的同步过程中起到了很大的作用</li><li><strong>DM1 Packet</strong>：所有逻辑链路的控制信息都需要允许这种包，也能传输数据，仅限于ACL链路中。可以认为是一种ACL的包。</li></ul><br>---<p><strong>链路控制层LC（位于RF射频物理层的上一层）</strong></p><blockquote><p>为基带数据分组提供物理连接方式为：<code>ACL（无连接）、SCO（面向连接）</code><br>面向连接的话音分组只需经过基带传输，而不到达L2CAP<br>ACL适用于数据分组包</p></blockquote><ul><li><p><strong>ACL分组</strong>：表示为 <code>D(M|H)(1|3|5)</code>；D：数据分组；M：中等速率，2:3比例FEC编码；H：高速率，无FEC编码；数字1、3、5：分组占用的时隙数</p><blockquote><p>DM1、DH1、DM3、DH3、DM5、DH5、AUX1、2-DH1,2-DH3,2-DH5以及3-DH1,3-DH3和3-DH5</p></blockquote></li><li><p><strong>SCO分组</strong>：表示为 <code>HV(1|2|3)</code>；HV：高质量语音分组；数字 1、2、3：纠错编码方式</p><blockquote><p>分别是DV和HV的packet。差别在于：HV没有CRC并且不重传，DV在data域有CRC，但是在同步数据域没有，data域的数据应当重传。（通话数据包）</p></blockquote></li><li><p><strong>eSCO分组</strong>：表示为 <code>EV(1|2|3|4|5|6)</code>；EV：扩展高质量语音分组；数字 1、2、3、4、5、6 ：分组类型和纠错编码方式</p><blockquote><p>EV3、EV4、EV5、2-EV3、2-EV5、3-EV3、3-EV5。（通话数据包）</p></blockquote></li></ul><h3 id="蓝牙数据包层次说明"><a href="#蓝牙数据包层次说明" class="headerlink" title="蓝牙数据包层次说明"></a>蓝牙数据包层次说明</h3><p>对于所抓取的蓝牙空中数据包，在<code>EllisysBluetoothAnalyzer</code>-&gt;<code>Application</code>分为以下几个<code>layer</code>层次:<br>Baseband：<br>LC：链接控制层<br>LMP：负责链路的建立、鉴权和加密等<br>L2CAP：提供数据的分段和重组，支持多种高层协议。<br>SMP：<br>SDP：</p><p>以下为应用层数据包<br>RFCOMM：串行数据<br>SCO&#x2F;eSCO Audio：<br>AT：HFP指令<br>HID：人机交互指令<br>Audio&#x2F;Vedio（音视频）：A2DP、AVRCP，基于AVDTP&#x2F;AVCTP</p><h3 id="SDP服务发现协议"><a href="#SDP服务发现协议" class="headerlink" title="SDP服务发现协议"></a>SDP服务发现协议</h3><p>暂略</p><p>发现对端所支持蓝牙配置文件</p><p>另，注册经典蓝牙uuid，比如车机用到EIR扩展服务，需要SDP通道发现、、、</p><h3 id="LMP链路管理协议"><a href="#LMP链路管理协议" class="headerlink" title="LMP链路管理协议"></a>LMP链路管理协议</h3><p>LMP：位于基带层之上，负责链路管理。</p><p>在这一层上，有哪些明显的蓝牙通信节点？暂略，通过此层界定蓝牙问题是高层软件流程或者是蓝牙底层配置？</p><h3 id="L2CAP逻辑链路控制与适配协议"><a href="#L2CAP逻辑链路控制与适配协议" class="headerlink" title="L2CAP逻辑链路控制与适配协议"></a>L2CAP逻辑链路控制与适配协议</h3><p>L2CAP：位于 LMP 之上，负责数据传输服务。</p><p>L2CAP（Logical Link Control and Adaptation Protocol）是蓝牙协议栈中的一个关键协议，位于基带层（Baseband）之上，为<strong>上层协议（如 RFCOMM、SDP、ATT 等）提供数据传输服务</strong>。L2CAP 的主要作用是将基带层提供的低层连接抽象化，为高层协议提供更灵活、更高效的传输机制。</p><p>首次配对与回连过程</p><h3 id="HFP-AT命令集"><a href="#HFP-AT命令集" class="headerlink" title="HFP-AT命令集"></a>HFP-AT命令集</h3><p>AT Exchange 是指通过 AT 命令进行的通信交换。</p><p>AT 命令（Attention Command）是一组用于控制调制解调器和其他通信设备的标准命令。</p><p>在蓝牙设备中，特别是支持 HFP（Hands-Free Profile）的设备，AT 命令用于控制各种功能，如接听电话、挂断电话、调整音量、开启或关闭 SIRI 等。</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><code>AT + BVRA=1\r</code></td><td align="center">打开SIRI</td><td align="center"></td></tr><tr><td align="center"><code>AT + BVRA=0\r</code></td><td align="center">关闭SIRI</td><td align="center"></td></tr><tr><td align="center"><code>+CIEV=&lt;event&gt;,&lt;value&gt;</code></td><td align="center">报告事件类型及对应的值</td><td align="center">涉及通话状态事件变化较多</td></tr><tr><td align="center"><code>AT + VTS=123\r</code></td><td align="center">发送DTMF音</td><td align="center"></td></tr><tr><td align="center"><code>AT + CLIP=1\r</code></td><td align="center">开启来电显示</td><td align="center"></td></tr><tr><td align="center"><code>AT + BTRH=1\r</code></td><td align="center">设置耳机音量为最大</td><td align="center"></td></tr><tr><td align="center"><code>AT + BTRH=0\r</code></td><td align="center">设置耳机音量为最小</td><td align="center"></td></tr><tr><td align="center"><code>AT + CHUP\r</code></td><td align="center">挂断电话</td><td align="center"></td></tr><tr><td align="center"><code>AT + CHLD=0\r</code></td><td align="center">接听电话</td><td align="center"></td></tr><tr><td align="center"><code>AT + CHLD=1\r</code></td><td align="center">呼叫等待</td><td align="center"></td></tr><tr><td align="center"><code>AT + CHLD=2\r</code></td><td align="center">呼叫保持</td><td align="center"></td></tr><tr><td align="center"><code>AT + CHLD=3\r</code></td><td align="center">切换通话</td><td align="center"></td></tr><tr><td align="center"><code>AT + CNUM\r</code></td><td align="center">查询当前通话号码</td><td align="center"></td></tr><tr><td align="center"><code>AT + CMER=3,0,0,1\r</code></td><td align="center">开启事件报告</td><td align="center"></td></tr><tr><td align="center"><code>AT + VGS=15\r</code></td><td align="center">设置麦克风增益</td><td align="center"></td></tr><tr><td align="center"><code>AT + VGM=15\r</code></td><td align="center">设置扬声器增益</td><td align="center"></td></tr><tr><td align="center"><code>AT + BIA=1,1,1,1,1\r</code></td><td align="center">设置电池状态报告</td><td align="center"></td></tr><tr><td align="center"><code>AT + BCS=1\r</code></td><td align="center">设置连接状态报告</td><td align="center"></td></tr><tr><td align="center"><code>AT + BCC\r</code></td><td align="center">断开连接</td><td align="center"></td></tr></tbody></table><h2 id="经典蓝牙数据包节点分析"><a href="#经典蓝牙数据包节点分析" class="headerlink" title="经典蓝牙数据包节点分析"></a>经典蓝牙数据包节点分析</h2><h3 id="蓝牙搜索与配对、连接过程"><a href="#蓝牙搜索与配对、连接过程" class="headerlink" title="蓝牙搜索与配对、连接过程"></a>蓝牙搜索与配对、连接过程</h3><p>Inquiry、paging、加密、获取厂商</p><p>抓包对应蓝牙上层业务的事件为哪些？</p><p>通过蓝牙分析<code>LMP Start Encryption Request</code>命令，初步界定是底层连接，还是协议层的问题。如下所示：<br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E7%95%8C%E5%AE%9A.png" alt="蓝牙连接异常问题界定示意"></p><h3 id="蓝牙回连过程"><a href="#蓝牙回连过程" class="headerlink" title="蓝牙回连过程"></a>蓝牙回连过程</h3><p>Paging<br>ID Packet<br>FHS Packet</p><p>LMP Features Exchange</p><p>可能在此流程中产生的问题、差异有哪些？（如回连失败、两端同时对连失败等问题</p><h3 id="蓝牙高级音频过程"><a href="#蓝牙高级音频过程" class="headerlink" title="蓝牙高级音频过程"></a>蓝牙高级音频过程</h3><p>高级音频链路正常播放示意：<br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91%E9%93%BE%E8%B7%AF%E6%AD%A3%E5%B8%B8%E6%92%AD%E6%94%BE%E7%A4%BA%E6%84%8F.png" alt="高级音频链路正常播放示意"></p><p>高级音频音量控制示意如下：<br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E5%88%86%E6%9E%90%E4%BB%AA%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6%E7%A4%BA%E6%84%8F.png" alt="蓝牙分析仪音量控制"></p><p>高级音频暂停、上下曲示意如下：<br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E5%88%86%E6%9E%90%E4%BB%AA%E6%9A%82%E5%81%9C%E6%92%AD%E6%94%BE%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%B8%8B%E6%9B%B2%E7%A4%BA%E6%84%8F.png" alt="蓝牙分析仪暂停、上下曲示意"></p><p>另外，音频停止后，可能会一直发POLL包确认对端状况，此设计下功耗大。 可以通过分析抓包确认</p><p>排查蓝牙播放 远&#x2F;近 端声音异常问题时，在蓝牙分析仪软件上抓包可以直接听歌，由此初步确认空中数据音频是否正常，再行debug。</p><p><code>：高级音频哪些包对应蓝牙上层业务的事件有哪些？</code></p><h3 id="蓝牙通话过程相关节点"><a href="#蓝牙通话过程相关节点" class="headerlink" title="蓝牙通话过程相关节点"></a>蓝牙通话过程相关节点</h3><p>来电时、播放来电号码时、挂断时、键盘输入、调节通话音量时，在蓝牙抓包上的体现是怎样的</p><p>HSP HFP</p><p>SCO&#x2F;eSCO</p><p>抓包对应蓝牙上层业务的事件为哪些？</p><h3 id="音量控制与同步"><a href="#音量控制与同步" class="headerlink" title="音量控制与同步"></a>音量控制与同步</h3><p>不同手机的音量同步范例：首次连接同步音量过程、回连时同步音量过程</p><p>从蓝牙抓包分析角度，<strong>了解不同品牌手机的蓝牙音量同步设计差异</strong></p><p>比如说，苹果手机，在加密认证或者HFP建立之前，发送音量是无效的？ 等等</p><p>暂略</p><h2 id="应用业务设计-蓝牙抓包问题分析实例"><a href="#应用业务设计-蓝牙抓包问题分析实例" class="headerlink" title="应用业务设计-蓝牙抓包问题分析实例"></a>应用业务设计-蓝牙抓包问题分析实例</h2><h3 id="音量同步-手机兼容性"><a href="#音量同步-手机兼容性" class="headerlink" title="音量同步-手机兼容性"></a>音量同步-手机兼容性</h3><p>查看蓝牙包中的 音量同步命令，以及相关配置文件通道连接包 时序的先后关系，</p><p>如：通过蓝牙抓包分析，可以看出在何种情况上，设备向手机发送音量同步指令是无效的（比如说，在a2dp通道建立之前）</p><blockquote><p>在一定程度上，说明该手机端的软件设计是忽略a2dp建立之前的音量同步指令。</p></blockquote><p>设备端可以针对这种情况，在相关条件建立、满足之后，主动再发一次音量同步即可。或其它。</p><p>或其它情况，暂不列举。通过蓝牙抓包分析，<strong>正确推导、整理不同手机厂商的软件设计差异</strong></p><h3 id="SIRI语音助手-手机兼容性"><a href="#SIRI语音助手-手机兼容性" class="headerlink" title="SIRI语音助手-手机兼容性"></a>SIRI语音助手-手机兼容性</h3><p>标准的蓝牙hfp-at指令，是at+bvra&#x3D;1是打开siri，&#x3D;0是关闭。 对于苹果是适用的。</p><ul><li>存在部分安卓手机 发bvra&#x3D;1打开，&#x3D;0关闭不了。  再发一次at+bvra&#x3D;1，才关闭。</li><li>另，如vivo手机，收到at+bvra&#x3D;1后打开了siri，然后回复ok，接着马上又回复了at+bvra&#x3D;0。  导致了设备马上回调了 siri状态为0。</li></ul><p>如下图所示，通过抓包分析，确认为手机自身软件设计不当导致的兼容性问题：</p><p><img src="/../pictures/vivo%E6%89%8B%E6%9C%BAsiri%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%8A%93%E5%8C%85.png" alt="VIVO手机回复siri异常抓包分析"></p><p>进一步确认手机兼容性软件设计行为后，可以尝试考虑从设备端来规避，从而达到目的。</p><p>但更多情况下，设备端是不可能完美适配所有手机的，那么需要<strong>从抓包分析中拿出证据说明理论不可行性</strong>。</p><blockquote><p>如果对比样机可行，那么需要抓包样机发掘差异，分析我们的软件设计流程或者分析是否有遗漏</p></blockquote><h3 id="关HFP配置，设备与手机同时回连异常"><a href="#关HFP配置，设备与手机同时回连异常" class="headerlink" title="关HFP配置，设备与手机同时回连异常"></a>关HFP配置，设备与手机同时回连异常</h3><p>蓝牙分析仪及设备端软件修改流程， </p><p>暂略</p><h3 id="蓝牙发射器播歌-接收器音频卡顿-异常"><a href="#蓝牙发射器播歌-接收器音频卡顿-异常" class="headerlink" title="蓝牙发射器播歌-接收器音频卡顿&#x2F;异常"></a>蓝牙发射器播歌-接收器音频卡顿&#x2F;异常</h3><p>当经过初步排查发射器本身的音频流数据源无异常，需要进一步界定问题音频节点时，可通过蓝牙抓包空中音频数据，可以界定以下情况：</p><ul><li>蓝牙空中链路正常，发包间隔、丢包率等正常，则可以说明数据在发射前就已经异常；基于这一点可以接着排查蓝牙编码节点前后的数据流，确认是在编码前数据存在异常，还是编码后出现的音频异常</li><li>数据流正常，蓝牙空中包出现严重丢包、发包异常等，说明蓝牙发射异常</li></ul><p>无法明确问题出现在音频流程还是蓝牙流程时，可以<strong>通过蓝牙抓包快速界定范围</strong></p><h3 id="注册RFCOMM-UUID不断开SDP通道，导致PBAP无法使用"><a href="#注册RFCOMM-UUID不断开SDP通道，导致PBAP无法使用" class="headerlink" title="注册RFCOMM-UUID不断开SDP通道，导致PBAP无法使用"></a>注册RFCOMM-UUID不断开SDP通道，导致PBAP无法使用</h3><p>具体在蓝牙抓包上是如何体现的？暂略</p><p>PBAP，即电话本，基于RFCOMM的高层配置文件</p><p>如，在汽车carplay中，需要在eir扩展服务中注册新uuid，用于标识车机服务，如苹果carplay、谷歌安卓auto</p><p>设备端设计不当，注册并连接完成后，须主动关闭SDP通道</p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="蓝牙分析仪如何抓包BLE数据包？是如何分析的？"><a href="#蓝牙分析仪如何抓包BLE数据包？是如何分析的？" class="headerlink" title="蓝牙分析仪如何抓包BLE数据包？是如何分析的？"></a>蓝牙分析仪如何抓包BLE数据包？是如何分析的？</h3><p>如何配置解密的？与经典蓝牙抓包差异？等等，暂略</p><p>以下图示指示处为LE数据包概览<br><img src="/../pictures/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E8%93%9D%E7%89%99%E5%88%86%E6%9E%90%E4%BB%AALE%E6%95%B0%E6%8D%AE%E5%8C%85%E7%95%8C%E9%9D%A2%E7%A4%BA%E6%84%8F.png" alt="alt text"></p><h3 id="蓝牙分析仪如何抓包TWS主从交互数据包？是如何分析的？通常什么场景下需要？"><a href="#蓝牙分析仪如何抓包TWS主从交互数据包？是如何分析的？通常什么场景下需要？" class="headerlink" title="蓝牙分析仪如何抓包TWS主从交互数据包？是如何分析的？通常什么场景下需要？"></a>蓝牙分析仪如何抓包TWS主从交互数据包？是如何分析的？通常什么场景下需要？</h3><h3 id="蓝牙抓包分析中，需要关注跳频、蓝牙时隙这些概念吗？有什么用？"><a href="#蓝牙抓包分析中，需要关注跳频、蓝牙时隙这些概念吗？有什么用？" class="headerlink" title="蓝牙抓包分析中，需要关注跳频、蓝牙时隙这些概念吗？有什么用？"></a>蓝牙抓包分析中，需要关注跳频、蓝牙时隙这些概念吗？有什么用？</h3><p>跳频是：1600次&#x2F;s,蓝牙时隙为：1&#x2F;1600&#x3D;625us</p><p>这些概念对抓包分析起到什么作用？</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/qq_45288500/article/details/131593410">蓝牙协议官方文档HFP v1.8 核心内容翻译解析</a></li><li><a href="https://blog.csdn.net/weixin_44260005/article/details/104880536">蓝牙电话之HFP-AT命令集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 蓝牙 </category>
          
          <category> 杰理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【杰理】杰理SDK-Makefile-编译构建下载流程分析</title>
      <link href="/2024/09/19/%E3%80%90%E6%9D%B0%E7%90%86%E3%80%91%E6%9D%B0%E7%90%86SDK-Makefile%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%BA%E4%BB%B6%E9%9B%86%E5%88%86%E6%9E%90/"/>
      <url>/2024/09/19/%E3%80%90%E6%9D%B0%E7%90%86%E3%80%91%E6%9D%B0%E7%90%86SDK-Makefile%E5%8F%8A%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%BA%E4%BB%B6%E9%9B%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习理解Makefile编译构建过程，有助于新手开发者熟悉SDK文件框架构成、配置编译链接选项、增删文件编译、了解各bin文件作用及下载升级流程、进行程序空间优化等。特别是可视化SDK，其即是基于Makefile使用命令行执行编译、下载等操作，默认不使用CodeBlock IDE。</p><p>那么本文即以杰理<code>jl701n_soundbox_release_v1.4.2/sdk</code>为例，讲述杰理SDK-Makefile及目标程序固件的编译构建过程，其它无论是可视化或非可视化SDK均可参考此篇文章。</p><p>另外，本文主要为讲述基础原理、Makefile编译构建以及程序烧录升级过程，当然也包括部分环境及相关的配置开发介绍，但并不会详细指导如何搭建开发环境。</p><h2 id="Makefile解析"><a href="#Makefile解析" class="headerlink" title="Makefile解析"></a>Makefile解析</h2><h3 id="Makefile通用结构简述"><a href="#Makefile通用结构简述" class="headerlink" title="Makefile通用结构简述"></a>Makefile通用结构简述</h3><p><em>PS: 设计 Makefile 的目的是配置通过命令行自动执行程序，代替手动的编译操作，从而实现一键编译、下载等。</em></p><p><strong>通用 Makefile 目标形式：</strong></p><ul><li><p><code>make</code>、<code>make all</code>、<code>make -j</code></p><blockquote><p>命令行执行<code>make</code>表示默认执行第一个目标，等同于<code>make all</code>（相当于执行预设的编译构建下载全流程，但不是重新编译而是增量编译）<br><code>make -j</code>表示使用最大线程数并行执行默认目标，加快编译速度</p></blockquote></li><li><p><code>make clean</code>表示清除所有编译中间文件，先执行此条指令再<code>make</code>相当于 rebuild</p><blockquote><p>在终端输入<code>make clean;make -j</code>，指示 Shell 终端串行执行此两条指令 rebuild</p></blockquote></li></ul><br><p>Makefile 通常为以下的组织形式：</p><ul><li>各项变量集合定义，包括编译器路径、编译选项、源文件路径、链接选项等</li><li>定义构建目标的层层依赖关系，以及达成目标的命令集合（会应用到以上自动化变量）</li></ul><p>从 Makefile 内容来看，自上而下，通常的结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">工具链路径/可执行程序路径</span><br><span class="line">编译参数</span><br><span class="line">全局宏定义</span><br><span class="line">头文件搜索路径集合</span><br><span class="line">源文件路径集合</span><br><span class="line">链接参数</span><br><span class="line"></span><br><span class="line">编译依赖声明集合</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">默认目标（all）：依赖目标1 ...依赖目标n（如prebuild、固件sdk.elf等）</span><br><span class="line">命令...</span><br><span class="line"></span><br><span class="line">其它目标（clean）：</span><br><span class="line">命令...（rm -rf *）</span><br><span class="line"></span><br><span class="line">依赖目标1（prebuild）：</span><br><span class="line">命令...</span><br><span class="line"></span><br><span class="line">依赖目标2（sdk.elf）：依赖目标2-1 ...依赖目标2-n</span><br><span class="line">命令...</span><br><span class="line"></span><br><span class="line">依赖目标n-n：</span><br><span class="line">命令...</span><br></pre></td></tr></table></figure><p>Makefile 作为一个编译构建工具，其构建原理相当于：定义构建目标作为树形结构的顶点，然后通过层层依赖关系得到最底层的所有命令行集合。执行完所有的命令依赖，即可完成目标。</p><br><h3 id="编译工具链路径设置"><a href="#编译工具链路径设置" class="headerlink" title="编译工具链路径设置"></a>编译工具链路径设置</h3><p>在<code>Windows</code>环境下，通常默认安装杰理工具链路径位于<code>C:/JL</code>，而<code>701-SDK/br28</code>内核的编译链可执行文件路径则位于<code>C:/JL/pi32/bin</code>，工具说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOOL_DIR := C:/JL/pi32/bin</span><br><span class="line">CC    := clang.exe                # </span><br><span class="line">CXX   := clang.exe                # 定义C、C++编译器为clang，用于生成.o目标文件</span><br><span class="line">LD    := pi32v2-lto-wrapper.exe   # 定义链接器，用于生成可执行文件</span><br><span class="line">AR    := llvm-ar.exe              # 定义归档工具，用于生成.a静态库</span><br></pre></td></tr></table></figure><br><p>除编译工具外，还有相关的辅助构建工具，其可执行程序位于<code>/SDK/tools/utils</code>，通常<strong>将此部分工具添加到系统环境变量中</strong>，便于编译时调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MKDIR := mkdir_win -p   # mkdir_win.exe，用于递归创建多级目录</span><br><span class="line">RM    := rm -rf         # rm.exe，用于删除文件/目录</span><br><span class="line">FIXBAT  := tools\utils\fixbat.exe # 用于处理 utf8-&gt;gbk 编码问题</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><p>Question：为什么在SDK里指定编译器绝对路径，而不是声明到环境变量中？但辅助构建工具却是可以添加到环境变量中？</p><blockquote><p>因为不同SDK对应的cpu内核可能不一致，其编译链虽都是clang，但存在差异，有pi32或pi32v2的，声明同名编译器到环境变量会导致混乱<br>而辅助构建工具比如创建目录、删除、打包等，则是通用的命令</p></blockquote><hr><p>工具链自带的<strong>库文件、头文件路径如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYS_LIB_DIR := C:/JL/pi32/pi32v2-lib/r3-large</span><br><span class="line">SYS_INC_DIR := C:/JL/pi32/pi32v2-include</span><br></pre></td></tr></table></figure><p><code>SYS_LIB_DIR</code>和<code>SYS_INC_DIR</code>用于编译链接时，查找系统库和头文件，通常包含了标准C库、数学库的实现以及函数声明，如<code>SYS_LIB_DIR</code>下包含<code>libc.a</code>、<code>libm.a</code>等，而<code>SYS_INC_DIR</code>下包含<code>stdint.h</code>、<code>stdio.h</code>、<code>stdlib.h</code>等。</p><br><p>以下为设置编译生成的中间文件路径，以及输出sdk.elf文件（elf描述了链接后生成的可执行文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出文件设置</span><br><span class="line">OUT_ELF   := cpu/br28/tools/sdk.elf</span><br><span class="line">OBJ_FILE  := $(OUT_ELF).objs.txt</span><br><span class="line"># 编译路径设置</span><br><span class="line">BUILD_DIR := objs</span><br></pre></td></tr></table></figure><p>其中sdk.elf是编译工具链输出的产物，而最终的.ufw固件是由<code>cpu/br28/tools/download.bat</code>对 sdk.elf 进一步处理得到的</p><h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>编译参数，通常无须过多关注，保持默认即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := \</span><br><span class="line">-target pi32v2 \</span><br><span class="line">-mcpu=r3 \</span><br><span class="line">-integrated-as \</span><br><span class="line">-flto \</span><br><span class="line">-Wuninitialized \</span><br><span class="line">-Wno-invalid-noreturn \</span><br><span class="line">-fno-common \</span><br><span class="line">-integrated-as \</span><br><span class="line">-Oz \          # 表示最大限度的编译优化</span><br><span class="line">-g \           # 生成调试信息，g0 g1 g2 g3 g，其中-g等于g3，表示最大优化</span><br><span class="line">-flto \</span><br><span class="line">-fallow-pointer-null \</span><br><span class="line">-fprefer-gnu-section \</span><br><span class="line">-Wno-shift-negative-value \</span><br><span class="line">-Wundef \</span><br><span class="line">-Wframe-larger-than=256 \</span><br><span class="line">-Wincompatible-pointer-types \      # 警告不兼容的指针类型转换</span><br><span class="line">-Wreturn-type \                     # 警告缺少返回值的函数</span><br><span class="line">-Wimplicit-function-declaration \   # 缺失函数警告</span><br><span class="line">-mllvm -pi32v2-large-program=true \</span><br><span class="line">-fms-extensions \</span><br><span class="line">-fdiscrete-bitfield-abi \</span><br><span class="line">-w \       # 默认禁用所有编译警告</span><br></pre></td></tr></table></figure><h3 id="全局宏定义设置"><a href="#全局宏定义设置" class="headerlink" title="全局宏定义设置"></a>全局宏定义设置</h3><p>节选如下，用于定义全局的宏定义，有需要可以自行在此添加，但通常不建议这样做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEFINES := \</span><br><span class="line">-DSUPPORT_MS_EXTENSIONS \</span><br><span class="line">-DCONFIG_RELEASE_ENABLE \</span><br><span class="line">-DCONFIG_CPU_BR28 \</span><br><span class="line">    ...</span><br><span class="line">    -DCONFIG_SOUNDBOX \</span><br><span class="line">-DEVENT_HANDLER_NUM_CONFIG=2 \</span><br><span class="line">-DEVENT_TOUCH_ENABLE_CONFIG=0 \</span><br><span class="line">-DEVENT_POOL_SIZE_CONFIG=256 \</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="头文件搜索路径、源文件设置"><a href="#头文件搜索路径、源文件设置" class="headerlink" title="头文件搜索路径、源文件设置"></a>头文件搜索路径、源文件设置</h3><p>二次业务开发时，新建的.h头文件，需要将其路径添加到如下，使得编译器能够找到包含的头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INCLUDES := \</span><br><span class="line">-Iinclude_lib \</span><br><span class="line">-Iinclude_lib/driver \</span><br><span class="line">    ......</span><br><span class="line">-Iapps/common \</span><br><span class="line">-Iapps/common/device \</span><br><span class="line">-Iapps/common/audio \</span><br><span class="line">-Iapps/common/audio/live_audio \</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><br><p>二次业务开发时，新建的.c源文件，需要将其路径添加到如下，使得编译器能够对源文件进行编译并链接进目标程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 需要编译的 .c 文件</span><br><span class="line">c_SRC_FILES := \</span><br><span class="line">apps/common/audio/amplitude_statistic.c \</span><br><span class="line">apps/common/audio/audio_digital_vol.c \</span><br><span class="line">apps/common/audio/audio_export_demo.c \</span><br><span class="line">apps/common/audio/audio_utils.c \</span><br><span class="line">apps/common/audio/decode/audio_key_tone.c \</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><br><p>其它用户新建的源文件，如.s、.S、.cpp等，自行添加即可，但一般不会用到（.cc .cxx .cpp都是属于C++源文件扩展名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 需要编译的 .S 文件</span><br><span class="line">S_SRC_FILES := \</span><br><span class="line">apps/soundbox/sdk_version.z.S \</span><br><span class="line"></span><br><span class="line"># 需要编译的 .s 文件</span><br><span class="line">s_SRC_FILES :=</span><br><span class="line"></span><br><span class="line"># 需要编译的 .cpp 文件</span><br><span class="line">cpp_SRC_FILES :=</span><br><span class="line"></span><br><span class="line"># 需要编译的 .cc 文件</span><br><span class="line">cc_SRC_FILES :=</span><br><span class="line"></span><br><span class="line"># 需要编译的 .cxx 文件</span><br><span class="line">cxx_SRC_FILES :=</span><br></pre></td></tr></table></figure><h3 id="链接参数设置（添加静态库时用到）"><a href="#链接参数设置（添加静态库时用到）" class="headerlink" title="链接参数设置（添加静态库时用到）"></a>链接参数设置（添加静态库时用到）</h3><p>节选如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 链接参数</span><br><span class="line">LFLAGS := \</span><br><span class="line">--plugin-opt=-pi32v2-always-use-itblock=false \</span><br><span class="line">--plugin-opt=-enable-ipra=true \</span><br><span class="line">--gc-sections \         # 删除未使用的section，减少程序占用</span><br><span class="line">--start-group \         # </span><br><span class="line">cpu/br28/liba/cpu.a \</span><br><span class="line">cpu/br28/liba/system.a \</span><br><span class="line">    ...</span><br><span class="line">    # 添加静态库时，按需求添加在--start-group和--end-group之间</span><br><span class="line">    ...</span><br><span class="line"> cpu/br28/liba/res.a \</span><br><span class="line">--end-group \           # 与--start-group搭配</span><br><span class="line">-Tcpu/br28/sdk.ld \     # 指定链接脚本 sdk.ld，控制内存布局和段定位</span><br><span class="line">-M=cpu/br28/tools/sdk.map \ # 配置生成map文件，记录链接信息，用于调试分析</span><br><span class="line">--plugin-opt=mcpu=r3 \</span><br><span class="line">--plugin-opt=-mattr=+fprev1 \   </span><br></pre></td></tr></table></figure><p>核心点是注意<code>--start-group</code>和<code>--end-group</code>，此组参数的作用是<strong>保证顺序链接、控制不同库文件中的同名函数&#x2F;符号优先级、避免多个库中同名符号冲突</strong></p><blockquote><p>进行库添加时，规范库的链接顺序<br>如，打补丁需要添加新的静态库时，须注意。顺序不当，有可能会导致链接报错。</p></blockquote><br><p>比如如下，链接器会优先从 liba.a 中查找 函数&#x2F;变量 实现，然后是 libb.a，最后是 libc.a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--start-group</span><br><span class="line">liba.a</span><br><span class="line">libb.a</span><br><span class="line">libc.a</span><br><span class="line">--end-group</span><br></pre></td></tr></table></figure><h3 id="预构建流程"><a href="#预构建流程" class="headerlink" title="预构建流程"></a>预构建流程</h3><p>在<code>Makefile</code>所在目录终端，输入命令<code>make -j</code>，即开始编译，其中<code>all</code>是默认目标，而<code>pre_build</code>是其依赖的第一个目标，即每开始正式编译前，都会先进行一次预构建过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">all: pre_build $(OUT_ELF)</span><br><span class="line">$(info +POST-BUILD)</span><br><span class="line">$(QUITE) $(RUN_POST_SCRIPT) sdk</span><br><span class="line"></span><br><span class="line"># 预构建</span><br><span class="line">pre_build:</span><br><span class="line">$(info +PRE-BUILD)</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/sdk_used_list.c -o cpu/br28/sdk_used_list.used</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/sdk_ld.c -o cpu/br28/sdk.ld</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/tools/download.c -o $(POST_SCRIPT)</span><br><span class="line">$(QUITE) $(FIXBAT) $(POST_SCRIPT)</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/tools/isd_config_rule.c -o cpu/br28/tools/isd_config.ini</span><br></pre></td></tr></table></figure><p><strong>预构建流程是杰理SDK编译前的必要步骤</strong>，其主要作用包括以下：</p><ul><li>处理<code>sdk_used_list.c</code>得到<code>sdk_used_list.used</code>，在链接参数中会引用此文件，主要是起到记录、声明作用<blockquote><p>链接参数<code>--plugin-opt=-used-symbol-file=cpu/br28/sdk_used_list.used</code><br>表示链接器会去匹配寻找该文件里的符号（函数&#x2F;变量声明），将这个符号在库中的实现链接到<code>sdk.ld</code>指定的地址。</p></blockquote></li></ul><br><ul><li><p>处理<code>cpu/br28/tools/sdk_ld.c</code>得到<code>sdk.ld</code>，主要是生成链接脚本，控制内存布局</p></li><li><p>处理<code>cpu/br28/tools/download.c</code>得到<code>download.bat</code>，生成顶层下载脚本</p><blockquote><p>从sdk.elf提取不同节，得到相应的二进制文件，并组合成app.bin等操作<br>调用子脚本download.bat，进行二进制文件打包和程序下载流程</p></blockquote></li></ul><br><ul><li><p><code>$(FIXBAT) $(POST_SCRIPT)</code> 调用fixbat.exe对download.bat处理编码转换问题</p></li><li><p>处理 cpu&#x2F;br28&#x2F;tools&#x2F;isd_config_rule.c 得到 isd_config.ini</p><blockquote><p>子脚本download.bat 调用 isd_download.exe 进行实际的flash下载（isd_config.ini为下载配置文件）<br>如：<code>..\..\isd_download.exe ..\..\isd_config.ini -tonorflash -dev br28 -boot 0x120000 -div8 -wait 300 -uboot ..\..\uboot.boot -app ..\..\app.bin -res tone.cfg ..\..\cfg_tool.bin ..\..\eq_cfg_hw.bin p11_code.bin -uboot_compress</code></p></blockquote></li></ul><br><h3 id="源文件构建流程"><a href="#源文件构建流程" class="headerlink" title="源文件构建流程"></a>源文件构建流程</h3><ul><li>使用通配符和转换规则，使<code>c_OBJS, S_OBJS, s_OBJS, cpp_OBJS, cxx_OBJS, cc_OBJS</code>分别映射包含所有源文件编译生成对应的 .o 目标文件</li><li>定义<code>OBJS</code>包含所有类型的目标文件；定义<code>DEP_FILES</code>包含所有的.d依赖文件，用于增量编译判断用。</li><li>修改 OBJS 和 DEP_FILES 的值，增加BUILD_DIR前缀，使得所有构建过程输出都位于BUILD_DIR目录下</li><li><code>VERBOSE</code>控制编译过程输出详细日志，默认为0，可设置为1，如<code>make VERBOSE=1</code>; <code>LINK_AT</code>用于决定是否使用file函数</li><li>定义构建伪目标<code>all、pre_build、clean</code>，规则、编译、依赖文件包含等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all依赖于pre_build和OUT_ELF（即sdk.elf）（层层目标依赖，直至源文件-&gt;目标文件的编译）</span><br><span class="line">直接输入make时，默认执行make all。</span><br><span class="line">其执行完编译链接流程后，最后调用脚本`cpu\br28\tools\download.bat`进行下载</span><br><span class="line"></span><br><span class="line">pre_build用于执行预处理步骤，如生成配置文件、链接脚本、下载脚本</span><br><span class="line"></span><br><span class="line">clean用于清理构建过程产生的中间文件，如rm -rf BUILD_DIR xxx</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="链接脚本、固件打包程序、下载脚本解析"><a href="#链接脚本、固件打包程序、下载脚本解析" class="headerlink" title="链接脚本、固件打包程序、下载脚本解析"></a>链接脚本、固件打包程序、下载脚本解析</h3><h4 id="sdk-ld-c分析"><a href="#sdk-ld-c分析" class="headerlink" title="sdk_ld.c分析"></a>sdk_ld.c分析</h4><p>maskrom_stubs.ld</p><p>涉及到 update_flag VM区 等的地址链接定位</p><p>涉及到 配置 代码放RAM 的链接配置</p><h4 id="cpu-brxx-tools-download-c分析"><a href="#cpu-brxx-tools-download-c分析" class="headerlink" title="cpu&#x2F;brxx&#x2F;tools&#x2F;download.c分析"></a>cpu&#x2F;brxx&#x2F;tools&#x2F;download.c分析</h4><p>暂无</p><p>说明如何打包固件等</p><h4 id="子脚本download-bat分析"><a href="#子脚本download-bat分析" class="headerlink" title="子脚本download.bat分析"></a>子脚本download.bat分析</h4><p>在可视化SDK中，子脚本download.bat 已经合并进 download.c 了</p><p>执行实际的下载流程</p><h3 id="下载-升级固件构成分析"><a href="#下载-升级固件构成分析" class="headerlink" title="下载&#x2F;升级固件构成分析"></a>下载&#x2F;升级固件构成分析</h3><p>由download.c以及子脚本download.bat可得到，实际下载到芯片的flash构成，以及各固件的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单备份： jl_isd.bin + VM区 + 蓝牙配置区 = 程序flash占用空间</span><br><span class="line"></span><br><span class="line">jl_isd.bin = (isd_download.exe) uboot.boot + app.bin + tone_zh.cfg + cfg_tool.bin + p11_code.bin + stream.bin</span><br><span class="line"></span><br><span class="line">app.bin = text.bin + data.bin + data_code.bin + aec.bin + aac.bin + ps_ram_data_code.bin</span><br><span class="line"></span><br><span class="line">update.ufw = jl_isd.ufw = ufw_make.exe (jl_isd.fw + ota.bin)</span><br></pre></td></tr></table></figure><p>VM区大小须满足 大于 提示各种升级所需的最小空间<br>其中 VM区 和 蓝牙配置区 的大小，可以在isd_config.ini中查看。</p><p>压缩代码方法： 配置能关则关，音频编解码能关尽关， 提示音文件可以改成 16bit-16KHz-单声道的mp3文件</p><p>哪些文件是烧录的，哪些文件是用于ota的，哪些文件是干嘛的？</p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="杰理CodeBlock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？哪个效率更优？"><a href="#杰理CodeBlock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？哪个效率更优？" class="headerlink" title="杰理CodeBlock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？哪个效率更优？"></a>杰理CodeBlock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？哪个效率更优？</h3><p>暂无解答</p><p>make与codeblock-IDE的构建工具 差异对比？</p><p>归根到底无论是IDE还是Makefile，都是调用同一个编译器对源文件进行编译链接，编译速度理论上无差异。但构建组织速度存在差异</p><p>Code::Blocks可以配置使用Makefile，也可以使用其内置的构建系统。另，可以通过配置ccache工具加速编译构建</p><h3 id="Maskrom的程序跟下载的固件有相关性吗？"><a href="#Maskrom的程序跟下载的固件有相关性吗？" class="headerlink" title="Maskrom的程序跟下载的固件有相关性吗？"></a>Maskrom的程序跟下载的固件有相关性吗？</h3><p>Maskrom是出厂自带的只读程序，主要用于引导启动、集成固件烧录功能等？</p><p>暂不了解 Maskrom uboot app 的详细流程</p><h3 id="可以用C-编写杰理程序吗？"><a href="#可以用C-编写杰理程序吗？" class="headerlink" title="可以用C++编写杰理程序吗？"></a>可以用C++编写杰理程序吗？</h3><p>理论上可以，只要编译器支持即可</p><p>毕竟编程语言只是程序流程描述，编译器负责将其解析其适合于芯片cpu的机器码。但越是高级的语言，其附带的特性就越多，因此会占用更多的资源。不建议用于资源紧张的嵌入式开发</p><h3 id="什么情况下需要rebuild？"><a href="#什么情况下需要rebuild？" class="headerlink" title="什么情况下需要rebuild？"></a>什么情况下需要rebuild？</h3><p>全局宏配置、功能的开启&#x2F;关闭，有可能会影响到预构建相关的文件sdk_used_list.c、sdk_ld.c、download.c、isd_config_rule.c里预编译条件变化，需要rebuild。<br>当链接静态库有更新时，必须要 rebuild。如果静态库有引用到相关的配置宏的，也需要 rebuild。</p><p>常规的.c源文件、.h头文件修改，不需要rebuild。<br>因为在Makefile中，包含进编译源文件的路径集合，已经被全部声明了依赖关系。</p><p>但静态库文件、预构建文件这部分没有被声明依赖关系的文件，即使有更新，make也不会检测到。需要rebuild，清除已有的编译中间文件，重新进行编译链接</p><h3 id="什么情况下需要擦除flash和VM？"><a href="#什么情况下需要擦除flash和VM？" class="headerlink" title="什么情况下需要擦除flash和VM？"></a>什么情况下需要擦除flash和VM？</h3><p>需要清除记忆的配置信息，如蓝牙配对信息、用户信息等，则擦除VM</p><h3 id="OTA升级前后的程序VM区大小配置不一致，会导致升级失败？"><a href="#OTA升级前后的程序VM区大小配置不一致，会导致升级失败？" class="headerlink" title="OTA升级前后的程序VM区大小配置不一致，会导致升级失败？"></a>OTA升级前后的程序VM区大小配置不一致，会导致升级失败？</h3><p>旧程序配置了VM为48K，新程序配置为64K，验证了仅有此部分差异情况下，OTA升级不成功。</p><p>可以通过分析链接脚本，查看程序的内存排布。</p><p>VM区的大小配置，会影响到全局程序区的地址偏移链接，导致对指定地址区域的升级文件校验失败？</p><p>配置 Makefile 下载时默认擦除所有： 在download.bat增加 -format all ?</p><h3 id="编译工具链-addr2line-的使用"><a href="#编译工具链-addr2line-的使用" class="headerlink" title="编译工具链 addr2line 的使用"></a>编译工具链 addr2line 的使用</h3><p>由上文解释可知，sdk.elf是链接后生成的elf文件，其包含所有编译的源文件、编译的函数、编译的变量等，通过addr2line工具，可以直接反编译出指定地址的函数名、变量名等。</p><blockquote><p>ps: map、lst 文件都是由elf文件衍生的</p></blockquote><p>addr2line工具用于将内存地址转换为源代码中的函数名和行号</p><blockquote><p>参数： -e 指定 elf文件，-a 显示地址，-f 显示函数名，-i 显示行号</p></blockquote><p>在终端（如 PowerShell ）输入命令执行示例如下：<code>addr2line -e sdk.elf -a -f  0x0011BE9E 0x00119A40 0x00119A9A 0x06003AF8</code><br><img src="/../pictures/%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5addr2line%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BD%E6%95%B0.png" alt="alt text"></p><h3 id="可视化SDK界面点击编译、擦除VM、擦除flash等，具体流程是怎样的？"><a href="#可视化SDK界面点击编译、擦除VM、擦除flash等，具体流程是怎样的？" class="headerlink" title="可视化SDK界面点击编译、擦除VM、擦除flash等，具体流程是怎样的？"></a>可视化SDK界面点击编译、擦除VM、擦除flash等，具体流程是怎样的？</h3><p>特别地，在可视化SDK根目录下，也存在一个download.bat文件</p><p>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:: 将命令的第一个参数作为xx路径</span><br><span class="line">SET PROJ_DOWNLOAD_PATH=%1</span><br><span class="line"></span><br><span class="line">:: 第二个参数用于定义环境变量是否擦除VM、FLASH</span><br><span class="line">if %2==format_flash (</span><br><span class="line">    SET FORMAT_ALL_ENABLE=1</span><br><span class="line">    SET FORMAT_VM_ENABLE=0</span><br><span class="line">)</span><br><span class="line">if %2==format_vm (</span><br><span class="line">    SET FORMAT_VM_ENABLE=1</span><br><span class="line">    SET FORMAT_ALL_ENABLE=0</span><br><span class="line">)</span><br><span class="line">if %2==download  (</span><br><span class="line">    SET FORMAT_ALL_ENABLE=0</span><br><span class="line">    SET FORMAT_VM_ENABLE=0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cpu\br27\tools\download.bat</span><br></pre></td></tr></table></figure><p>最终都会执行下载流程，区别在于设置当前终端的临时环境变量</p><h3 id="Makefile-嵌套调用与递归调用"><a href="#Makefile-嵌套调用与递归调用" class="headerlink" title="Makefile 嵌套调用与递归调用"></a>Makefile 嵌套调用与递归调用</h3><p>通过嵌套 Makefile，可以将大型项目分解成多个Makefile文件，提高可维护性和可读性：</p><ul><li>主Makefile：位于项目的根目录下，负责整体的构建流程</li><li>子Makefile：可以有多个，位于项目的子目录下，负责特定模块或组件的构建</li></ul><p>主Makefile可以通过 <code>include</code> 指令来包含合并子Makefile的内容，也可以通过 <code>$(MAKE)</code> 指令递归调用子Makefile的目标。</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 杰理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式之文件系统应用开发笔记</title>
      <link href="/2024/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文讲述个人对嵌入式文件系统的学习、理解、移植、应用等相关方面的笔记。</p><h2 id="前置思考与解答"><a href="#前置思考与解答" class="headerlink" title="前置思考与解答"></a>前置思考与解答</h2><p>个人认为，接触一个事物之前，总要带着一点疑问和思考较为好些，那么在文件系统应用与开发方面，也<strong>应该有些前置思考</strong>：</p><ul><li><p>文件系统在嵌入式开发中有哪些应用场景？</p></li><li><p>如何从零移植一个文件系统到嵌入式芯片上？移植步骤？</p></li><li><p>文件系统的代码原理？占用内存空间如何评估？时间复杂度如何评估？如何从零开始编写一个文件系统？</p></li><li><p>初始化挂载、目录读写、文件读写实现原理？与Windows的文件目录架构、Linux的文件目录架构有何异同？不同文件系统的差异？</p></li><li><p>对于非Windows兼容或者非上位机直接交互的存储设备&#x2F;文件系统，如外部Flash，如何将文件按照指定格式烧录进存储设备？</p><blockquote><p>准备源文件，选择文件系统镜像工具（杰理有提供），根据需求配置文件系统类型、簇大小、镜像大小等参数，将源文件按照指定格式生成文件系统镜像文件。</p></blockquote></li><li><p><strong>在嵌入式设备中，直接给存储设备烧录文件通常比较麻烦？有其它烧写文件系统的方法吗？如何调试与开发？</strong></p><blockquote><p>对于板载 SPI-Flash，可以直接通过SPI-Flash编程器把文件系统镜像直接烧录进去</p><p>另外，如杰理芯片（内部集成了烧录升级协议栈的），可以配置在给芯片升级时，同时将文件系统镜像烧录进去。（设备通过USB Mass Storage实现读卡器功能，大致是：设备配置为USB从机，电脑主机通过USB将设备的存储介质，如SPI-Flash识别为一个大容量设备，从而对SPI-Flash进行格式化和镜像烧写操作）</p></blockquote></li><li><p><strong>使用文件系统会遇到的问题？如何排查和解决？</strong></p><blockquote><p>嵌入式文件系统API对不同文件系统类型的支持度有所不同，需要注意（如：部分设备对FAT12的支持不完善，比如空间占用统计功能不完整）</p><p>SD卡某些情况下，会被电脑识别成损坏，但嵌入式设备能读卡，并正常播放部分歌曲（但中途可能会有卡顿、播放异常、跳歌等情况）。原因是：电脑扫描检测更完善，嵌入式设备不会做全盘的完整性检测。比如，FAT表的完整性、坏簇的检查等。</p><p>注意文件系统的文件排序与实际存储的排序（创建文件的文件号与预期调用的不符，跟扫盘逻辑有关）</p></blockquote></li><li><p><strong>在使用SD卡、MMC、SPI Flash、E2PROM等存储设备时，需要考虑什么问题？</strong></p><blockquote><p>小容量设备，选择文件系统时，要选择较小的簇大小，可以选择空间开销较少的FAT12等文件系统；<br>容量较大，则选择FAT32或者其它文件系统，选择较大的簇，减少时间开销；<br>特别小容量的存储介质，不建议上文件系统，可以自行通过底层接口，进行二进制数据读写。</p></blockquote></li><li><p>不同文件系统的扫盘、文件增删读写等操作有何区别？扫盘到底是什么？文件系统是如何扫盘的？对文件号的排序是怎样的？获取下一个文件，需要扫盘吗？上一个文件呢？</p><blockquote><p>文末解答，此处不赘述</p></blockquote></li><li><p>对于有限擦写寿命的Flash是<strong>如何实现擦写均衡的？掉电安全是如何实现的？</strong>等等原理实现？</p></li></ul><br><p><strong>以下内容为在前人的基础上作进一步总结，未完待续……，参考内容见文末站点</strong></p><hr><h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><h3 id="文件系统是什么？"><a href="#文件系统是什么？" class="headerlink" title="文件系统是什么？"></a>文件系统是什么？</h3><p>文件系统是一个<strong>中间件</strong>，用于管理和组织存储设备（如硬盘、U盘、SD卡等）的文件和目录。文件系统定义了文件如何被存储、命名、组织以及检索的方式。</p><p>文件系统向应用程序或用户提供了一系列的接口，包括对文件&#x2F;目录的创建、删除、重命名、读取、写入、移动等等操作。</p><p>文件系统向上层&#x2F;用户提供的功能包括有：文件存储、目录管理、文件属性管理、文件访问控制、文件备份、文件恢复、文件压缩、文件加密等等。</p><p><strong>文件系统概念</strong></p><ul><li><p>扇区：存储介质的最小分割单位，一次至少读取或写入一个扇区的数据。<br>文件系统建立在物理扇区之上，通常将单个或多个物理扇区组合成更大的逻辑单元，称为簇（Clust），或者块（BLOCK）。</p></li><li><p>簇（clust）：文件系统的最小管理单位。</p></li></ul><p>如果一个文件系统的簇大小为4KB，那么即使一个文件只有1KB大小，它也会占用整个4KB的簇空间。<br>如果一个文件大小为4.5KB，它将占用两个簇的空间，即8KB。一个文件的最后一簇往往是未存满的。</p><p>以32GB-U盘实验为例，检测到簇大小为16KB，创建一个空文件夹或者空文件，都会显示已用空间增加了16KB。</p><p><em><strong>无论是不是在根目录下创建，或者创建的是文件夹还是文件，其实体在数据区都会至少占用一个簇。</strong></em></p><p>PS：在容量较小的存储介质中，尽量少用或者不用文件夹，以减少空间消耗。</p><h3 id="文件系统类型概述及适用场景"><a href="#文件系统类型概述及适用场景" class="headerlink" title="文件系统类型概述及适用场景"></a>文件系统类型概述及适用场景</h3><p>FAT12 、FAT16、 FAT32 都是属于FAT文件系统</p><p>NTFS ext4</p><p>exFAT 适用于大于32GB的可移动存储设备</p><h2 id="FAT文件系统结构"><a href="#FAT文件系统结构" class="headerlink" title="FAT文件系统结构"></a>FAT文件系统结构</h2><p><img src="/../pictures/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%BB%E6%A1%86%E6%9E%B6.png" alt="alt text"></p><p>FAT文件系统由 <strong>DBR及其保留扇区、FAT1、FAT2、DATA</strong> 四个部分组成。（<em>分区被格式化时即创建该系统结构</em>）</p><p><strong>DBR及其保留扇区：</strong> DBR的含义是DOS引导记录，也称为操作系统引导记录，在DBR之后会有一些保留扇区。</p><p><strong>FAT1：</strong> FAT的含义是文件分配表，FAT32一般有两份FAT，FAT1是第一份，也是主FAT。</p><p><strong>FAT2：</strong> FAT2是FAT32的第二份文件分配表，也是FAT1的备份。</p><p><strong>DATA：</strong> DATA也就是数据区，是FAT32文件系统的主要区域，由目录区和文件数据。</p><blockquote><p>注意：FAT12&#x2F;FAT16 通常情况下根目录区位于2号簇，但FAT32文件系统并不一定，根目录区的位置偏移由引导扇区的BPB描述决定。</p></blockquote><hr><p><strong>FAT文件系统重要概念：</strong><br><strong>FAT表项：</strong> 每个 FAT 表项对应于一个簇（Cluster），包含指向下一个簇的指针，形成一个链表，用于表示文件或目录的实际存储位置。</p><blockquote><p>FAT表项的序号对应相应的簇，比如第10个FAT表项，对应10号簇<br>FAT表项的值：全零，表示该簇为空闲；0FFFFFFF表示当前簇是一个文件的末尾；其它序号值，指向当前文件数据的下一个簇所在。<br>FAT12、FAT16、FAT32的根本区别就是<strong>单个FAT表项的位数，其直接限制了簇号的最大值，所能管理的空间大小 &#x3D; 簇号Max * 簇Max大小</strong></p></blockquote><p><strong>目录项：</strong> 描述文件或目录的元数据信息，包括但不限于文件名、扩展名、属性、创建时间、最后访问时间、最后修改时间、文件大小以及文件的第一个簇号等。</p><h3 id="DBR-引导扇区及保留扇区"><a href="#DBR-引导扇区及保留扇区" class="headerlink" title="DBR 引导扇区及保留扇区"></a>DBR 引导扇区及保留扇区</h3><p>由五部分组成，分别为跳转指令、OEM代号、BPB、引导程序、结束标志</p><p><img src="/../pictures/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E5%88%86%E6%9E%90.png" alt="alt text"></p><p>如上图所示</p><ul><li><p><code>EB 3C 90</code>为跳转指令，3C 表示OS引导代码的偏移位置（非OS环境可忽略）</p></li><li><p>OEM代号：占8个字节，由创建该文件系统镜像的厂商具体安排</p></li><li><p>BPB：FAT32的BPB从DBR的第12个字节开始，占用79字节，记录了有关该文件系统的重要信息。前面53个字节是BPB，后面26个字节是扩展BPB<br>  记录的信息包括如下：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BPB</span><br><span class="line">每个扇区的字节数</span><br><span class="line">每簇的扇区数</span><br><span class="line">保留扇区数</span><br><span class="line">FAT数：一般为2</span><br><span class="line">根目录项数：FAT12/16使用，FAT32必须为0</span><br><span class="line">小扇区数：FAT12/16使用，FAT32必须为0</span><br><span class="line">媒体描述符</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">总扇区数</span><br><span class="line">每FAT扇区数：只被FAT32使用，协助决定根目录从哪里开始</span><br><span class="line">扩展标志、文件系统版本、根目录簇号、文件系统信息扇区号：只被FAT32使用</span><br><span class="line">备份引导扇区号：只被FAT32使用</span><br><span class="line">保留位</span><br><span class="line"></span><br><span class="line">扩展BPB：</span><br><span class="line">物理驱动器号、保留位、扩展引导标签</span><br><span class="line">分区序号</span><br><span class="line">卷标号</span><br><span class="line">系统ID</span><br></pre></td></tr></table></figure><p>  文件系统信息扇区位于保留扇区，记录数据区中空闲簇的个数及下一个空闲簇的簇号。（即紧跟DBR后的第一个扇区：1号扇区）</p></li><li><p>引导程序代码：FAT32的DBR引导程序占用420字节（非OS环境可忽略）</p></li><li><p>结束标志：DBR的结束标志与MBR，EBR的结束标志相同，为“55 AA”。</p></li></ul><h3 id="FAT-文件分配表"><a href="#FAT-文件分配表" class="headerlink" title="FAT 文件分配表"></a>FAT 文件分配表</h3><p><strong>FAT表是用来记录簇号的，FAT表由FAT表项构成，每个表项对应一个簇号。</strong>（根目录、目录、文件都是属于文件数据，都会以表项的形式通过链表方式记录在FAT表中）</p><blockquote><p>分区的数据区中每个簇都会映射到FAT表中的唯一一个FAT项，因为0号FAT和1号FAT被系统占用，用户的数据从2号FAT开始记录。</p></blockquote><p>FAT文件系统之所以有12，16，32不同的版本之分，其根本在于单个FAT表项的二进制位数。</p><p>以FAT16为例，每一簇在FAT表中占据2字节(二进制16位)。所以，FAT16最大可以表示的簇号为0xFFFF(十进制的65535)，以32K（最多只支持64个扇区）为簇的大小的话，FAT16可以管理的最大磁盘空间为：32KB×65535&#x3D;2048MB,这就是为什么FAT16不支持超过2GB分区的原因（DOS下）。</p><p>下图为FAT1的第一个扇区：</p><p><img src="/../pictures/FAT32%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFAT%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8%E7%A4%BA%E6%84%8F.png" alt="alt text"></p><p>文件系统擦写均衡策略，就是通过FAT表来管理的，每一个表项表示一个簇，擦写时随机选用簇来存放实际数据，而不是递增存放。</p><p>第0项和第1项即文件系统的DBR扇区及FAT表等存放的位置，从第2项开始，为0F FF FF FF，表示这是一个小文件，只占用一个簇就结束了，然后第3、4项也是的。</p><p>文件分配表，FAT32系统中，每32位就表示一个簇，簇号呈递增关系。 32位数据里的内容，则是簇链，表示文件的下一部分指向哪一个簇。 （刚初始化的文件分配表，通常都是连续的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第5簇中存放的数据是6，表示一个文件或文件夹的首簇。其内容为第6簇，表示文件内容接下来的簇位于第6簇；</span><br><span class="line">第6簇上面写的数据是7，表示接着的簇位于第7簇</span><br><span class="line">第7簇，上面写的数据是8，也就是指向第8簇</span><br><span class="line">第8簇，上面写的数据是9，也就是指向第9簇</span><br><span class="line">第9簇的内容为”0F FF FF FF”，意即该文件已至尾簇。</span><br></pre></td></tr></table></figure><p><strong>重点：FAT表追踪记录 文件内容或者文件夹 在数据区的存放连续性，并不描述文件或文件夹属性。</strong></p><h3 id="DATA-数据区"><a href="#DATA-数据区" class="headerlink" title="DATA 数据区"></a>DATA 数据区</h3><p>数据区的位置在FAT2的后面，</p><!-- 具体定位方式如下；1、通过MBR中的分区表信息得知分区的起始位置。2、通过分区中DBR得知DBR的保留扇区数以及FAT表的大小，FAT表的个数。3、通过上面的信息就可以找到数据区的起始位置，数据区 = 隐藏扇区数+DBR保留扇区+（每个FAT表扇区数*2）。 --><p>数据区的内容主要由三部分组成：<em>根目录，子目录和实际的文件数据内容</em>。在数据区中是以“簇”为单位进行存储的，<strong>通常2号簇被分配给根目录使用</strong>。</p><blockquote><p>重申：目录区和实际文件内容，在存储介质中的地址并不是递增关系，而是由FAT表记录<br>只有根目录区的位置是由引导扇区的描述数据确定的<br>其它子目录和文件的起始簇位置，由根目录区下的目录项描述（呈现树状关系）</p></blockquote><br><!-- 根据簇号得到在FAT中的扇区号和偏移：扇区号 = 簇号*4/每个扇区的字节数 + 隐藏扇区数 + 保留扇区数扇区偏移 = 簇号*4%每个扇区的字节数根据簇号得到起始扇区号：簇号起始扇区 = （簇号-2）* 每个簇的扇区数 + 隐藏扇区数 + 保留扇区数 + FAT数*每个FAT占扇区数 --><p>FAT32文件系统中，分区根目录下的文件和目录的目录项都放在根目录区中，子目录中的文件和目录的目录项都放在子目录区中，<strong>每32个字节为一个目录项（FDT）</strong></p><blockquote><p>每个目录项纪录着一个目录或文件的数据描述信息。<br>也可能是多个目录项记录一个文件或目录</p></blockquote><br><p>注意长短文件名目录项。</p><!-- 短文件名目录项：所谓短文件名既文件名的“8.3”格式，此格式支持主文件名不能超过8字节，扩展名不能超过3字节。短文件名目录始终存放在一个目录项中。FDT第1字节又表明了该文件的状态，它有如下四种取值方式：a.   00H–目录项的空目录。b.   E5H–表示该目录项曾经使用过，但文件已被删除。c.   2EH–表示子目录下的两个特殊文件 “. “或 “.. “目录项d.   其它任何字符–表示一个文件名(或目录名)的第一个字符的ASCII码值.FAT第0xB个字节可以判别是长文件目录项还是短文件目录项。 --><h2 id="嵌入式文件系统的应用"><a href="#嵌入式文件系统的应用" class="headerlink" title="嵌入式文件系统的应用"></a>嵌入式文件系统的应用</h2><p>暂无</p><h2 id="移植思路概述"><a href="#移植思路概述" class="headerlink" title="移植思路概述"></a>移植思路概述</h2><h3 id="文件系统底层接口函数适配"><a href="#文件系统底层接口函数适配" class="headerlink" title="文件系统底层接口函数适配"></a>文件系统底层接口函数适配</h3><p>底层接口，即为操作存储介质的接口。</p><p>比如SD卡，有SD卡配置初始化、块读、块写、块擦除、块指针偏移等。</p><h3 id="文件系统上层接口应用"><a href="#文件系统上层接口应用" class="headerlink" title="文件系统上层接口应用"></a>文件系统上层接口应用</h3><p>暂略</p><h2 id="嵌入式文件系统实现原理"><a href="#嵌入式文件系统实现原理" class="headerlink" title="嵌入式文件系统实现原理"></a>嵌入式文件系统实现原理</h2><p>暂略</p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="FAT文件系统中-FAT表项和目录项-的区别？"><a href="#FAT文件系统中-FAT表项和目录项-的区别？" class="headerlink" title="FAT文件系统中 FAT表项和目录项 的区别？"></a>FAT文件系统中 FAT表项和目录项 的区别？</h3><ul><li>FAT 表项是 FAT 文件系统中用于跟踪文件存储位置的信息。每个 FAT 表项对应于一个簇（Cluster），包含指向下一个簇的指针，形成一个链表，用于表示文件或目录的实际存储位置，使得系统能够追踪文件数据的连续性。<blockquote><p>只要是文件夹或者文件，其数据本身就会至少占一个簇。（FAT12&#x2F;16中，根目录只能占一个簇）</p></blockquote></li></ul><br><ul><li><p>目录项则是用来描述文件或目录的元数据信息，包括但不限于文件名、扩展名、属性、创建时间、最后访问时间、最后修改时间、文件大小以及文件的第一个簇号等。</p><blockquote><p>目录项存储在目录区（Directory Area），提供了文件或目录的基本信息，并通过指向 FAT 表中的第一个簇号来链接到文件的实际数据存储位置。</p></blockquote></li><li><p>通过结合<strong>目录项的文件首簇号，和FAT表的文件簇链</strong>，从而可以找到文件的所有连续数据。</p></li></ul><h3 id="文件系统扫盘的详细流程？"><a href="#文件系统扫盘的详细流程？" class="headerlink" title="文件系统扫盘的详细流程？"></a>文件系统扫盘的详细流程？</h3><ul><li>FAT文件系统，由上文可知，上层只知道根目录区在数据区的簇号，其它一概不知。所以每初次读取文件，都需要从根目录开始。<blockquote><p>从根目录开始，先扫描根目录下的所有目录项（含文件夹和文件的目录项）<br>然后扫根目录下的第一个子目录下的文件，再递归扫子目录下的目录，直到叶子目录。（直到当前目录下的所有目录或者文件都已经扫完）</p></blockquote></li></ul><br><p><strong>文件系统扫盘，通常是递归扫描</strong>。如果是层级扫描，那么扫描每一层不同文件夹的文件时，都须从根目录区开始重新定位。（可以是从根目录先递归文件，再递归子目录；也可以先递归终端目录的文件，再折返递归至根目录）</p><p>给文件号的排序，不取决于文件的目录项在目录区中的位置。（看文件系统上层程序的实现方式）</p><p><em><strong>PS：建议自行做实验验证</strong></em></p><h3 id="文件系统的文件增加、删减操作在底层是如何体现的？会重新更新一次FAT表吗？"><a href="#文件系统的文件增加、删减操作在底层是如何体现的？会重新更新一次FAT表吗？" class="headerlink" title="文件系统的文件增加、删减操作在底层是如何体现的？会重新更新一次FAT表吗？"></a>文件系统的文件增加、删减操作在底层是如何体现的？会重新更新一次FAT表吗？</h3><p>分配簇：创建新文件或目录时，在 FAT 表项，找到一个空闲簇，分配给新文件或目录，并在相应的目录区创建目录项以指向新分配的簇。</p><p>释放簇：删除文件或目录时，仅删除目录项，并在 FAT 表中，标记目录项指向的相关簇为空闲。而不会去清零文件数据。</p><p>调整簇链：增删改查，更新 FAT 表项以反映新的簇链。不会全局更新FAT表，而是局部更新，<strong>如同链表插入和删除节点</strong>一样。</p><p>另外，一个文件所存放的簇号，不一定就是连续的，其实这就是碎片化？</p><h3 id="文件系统中文件检索与读取？文件号排序越靠后的，检索读取时间就越长吗？"><a href="#文件系统中文件检索与读取？文件号排序越靠后的，检索读取时间就越长吗？" class="headerlink" title="文件系统中文件检索与读取？文件号排序越靠后的，检索读取时间就越长吗？"></a>文件系统中文件检索与读取？文件号排序越靠后的，检索读取时间就越长吗？</h3><p>某种程序上来说，是的，按文件号读取的话，首次指定读取指定文件号，就需要从根目录区开始扫</p><p>每扫到一个文件项，就文件号计数加一，当文件号排序累加到与指定序号一致时，即表示找到了目标文件的目录项，接着从该目录项配置中，去到介质中指定偏移地址，读取实际的文件内容。</p><ul><li>设备扫盘，实际上是<strong>扫描DATA数据区的根目录区、子目录区的所有目录项</strong>。而不会扫描文件内容。<blockquote><p>增删文件后，需要重新扫盘，给文件号重新排序，避免混乱或者错序<br>获取下一个文件或者基于当前文件的情况下，读取靠后的文件号文件时，文件系统只需要基于当前的扫盘指针，继续往后扫即可。</p></blockquote></li></ul><br><p>如果文件号排序越靠后，那么初次读取花费时间就越长。（断点续传时，会记录相应的偏移，无须重新定位文件，所以不耗时）</p><p><em><strong>在嵌入式中，如果存储了数量非常多的文件，要重视访问文件时所消耗的扫盘时间，尤其是多线程环境，如果扫盘线程优先级靠后，且文件数量多，可能会出现明显的程序运行滞后（可考虑调高优先级）</strong></em></p><p>另外，文件系统内容碎片化程度越高，访问时间也越长。</p><h3 id="磁盘碎片化是什么意思？如何理解？"><a href="#磁盘碎片化是什么意思？如何理解？" class="headerlink" title="磁盘碎片化是什么意思？如何理解？"></a>磁盘碎片化是什么意思？如何理解？</h3><p>FAT表记录的簇链，在初始化时是沿着簇号递增链接的，随着增删改次数越来越多，簇链就变得杂乱，</p><p>导致文件内容在数据区的簇号分布也是散乱的，那么每次在读取一个文件时，都要根据各种偏移或者信息，进行拼凑，导致性能下降。</p><p>磁盘碎片整理，有助于提高访问性能</p><h3 id="文件系统是如何统计空间占用的？"><a href="#文件系统是如何统计空间占用的？" class="headerlink" title="文件系统是如何统计空间占用的？"></a>文件系统是如何统计空间占用的？</h3><p>通过统计FAT表的表项值来判断</p><ul><li>空闲簇的表项值是0x0000；（FAT12是0x000，FAT16是0x0000，FAT32是0x00000000）</li><li>占用的簇的表项值是0xFFFF；（FAT12是0xFFF，FAT16是0xFFFF，FAT32是0x0FFFFFFF）</li></ul><p>对于FAT16和FAT32，都是整字节占用的，利于统计，在统计FAT表时，每两个字节或者每四个字节，就判断一下当前的簇状态，然后累计计数，<strong>占用的簇数乘以簇大小，就是文件占用的空间大小</strong>。</p><p>而 <em><strong>FAT12，是每12位表示当前的簇状态</strong></em>，稍显麻烦。可能会有些程序，没做好占用空间大小统计的兼容。比如，在<code>695N-3.1.0-SDK</code>中，如果有部分文件系统统计占用空间为0，但其它的正常。那说明是没有做好对FAT12文件系统的空间占用统计。需要打补丁</p><p>FAT16相对于FAT12，仅除了FAT表项占用的位数有差异，其它无论是在分区大小、簇大小都有优势，建议舍弃FAT12，选用FAT16。（FAT32文件系统本身的空间开销会明显偏大一些）</p><h3 id="为什么SD卡、U盘等，没有存放文件，也被使用了一部分空间？"><a href="#为什么SD卡、U盘等，没有存放文件，也被使用了一部分空间？" class="headerlink" title="为什么SD卡、U盘等，没有存放文件，也被使用了一部分空间？"></a>为什么SD卡、U盘等，没有存放文件，也被使用了一部分空间？</h3><p>文件系统本身即占一部分资源，DBR、FAT表、根目录区；</p><p>另外，SD卡本身也有保留空间，</p><h3 id="文件系统的擦写均衡是如何实现的？"><a href="#文件系统的擦写均衡是如何实现的？" class="headerlink" title="文件系统的擦写均衡是如何实现的？"></a>文件系统的擦写均衡是如何实现的？</h3><p>通过FAT表，FAT表记录了各簇的使用情况，在增删改时，可以调整随机使用不同的簇，而不是从前往后、一直递增地使用簇。</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.cnblogs.com/Chary/p/12981056.html">博客园-详解FAT32文件系统</a></li><li><a href="https://blog.csdn.net/winafa/article/details/115319185">经典FAT文件系统格式详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【USB】USB插拔检测原理及应用</title>
      <link href="/2024/08/31/%E3%80%90USB%E3%80%91USB%E6%8F%92%E6%8B%94%E6%A3%80%E6%B5%8B/"/>
      <url>/2024/08/31/%E3%80%90USB%E3%80%91USB%E6%8F%92%E6%8B%94%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文大部分技术原理内容摘选自USB中文网</p><h2 id="USB2-0"><a href="#USB2-0" class="headerlink" title="USB2.0"></a>USB2.0</h2><p>USB供电电平为5V，通信电平为3.3V，上拉通常是3.3V上拉。（5V电平接10K上拉电阻）</p><ul><li>USB主机端D+和D-均有一个15K的下拉电阻</li><li>低速设备端D-上拉一个1.5K的电阻</li><li>高速&#x2F;全速设备端D+上拉一个1.5K的电阻</li></ul><p><img src="/../pictures/USB-2.0%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%B7%AF%E5%9B%BE.png" alt="alt text"></p><h3 id="USB2-0设备连接状态检测"><a href="#USB2-0设备连接状态检测" class="headerlink" title="USB2.0设备连接状态检测"></a>USB2.0设备连接状态检测</h3><p>USB设备插入到主机端口后，会有以下一个典型流程：</p><ul><li>设备端检测到主机的VBus-5V供电后，D+&#x2F;D-由<code>SE0状态</code>转为<code>挂接3.3V上拉电阻</code>（低速设备端D-，高速&#x2F;全速设备端D+）</li><li>主机端读取D+&#x2F;D-电平变化，识别USB2.0-低速&#x2F;全速 设备接入</li><li>USB主机对插入的设备发送复位信号，进行设备复位</li></ul><br><ul><li>如果是主机上电前已连接的设备，设备端通过检测到主机下发的第一个复位信号来判断自身已连接</li><li>动态接入，设备端检测到自身的VBus电压升高（&gt;&#x3D;4.01V），判断自身已连接</li><li>设备端也可检测 D+&#x2F;D- 电平变化，判断是否已连接</li></ul><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USB2.0高速设备在设备的连接检测时，是以USB2.0全速的工作状态进行通讯连接的。</span><br><span class="line"></span><br><span class="line">在USB主机端对设备复位后，USB高速设备会主动发送USB高速协商信号；</span><br><span class="line">主机端如果正确识别，则工作在全速状态的USB2.0高速设备切换到高速状态。</span><br></pre></td></tr></table></figure><p><strong>SE0状态：</strong></p><h3 id="USB2-0设备断开状态检测"><a href="#USB2-0设备断开状态检测" class="headerlink" title="USB2.0设备断开状态检测"></a>USB2.0设备断开状态检测</h3><ul><li>主机端-设备断开检测</li></ul><p>低速、全速设备：</p><p>高速设备：主机通过检测帧开始的包结束来判断设备是否断开，帧开始的间隔是125us，所以设备断开后，主机最多在125us就可以检测到设备断开</p><h2 id="USB3-0"><a href="#USB3-0" class="headerlink" title="USB3.0"></a>USB3.0</h2><h2 id="USB-OTG设备插拔检测-主从机识别软件方案"><a href="#USB-OTG设备插拔检测-主从机识别软件方案" class="headerlink" title="USB-OTG设备插拔检测-主从机识别软件方案"></a>USB-OTG设备插拔检测-主从机识别软件方案</h2><p>以杰理方案为例，周期轮询</p><p>如果设备一个USB端口同时使能 主机和从机 模式的话，则需要轮询识别接入的设备是主机还是从机</p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.usbzh.com/article/detail-332.html">USB通讯基础入门概述</a></li><li><a href="https://www.usbzh.com/article/detail-634.html#:~:text=USB%E4%B8%BB%E6%9C%BA%E7%AB%AF%E6%A0%B9%E6%8D%AED+">USB2.0设备连接状态的检测</a></li><li><a href="https://blog.csdn.net/qq_37391577/article/details/131945122#:~:text=USB%203.0%E7%9A%84%E6%8E%A5%E5%8F%A3">USB协议之一 设备连接检测、断开检测</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> USB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【蓝牙】BLE Profile概述</title>
      <link href="/2024/08/03/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99BLE-Profile%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/08/03/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99BLE-Profile%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>未完待续</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文框架主要分为以下几部分：</p><ul><li>BLE协议栈框架简述</li><li>BLE-GATT层相关概念简单介绍，包括profile、service等</li><li>结合代码分析GATT层的概念</li><li>思考与拓展</li></ul><h2 id="BLE协议栈框架"><a href="#BLE协议栈框架" class="headerlink" title="BLE协议栈框架"></a>BLE协议栈框架</h2><p>暂略</p><h2 id="BLE-GATT层相关概念"><a href="#BLE-GATT层相关概念" class="headerlink" title="BLE-GATT层相关概念"></a>BLE-GATT层相关概念</h2><p>GATT（Generic Attribute Profile）定义了一种用于数据交换的分层结构，包括<strong>Profile（通用属性配置文件）、Service（服务）、Characteristic（特征值）、Descriptor（描述符）</strong>等。</p><p>一个BLE设备可以有多个服务，每个服务可以包含多个特征值，每个特征值可以有零个或多个特征描述符。</p><p>例如，一个健康监测设备可能有一个心率服务，该服务有一个心率测量特征值，这个特征值可能有一个描述符来指示测量结果的格式。</p><p>特征声明是特征值的描述和定义。它包含了特征值的属性（如读、写、通知）、权限、以及可能的描述符等信息，定义如何访问和使用特征值。</p><h3 id="Profile（配置文件）"><a href="#Profile（配置文件）" class="headerlink" title="Profile（配置文件）"></a>Profile（配置文件）</h3><p>Profile，即配置文件，定义了BLE设备的功能和数据交换规则。</p><p>包括关键概念有：服务、特征值、特征描述符、属性、配置文件角色、数据交换格式、安全和配对等。</p><h3 id="Service（服务）"><a href="#Service（服务）" class="headerlink" title="Service（服务）"></a>Service（服务）</h3><p>Service（服务）是一组特征值的组合，每个服务都有一个唯一的标识符UUID，使得客户端可以标准化识别服务。</p><p>服务可以包含多个特征值，特征值可以包含多个特征描述符（Descriptors）。</p><p>服务本身没有直接的访问权限，但它们包含的特征值可以具有不同的访问权限，如只读、可写、可通知等。</p><br><p><strong>句柄：</strong> 服务句柄（Service Handle）是一个用于唯一标识服务的数字。每个服务、特征值（Characteristic）、以及特征描述符（Descriptor）在GATT数据库中都有一个唯一的句柄值。</p><ul><li>在GATT数据库，即<code>profile_data</code>中，句柄值通常会从1开始，然后依次增加。</li><li>服务句柄通常与其他属性的句柄一起定义了一个服务的范围，即服务的第一个和最后一个属性句柄标识了服务的开始和结束。</li><li>服务句柄与服务的UUID相关联，UUID用于定义服务的类型和功能，而句柄用于在GATT数据库中标识服务的位置。</li></ul><br><p><strong>主服务：</strong> 主服务是GATT数据库中的顶级服务，它作为GATT层次结构的起点，包含多个特征值（Characteristics）和次级服务（Secondary Services）。</p><ul><li><p>一个主服务可以包含多个次级服务，而次级服务也可以进一步包含其他次级服务或特征值。</p></li><li><p>主服务可以被客户端设备发现，客户端设备通过扫描和查询来识别服务器端提供的服务</p><blockquote><p>在BLE设备配对和连接过程中，客户端设备首先发现主服务，然后才能进一步发现和访问服务内的特征值</p></blockquote></li><li><p>主服务在GATT数据库中定义了一个服务范围，由服务的起始句柄（Start Handle）和结束句柄（End Handle）标识</p></li></ul><h3 id="Characteristic（特征值）"><a href="#Characteristic（特征值）" class="headerlink" title="Characteristic（特征值）"></a>Characteristic（特征值）</h3><p>每个特征值都有一个唯一的UUID（Universally Unique Identifier），用于在GATT数据库中标识不同的特征值。</p><p>特征值是客户端和服务器之间数据交换的基本单元。其表示BLE设备中的一个数据项，可以是温度传感器的读数、设备的电池电量、或者其它用户自定义的数据设置通道。</p><p>客户端可以读取服务器的特征值，或者在特征值上注册通知，以接收数据更新。</p><ul><li><p>其定义了一系列特征属性（Properties），这些属性描述了特征值的行为，例如是否可读、可写、可通知（Notify）、可指示（Indicate）等。</p></li><li><p>特征值可以有零个或多个特征描述符（Descriptor），这些描述符提供了关于特征值的额外信息，例如用户友好的描述、配置参数等。</p></li><li><p>特征值具有访问权限，定义了哪些操作（如读取、写入）是被允许的。这些权限可以用于实现安全措施，如认证和加密。</p></li><li><p>特征值可以是动态的，其值随设备状态变化而变化；也可以是静态的，其值在设备使用期间保持不变。</p></li></ul><h3 id="UUID（唯一标识符）"><a href="#UUID（唯一标识符）" class="headerlink" title="UUID（唯一标识符）"></a>UUID（唯一标识符）</h3><p>蓝牙低功耗（BLE）的GATT（Generic Attribute Profile）框架中，服务（Service）、特征声明（Characteristic Declaration）、特征值（Characteristic Value）和特征描述符（Descriptor）都有各自的UUID（Universally Unique Identifier，通用唯一识别码）</p><p>BLE的服务和特征值都是通过UUID唯一标识的，并且可以通过UUID查找相关的服务和特征值</p><ul><li><p>唯一性：UUID提供了一个全球唯一的标识符，确保了不同设备或开发者定义的服务、特征值和描述符不会发生冲突。</p></li><li><p>标准化：使用UUID有助于标准化，使得不同制造商生产的设备能够通过标准化的接口进行通信和交互。</p></li></ul><p>等等</p><h3 id="Client-and-Server"><a href="#Client-and-Server" class="headerlink" title="Client and Server"></a>Client and Server</h3><p><strong>Server（服务器端）：</strong> 比如蓝牙耳机</p><ul><li>提供服务，广播服务信息，被其它设备发现</li><li>存储特征值数据，如设备参数、状态信息或者用户自定义的数据</li><li>响应客户端的数据交互，或者发送通知&#x2F;指示到客户端</li></ul><p><strong>Client（客户端）：</strong> 比如手机</p><ul><li>发现服务，请求服务信息，连接到Server访问特征值</li><li>根据实际应用，可以读取Server的特征值数据，或者写入数据到特征值</li><li>也可以订阅特征值通知，当特征值数据发生变化时，会收到通知。</li></ul><br><ul><li>一个通信会话包括一个 Server 和一个 Client</li><li>设备可以同时充作为 Server 和 Client</li><li>BLE支持一对多通信模式，一个Server可以与多个Client建立通信</li></ul><h3 id="BLE通信流程"><a href="#BLE通信流程" class="headerlink" title="BLE通信流程"></a>BLE通信流程</h3><p>发现阶段：Client扫描周围环境中的Server，通过广播包发现服务。<br>连接阶段：Client发起连接请求，Server接受连接后，两者建立通信链路。<br>服务和特征值发现：Client通过读取操作获取Server上的服务列表，进一步发现服务内的特征值。<br>数据交互：Client根据需要读取或写入特征值，Server响应这些请求并提供数据或确认。<br>通知和指示：Server可以通过特征值向Client发送通知或指示，Client接收并处理这些更新。</p><h3 id="GATT层概念小结"><a href="#GATT层概念小结" class="headerlink" title="GATT层概念小结"></a>GATT层概念小结</h3><p>BLE定义了一系列的标准服务，其可以看作是特定应用场景下的profile，如Heart Rate Service、Battery Service等都是标准服务</p><p><strong>标准服务和特征值：</strong></p><p>标准服务和特征值的 UUID 通常为 16 位。<br>16位 UUID 通常用于表示标准的服务和特征值。这种 UUID 的格式为 0xXXXX，其中 XXXX 是一个四位的十六进制数。<br>16位 UUID 的完整形式为 0000XXXX-0000-1000-8000-00805F9B34FB。</p><p>例如，Battery Service 的 UUID 为 0x180F，其中包含的 Battery Level 特征值的 UUID 为 0x2A19。</p><p><strong>自定义服务和特征值：</strong></p><p>自定义服务和特征值的 UUID 可以为 16 位或 128 位。<br>例如，一个自定义的服务 UUID 可能是 128 位的，而该服务下的特征值也可以是 128 位的 UUID，或者其中一个为 16 位，另一个为 128 位。</p><p>128位 UUID 通常用于表示自定义的服务和特征值。这种 UUID 的格式为一组 32 位的十六进制数字，以连字号分为五段。<br>128位 UUID 的格式为 XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX。</p><h2 id="嵌入式BLE之业务应用层开发"><a href="#嵌入式BLE之业务应用层开发" class="headerlink" title="嵌入式BLE之业务应用层开发"></a>嵌入式BLE之业务应用层开发</h2><p>以下为一项目范例BLE广播及连接示意</p><p><img src="/../pictures/20240803-BLE%E5%B9%BF%E6%92%AD%E8%BF%9E%E6%8E%A5%E5%AF%B9%E6%8E%A5%E5%9B%BE.png" alt="alt text"></p><h3 id="BLE的广播包设置及分析"><a href="#BLE的广播包设置及分析" class="headerlink" title="BLE的广播包设置及分析"></a>BLE的广播包设置及分析</h3><p>0x02010609FF00008AE088E655540505DAF58F010201061409736F756E64636F72652053656C656374203253</p><table><thead><tr><th>LEN</th><th>TYPE</th><th>VALUE</th></tr></thead><tbody><tr><td>2</td><td>0x01</td><td>0x06</td></tr><tr><td>9</td><td>OxFF</td><td>0x00008AE088E65554</td></tr><tr><td>5</td><td>0x05</td><td>0xDAF58F01</td></tr><tr><td>2</td><td>0x01</td><td>0x06</td></tr><tr><td>20</td><td>0x09</td><td>0x736F756E64636F72652053656C656374203253</td></tr></tbody></table><ul><li><p>LEN: 0x02 (2字节)   TYPE: 0x01 (Flags)  VALUE: 0x06<br>这通常表示设备的发现模式，其中0x06通常表示设备支持 BLE 仅连接模式。</p></li><li><p>LEN: 0x09 (9字节)   TYPE: 0xFF (Manufacturer Specific Data) VALUE: 0x00008AE088E65554<br>这是制造商特定的数据，通常包含公司标识符和产品特定的信息</p></li><li><p>LEN: 0x05 (5字节)TYPE: 0x05 (Service Data)VALUE: 0xDAF58F01（低位在前）<br>TYPE 0x05: 表示广播数据包的类型为 Service UUID；VALUE 0xDAF58F01: 表示一个服务的 UUID。</p></li><li><p>LEN: 0x02 (2字节)   TYPE: 0x01 (Flags)  VALUE: 0x06</p><blockquote><p>重复了，可能是设置错误？</p></blockquote></li><li><p>LEN: 0x14 (20字节) TYPE: 0x09 (Local Name)  VALUE: 0x736F756E64636F72652053656C656374203253</p><blockquote><p>设备的本地名称，解码为字符串<code>soundcore Select 2S</code>。</p></blockquote></li></ul><h3 id="Profile-data解析"><a href="#Profile-data解析" class="headerlink" title="Profile_data解析"></a>Profile_data解析</h3><p>以下为一profile_data示例，从行列角度描述，有：</p><p>长度表示、类型表示、服务句柄、UUID（2字节或者16字节）</p><ul><li>服务声明：</li><li>第一个特征值声明：</li><li>第一个特征值值：</li><li>第二个特征值声明：</li><li>第二个特征值值：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> profile_data[] = &#123;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0x0001 PRIMARY_SERVICE  1800</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x18</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CHARACTERISTIC,  2a00, READ | WRITE | DYNAMIC, */</span></span><br><span class="line">    <span class="comment">// 0x0002 CHARACTERISTIC 2a00 READ | WRITE | DYNAMIC</span></span><br><span class="line">    <span class="number">0x0d</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x28</span>, <span class="number">0x0a</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>,</span><br><span class="line">    <span class="comment">// 0x0003 VALUE 2a00 READ | WRITE | DYNAMIC</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0x0004 PRIMARY_SERVICE  ae30</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x28</span>, <span class="number">0x30</span>, <span class="number">0xae</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CHARACTERISTIC,  ae01, WRITE_WITHOUT_RESPONSE | DYNAMIC, */</span></span><br><span class="line">    <span class="comment">// 0x0005 CHARACTERISTIC ae01 WRITE_WITHOUT_RESPONSE | DYNAMIC</span></span><br><span class="line">    <span class="number">0x0d</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x28</span>, <span class="number">0x04</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xae</span>,</span><br><span class="line">    <span class="comment">// 0x0006 VALUE ae01 WRITE_WITHOUT_RESPONSE | DYNAMIC</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xae</span>,</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 0x0021 PRIMARY_SERVICE  E49A25F8-F69A-11E8-8EB2-F2801F1B9FD1</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x28</span>, <span class="number">0xd1</span>, <span class="number">0x9f</span>, <span class="number">0x1b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0xf2</span>, <span class="number">0xb2</span>, <span class="number">0x8e</span>, <span class="number">0xe8</span>, <span class="number">0x11</span>, <span class="number">0x9a</span>, <span class="number">0xf6</span>, <span class="number">0xf8</span>, <span class="number">0x25</span>, <span class="number">0x9a</span>, <span class="number">0xe4</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* CHARACTERISTIC,  E49A25E0-F69A-11E8-8EB2-F2801F1B9FD1, WRITE_WITHOUT_RESPONSE | DYNAMIC | NOTIFY, */</span></span><br><span class="line">    <span class="comment">// 0x0022 CHARACTERISTIC E49A25E0-F69A-11E8-8EB2-F2801F1B9FD1 WRITE_WITHOUT_RESPONSE | DYNAMIC | NOTIFY</span></span><br><span class="line">    <span class="number">0x1b</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x28</span>, <span class="number">0x14</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0xd1</span>, <span class="number">0x9f</span>, <span class="number">0x1b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0xf2</span>, <span class="number">0xb2</span>, <span class="number">0x8e</span>, <span class="number">0xe8</span>, <span class="number">0x11</span>, <span class="number">0x9a</span>, <span class="number">0xf6</span>, <span class="number">0xe0</span>, <span class="number">0x25</span>, <span class="number">0x9a</span>, <span class="number">0xe4</span>,</span><br><span class="line">    <span class="comment">// 0x0023 VALUE E49A25E0-F69A-11E8-8EB2-F2801F1B9FD1 WRITE_WITHOUT_RESPONSE | DYNAMIC | NOTIFY</span></span><br><span class="line">    <span class="number">0x16</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x03</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0xd1</span>, <span class="number">0x9f</span>, <span class="number">0x1b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0xf2</span>, <span class="number">0xb2</span>, <span class="number">0x8e</span>, <span class="number">0xe8</span>, <span class="number">0x11</span>, <span class="number">0x9a</span>, <span class="number">0xf6</span>, <span class="number">0xe0</span>, <span class="number">0x25</span>, <span class="number">0x9a</span>, <span class="number">0xe4</span>,</span><br><span class="line">    <span class="comment">// 0x0024 CLIENT_CHARACTERISTIC_CONFIGURATION</span></span><br><span class="line">    <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x01</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* CHARACTERISTIC,  E49A28E1-F69A-11E8-8EB2-F2801F1B9FD1, READ | NOTIFY, */</span></span><br><span class="line">    <span class="comment">// 0x0025 CHARACTERISTIC E49A28E1-F69A-11E8-8EB2-F2801F1B9FD1 READ | NOTIFY</span></span><br><span class="line">    <span class="number">0x1b</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x28</span>, <span class="number">0x12</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, <span class="number">0xd1</span>, <span class="number">0x9f</span>, <span class="number">0x1b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0xf2</span>, <span class="number">0xb2</span>, <span class="number">0x8e</span>, <span class="number">0xe8</span>, <span class="number">0x11</span>, <span class="number">0x9a</span>, <span class="number">0xf6</span>, <span class="number">0xe1</span>, <span class="number">0x28</span>, <span class="number">0x9a</span>, <span class="number">0xe4</span>,</span><br><span class="line">    <span class="comment">// 0x0026 VALUE E49A28E1-F69A-11E8-8EB2-F2801F1B9FD1 READ | NOTIFY</span></span><br><span class="line">    <span class="number">0x16</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x02</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, <span class="number">0xd1</span>, <span class="number">0x9f</span>, <span class="number">0x1b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0xf2</span>, <span class="number">0xb2</span>, <span class="number">0x8e</span>, <span class="number">0xe8</span>, <span class="number">0x11</span>, <span class="number">0x9a</span>, <span class="number">0xf6</span>, <span class="number">0xe1</span>, <span class="number">0x28</span>, <span class="number">0x9a</span>, <span class="number">0xe4</span>,</span><br><span class="line">    <span class="comment">// 0x0027 CLIENT_CHARACTERISTIC_CONFIGURATION</span></span><br><span class="line">    <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x01</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化、服务及回调注册"><a href="#初始化、服务及回调注册" class="headerlink" title="初始化、服务及回调注册"></a>初始化、服务及回调注册</h3><p>根据业务需求，定义好<code>profile_data</code>后，调用<code>ble_profile_init</code>函数进行初始化，并注册服务及回调函数。</p><h3 id="业务数据处理"><a href="#业务数据处理" class="headerlink" title="业务数据处理"></a>业务数据处理</h3><p>当设备收到数据，会在相应回调中触发 case 相应的事件枚举。该枚举即对应相应的profile_data句柄。</p><p><code>att_server_init(multi_profile_data, att_read_callback, att_write_callback);</code></p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="服务句柄、特征值句柄、特征值值句柄、CCCD句柄？"><a href="#服务句柄、特征值句柄、特征值值句柄、CCCD句柄？" class="headerlink" title="服务句柄、特征值句柄、特征值值句柄、CCCD句柄？"></a>服务句柄、特征值句柄、特征值值句柄、CCCD句柄？</h3><p>在程序中通过case各种句柄事件，从而执行相应的操作</p><p>特征值句柄，用于读取元数据</p><p>特征值值句柄用于读写实际数据</p><p>CCCD句柄：特征描述符相关的标识，可选</p><h3 id="客户端不与服务器端建立连接，可以读取特征值数据吗？"><a href="#客户端不与服务器端建立连接，可以读取特征值数据吗？" class="headerlink" title="客户端不与服务器端建立连接，可以读取特征值数据吗？"></a>客户端不与服务器端建立连接，可以读取特征值数据吗？</h3><h3 id="广播跟GATT层有什么联系？广播数据包必须包含哪些数据？必须与UUID关联？配置广播有什么标准要求吗？"><a href="#广播跟GATT层有什么联系？广播数据包必须包含哪些数据？必须与UUID关联？配置广播有什么标准要求吗？" class="headerlink" title="广播跟GATT层有什么联系？广播数据包必须包含哪些数据？必须与UUID关联？配置广播有什么标准要求吗？"></a>广播跟GATT层有什么联系？广播数据包必须包含哪些数据？必须与UUID关联？配置广播有什么标准要求吗？</h3><p>扫描到的广播名称，即与0x09字段的绑定</p><p>广播数据包结构：<br>广播数据包包含了一个或多个字段，每个字段由长度、类型和数据组成。<br>类型字段定义了数据的含义，如设备名称、服务 UUID 等。</p><p>广播数据包可以是可连接的 (Connectable) 或不可连接的 (Non-connectable)。</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/m0_73219367/article/details/133804551">详细介绍 BLE GATT层 porfile属性 ：特征声明，特征值，特征描述符</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 蓝牙 </category>
          
          <category> 杰理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【USB】USB基本通讯原理概述</title>
      <link href="/2024/07/26/%E3%80%90USB%E3%80%91USB%E5%9F%BA%E6%9C%AC%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/07/26/%E3%80%90USB%E3%80%91USB%E5%9F%BA%E6%9C%AC%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="USB设备导论"><a href="#USB设备导论" class="headerlink" title="USB设备导论"></a>USB设备导论</h2><p>USB（通用串行总线）设备是一种广泛使用的接口设备，支持即插即用和热插拔功能。</p><h3 id="USB硬件接口类型"><a href="#USB硬件接口类型" class="headerlink" title="USB硬件接口类型"></a>USB硬件接口类型</h3><h3 id="常见的USB设备应用"><a href="#常见的USB设备应用" class="headerlink" title="常见的USB设备应用"></a>常见的USB设备应用</h3><p>存储设备：<br>输入设备：<br>音频设备：<br>网络设备：<br>通信设备：<br>多媒体设备：<br>扩展和集线器：<br>电源设备：<br>USB虚拟设备：</p><h3 id="USB知识框架"><a href="#USB知识框架" class="headerlink" title="USB知识框架"></a>USB知识框架</h3><p>USB分析仪、调试方法、抓包分析</p><p>USB协议基础、USB总线电平标准、总线状态、信号<br>USB描述符<br>USB传输、中断、事务<br>USB包，<br>USB硬件设计、热插拔</p><h2 id="USB基本原理介绍"><a href="#USB基本原理介绍" class="headerlink" title="USB基本原理介绍"></a>USB基本原理介绍</h2><h3 id="从接入到使用"><a href="#从接入到使用" class="headerlink" title="从接入到使用"></a>从接入到使用</h3><p>USB设备分为两类：主机（Host）和从机（Device）。</p><blockquote><p>同一USB网络中，只能存在一个主机。USB OTG允许设备在主机和从机之间切换角色。<br>比如：音箱作为USB主机时，可以读取U盘音乐；作为USB从机时，接受电脑的USB音频输入。</p></blockquote><br><p><strong>USB拔插：</strong> 主机通过检测USB D+&#x2F;D- 的电平变化感知从机的接入或者拔出</p><ul><li>主机端D+&#x2F;D-下拉15KΩ电阻到GND（0V），从机端D+&#x2F;D-上拉1.5KΩ电阻到3.3V。</li><li>当从机接入主机时，D+&#x2F;D-上的电压变为3V，双方通过电平变化就可以发现USB的拔插事件</li><li>USB拔插事件会触发主机的中断（或回调），执行从机的加载、释放过程。</li></ul><p><strong>USB枚举：</strong> 主机通过获取设备的描述符集合来识别USB设备</p><ul><li>USB连接后，主机通过访问描述符集合来识别从机并配置从机</li><li>每个USB设备都必须有遵循相应格式的描述符集合介绍自身的功能和用途，包含设备描述符、配置描述符、接口描述符、端点描述符、字符串描述符、其它特殊描述符等。</li></ul><br><p><strong>USB使用：</strong> 主机以轮询的方式发数据，从机以中断的方式接收数据</p><ul><li>USB的数据传输过程描述以及主机端为主</li></ul><br><h3 id="USB通信构建过程概述"><a href="#USB通信构建过程概述" class="headerlink" title="USB通信构建过程概述"></a>USB通信构建过程概述</h3><p><strong>主机访问指定USB设备：</strong> 主机为所有从机分配唯一的设备地址，通过地址访问从机</p><ul><li>主机给所有已连接的设备分配地址，并确保不会重复（Addr1-AddrN）</li><li>对刚接入没分配地址的从机，主机使用默认地址<code>Addr0</code>与其通信，握手后分配新地址</li></ul><br><p><strong>主机访问指定USB设备的指定功能：</strong> 主机通过<code>（设备地址，设备端点）</code>访问指定从机的指定接口&#x2F;功能。</p><ul><li>用端点（Endpoint，EP）区分USB从机的不同功能（如一个从机同时具有HID、CDC等复合功能，通过端点区分，避免冲突）</li><li>端点具有唯一性，其和从机的功能用途一一对应，主机按<strong>照端点的属性构建专用的端点通道进行通信</strong>；端点还标识了特定用途的数据传输方向</li><li>初次接入时，主从双方通过<code>（Addr0, EP0）</code>进行通信</li></ul><br><p><strong>主从双方构建读&#x2F;写通信过程：</strong> 主机用默认端点0（EP0）创建通道枚举从机，根据描述符集中的其他端点创建对应通道访问其他功能</p><ul><li>从机必须支持默认控制端点EP0，用于处理设备的配置和状态令牌，此外用其它端点来处理数据传输，如：批量（Bulk）、中断（Interrupt）、等时（Isochronous）或控制（Control）类型的端点。</li><li>初接入时，主机通过<code>（Addr0, EP0）</code>访问从机，创建EP0的端点通道，枚举并分配地址</li><li>而后主机使用<code>（Addr1, EP0）</code>重新枚举从机；根据从机提供的信息（端点、属性）创建相应的数据通道，定义通道读写方式。</li></ul><br><p><strong>主从双方通信过程：</strong> 一次完整的通信分为三个过程：请求过程（令牌包）、数据过程（数据包）和状态过程（握手包），没有数据要传输时，则跳过数据过程。每一次帧轮询周期，有以下三种通信过程情况：</p><ul><li>主机发送令牌包（Token）开始请求过程，从机数据输入至主机，主机发送状态过程至从机</li><li>主机发送令牌包（Token）开始请求过程，主机数据输出至从机，从机回复状态过程至主机</li><li>主机发送令牌包（Token）开始请求过程，无数据传输，从机回复状态过程至主机</li></ul><h3 id="USB主从详细通信过程"><a href="#USB主从详细通信过程" class="headerlink" title="USB主从详细通信过程"></a>USB主从详细通信过程</h3><p>在USB通信中，每个USB数据包开始之前，会发送前导码和同步码，确保接收方能够正确地同步并准备接收随后的数据。</p><p>每秒被分为1000个帧（Frame），主机在每帧开始前，会向所有从机广播<strong>帧起始令牌包</strong>（SOF包）</p><ul><li><p>通知所有从机，主机的USB总线正常工作</p></li><li><p>使得从机可以同步主机的时序</p></li><li><p>USB高速设备主机将帧进一步等分为8个微帧，同一帧内，8个微帧的帧号都等于当前SOF包的帧号。</p></li><li><p>PID (Packet Identifier) 字段是每个包中的重要部分，用于标识数据包的类型和状态，通常位于数据包的头部，设计考虑了错误检测，其中高四位是低四位的二进制补码。</p></li></ul><p>以下为SOF包结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_alignment=1    <span class="comment">//对齐方式为Byte</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_Token_SOF_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  bPID;          <span class="comment">// 0xA5, SOF（0101B）</span></span><br><span class="line">    <span class="type">uint16_t</span> b11FrameID:<span class="number">11</span>; <span class="comment">// 帧号</span></span><br><span class="line">    <span class="type">uint16_t</span> b5CRC:<span class="number">5</span>;       <span class="comment">// wFrameID字段（11bit）的CRC校验码</span></span><br><span class="line">&#125;USB_Token_SOF_t;</span><br></pre></td></tr></table></figure><h4 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h4><p>主机广播SOF包之后，会发送带有地址和端点信息的令牌包（Token） 来指定要访问的从机，分别有：建立令牌包（SETUP）、输出令牌包（OUT）、输入令牌包（IN）。</p><p>这三种令牌包统称为请求包，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_alignment=1    <span class="comment">//对齐方式为Byte</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_Token_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> bPID;           <span class="comment">// 0xE1, OUT    (0001B);</span></span><br><span class="line">                               <span class="number">0x69</span>, IN     (<span class="number">1001B</span>);</span><br><span class="line">                               <span class="number">0x2D</span>, SETUP  (<span class="number">1101B</span>);</span><br><span class="line">    <span class="type">uint16_t</span> b7Addr:<span class="number">7</span>;      <span class="comment">// 要访问的设备地址</span></span><br><span class="line">    <span class="type">uint16_t</span> b4Endpoint:<span class="number">4</span>;  <span class="comment">// 要访问的端点号</span></span><br><span class="line">    <span class="type">uint16_t</span> b5CRC:<span class="number">5</span>;       <span class="comment">// wFrameID字段（11bit）的CRC校验码</span></span><br><span class="line">&#125;USB_Token_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主机可以通过请求包指定要访问的从机，发起请求过程，配置从机或指示从机准备发送&#x2F;接收数据。在枚举过程中，主机使用SETUP包请求从机的信息。枚举成功后，主机使用IN包请求输入数据，OUT包请求输出数据。<br>    枚举时，在SETUP包的后面会紧跟一个8B长度的请求（Request），用于描述主机的具体意图，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_alignment=1    <span class="comment">//对齐方式为Byte</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_Request_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>  bmRequestType; <span class="comment">// 请求类型</span></span><br><span class="line">    <span class="type">uint8_t</span>  bRequest;      <span class="comment">// 具体请求，参考USB 2.0 Spec Chapter 9.4</span></span><br><span class="line">    <span class="type">uint16_t</span> wValue;        <span class="comment">// 内容和Request有关</span></span><br><span class="line">    <span class="type">uint16_t</span> wIndex;        <span class="comment">// 内容和Request有关</span></span><br><span class="line">    <span class="type">uint16_t</span> wLength;       <span class="comment">// 数据过程可传输的最大字节数</span></span><br><span class="line">&#125;USB_Request_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">bmRequestType_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> b5Recipient:<span class="number">5</span>;  <span class="comment">// 0 = Device, 1 = Interface</span></span><br><span class="line">                               <span class="number">2</span> = Endpoint, <span class="number">3</span> = Other</span><br><span class="line">                               <span class="number">4.</span><span class="number">.31</span> = Reserved</span><br><span class="line">    <span class="type">uint8_t</span> b2Type:<span class="number">2</span>;       <span class="comment">// 0 = Standard, 1 = Class</span></span><br><span class="line">                               <span class="number">2</span> = Vendor, <span class="number">3</span> = Reserved</span><br><span class="line">    <span class="type">uint8_t</span> b1Direction:<span class="number">1</span>;  <span class="comment">// 0 = Host-to-device</span></span><br><span class="line">                               <span class="number">1</span> = Device-to-host</span><br><span class="line">&#125;bmRequestType_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据过程"><a href="#数据过程" class="headerlink" title="数据过程"></a>数据过程</h4><p>请求的bmRequestType字段中，Direction标志位声明了数据要传输的方向。<br>    当请求为输出（Data OUT，Direction &#x3D; 1）时，从机接收不超过wLength字段中声明长度的数据，并根据请求的内容解析接收到的数据；当请求为输入时（Data IN，Direction &#x3D; 0）时，从机根据请求的内容发送对应的数据（不超过wLength中声明的长度）。<br>    数据包（Data Packets）的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_alignment=1    <span class="comment">//对齐方式为Byte</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_Data_Packet_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> bPID;           <span class="comment">// 0xC3, DATA0 (0011B); even</span></span><br><span class="line">                               <span class="number">0x4B</span>, DATA1 (<span class="number">1011B</span>); odd</span><br><span class="line">                               <span class="number">0x87</span>, DATA2 (<span class="number">0111B</span>); <span class="keyword">for</span> usb high speed</span><br><span class="line">                               <span class="number">0x0F</span>, MDATA (<span class="number">1111B</span>); <span class="keyword">for</span> usb high speed</span><br><span class="line">    <span class="type">uint8_t</span> bData[];        <span class="comment">// 0 ~ 8192B</span></span><br><span class="line">    <span class="type">uint16_t</span> wCRC16;        <span class="comment">// bData字段的CRC校验码</span></span><br><span class="line">&#125;USB_Data_Packet_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在USB全速设备中，数据包以DATA0、DATA1的PID交替发送。当接收方连续收到两个PID相同的DATA包时，就知道丢包了。DATA2与MDATA是USB高速设备所使用的PID</p><h4 id="状态过程"><a href="#状态过程" class="headerlink" title="状态过程"></a>状态过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_alignment=1    <span class="comment">//对齐方式为Byte</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_Handshake_t</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> bPID;           <span class="comment">// 0xD2, ACK    (0010B); 确认接收</span></span><br><span class="line">                               <span class="number">0x5A</span>, NAK    (<span class="number">1010B</span>); 没有数据要返回</span><br><span class="line">                               <span class="number">0x1E</span>, STALL  (<span class="number">1110B</span>); 无法执行的请求</span><br><span class="line">                               <span class="number">0x96</span>, NYET   (<span class="number">0110B</span>); 接收成功但无法</span><br><span class="line">                            接收下一次数据，仅在usb高速设备中使用。下</span><br><span class="line">                            次主机发送数据需要先发送PING包试探设备。</span><br><span class="line">&#125;USB_Handshake_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通信异常<br>    当从机还没准备好时主机请求数据；从机收到未知请求；端点通信数据量溢出；主机不应发送的请求；或没有数据要发送等情况时，本轮通信会直接进入状态过程，从机发送NYET&#x2F;ERR&#x2F;STALL&#x2F;NAK包。<br>    当数据传输出错时，数据的发送方停止发送数据，直到本次通信超时。</p><h4 id="USB通信过程小结"><a href="#USB通信过程小结" class="headerlink" title="USB通信过程小结"></a>USB通信过程小结</h4><p>USB的帧结构允许主机在同一帧内与多个从机进行通信。</p><p>每个USB帧以一个SOF（Start Of Frame）包开始，它标志着一个新的帧周期的开始，帧周期通常是1毫秒。</p><p>在一个帧内，主机可以与多个从机进行通信，通过令牌包（Token Packet）来发起数据传输。<br>指定 地址、端点</p><h3 id="从机属性（USB描述符）"><a href="#从机属性（USB描述符）" class="headerlink" title="从机属性（USB描述符）"></a>从机属性（USB描述符）</h3><p>描述符集描述了从机的所有功能细节，包含唯一的设备描述符，至少一个配置描述符和接口描述符，每个接口描述符至少包含一个端点描述符，此外还有其他可选的特殊描述符进行补充。</p><p>USB描述符是用来描述USB设备特性的数据结构：<br>设备描述符（Device Descriptor）</p><blockquote><p>描述整个USB设备的基本信息，如设备类型、版本号、制造商和产品信息等。</p></blockquote><p>配置描述符（Configuration Descriptor）</p><blockquote><p>描述设备的一个配置，包括设备如何被配置和使用的信息。一个配置描述符可以包含多个接口描述符。</p></blockquote><p>接口描述符（Interface Descriptor）</p><blockquote><p>描述设备的一个功能接口，如音频接口或HID接口。一个接口描述符可以包含多个端点描述符。</p></blockquote><p>端点描述符（Endpoint Descriptor）</p><blockquote><p>描述数据传输的端点，包括端点的地址、类型（如控制、批量、中断或同步流）和最大数据包大小等。<br>端点0通常用于控制传输，其他端点用于数据传输。</p></blockquote><h3 id="枚举的详细过程"><a href="#枚举的详细过程" class="headerlink" title="枚举的详细过程"></a>枚举的详细过程</h3><p>USB设备接入后，主机复位从机，使用&lt;addr0, EP0&gt;构建端点通道（Pipe）请求设备描述符，从机发送完整的设备描述符或只发送前8B内容（当EP0最大包长度只有8B）；</p><p>主机分配唯一的设备地址并发送Set Address请求，收到应答后再次复位从机；</p><p>主机再次请求完整的设备描述符，当一次请求不足以获取完整的描述符，主机会请求多次；</p><p>主机请求完整的配置描述符；</p><p>根据设备描述符和配置描述符中声明的字符串描述符索引号，请求所有字符串描述符；<br>    <br>（可选）主机请求限定符描述符，当描述符中声明了支持更高速的USB协议时，主机复位从机，用新的USB协议重新枚举从机，当获取描述符失败时，认为从机不支持此功能，按原协议重新枚举并跳过此步骤；<br>    <br>根据配置描述符中声明的集合长度，请求配置集合。其中配置集合包括配置描述符、接口描述符、端点描述符以及特殊类描述符。当从机包含多个配置描述符集合时，会多次请求。<br>    <br>主机请求选择配置（Set Configuration）；<br>    <br>主机选择接口，请求接口空闲状态（Set Idle），此时接口生效。根据接口描述符，可能会请求其他的特殊描述符（一般这些描述符是对接口描述符的补充描述）。如果从机包含多个接口，此步骤会重复多次；<br>    <br>主机知道USB设备的类型、通信方式和工作方式后，采用恰当的对策轮询USB设备。在Windows平台，主机完成枚举后会给从机派发相应的驱动（符合官方支持的设备标准）或者不派发驱动（找不到对应驱动，需要手动安装）。</p><h2 id="USB设备类别与业务应用"><a href="#USB设备类别与业务应用" class="headerlink" title="USB设备类别与业务应用"></a>USB设备类别与业务应用</h2><h3 id="PD快充协议"><a href="#PD快充协议" class="headerlink" title="PD快充协议"></a>PD快充协议</h3><p>用到专用标识快充的 引脚</p><h3 id="HID设备"><a href="#HID设备" class="headerlink" title="HID设备"></a>HID设备</h3><p>人机交互设备，最早起源于USB，后面也扩展到 蓝牙、Wi-Fi等领域概念中</p><h3 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h3><p>SPK、MIC</p><h3 id="CDC"><a href="#CDC" class="headerlink" title="CDC"></a>CDC</h3><p><code>//apps/soundbox/task</code></p><p>app-USB设备事件 》 从机事件 》 cdc处理</p><h2 id="疑惑解答及扩展思考"><a href="#疑惑解答及扩展思考" class="headerlink" title="疑惑解答及扩展思考"></a>疑惑解答及扩展思考</h2><h4 id="USB2-0接口皆只有Vcc、GND、D-、D-四个引脚，为何有低速、全速、高速之分？"><a href="#USB2-0接口皆只有Vcc、GND、D-、D-四个引脚，为何有低速、全速、高速之分？" class="headerlink" title="USB2.0接口皆只有Vcc、GND、D+、D-四个引脚，为何有低速、全速、高速之分？"></a>USB2.0接口皆只有Vcc、GND、D+、D-四个引脚，为何有低速、全速、高速之分？</h4><p>低速（Low-Speed）：1.5 Mbps（兆比特每秒）<br>全速（Full-Speed）：12 Mbps<br>高速（High-Speed）：480 Mbps</p><p>多种因素，包括硬件成本、功耗、散热、应用需求、向后兼容性、技术复杂性等。</p><p>如键盘、鼠标等，仅用低速或全速设备即可；而USB闪存、U盘等，则需要全速&#x2F;高速设备。</p><h4 id="端点与描述符的区别与联系？"><a href="#端点与描述符的区别与联系？" class="headerlink" title="端点与描述符的区别与联系？"></a>端点与描述符的区别与联系？</h4><ul><li><p>端点是USB设备中用于数据传输的实际逻辑通道。</p></li><li><p>描述符则是用来描述端点以及其他USB设备特性的数据结构。</p></li></ul><p>USB描述符在USB通信的不同阶段都会被用到，如：<br>在设备枚举时，读取设备描述符；<br>配置设置时，通过读取配置描述符，并进行配置；<br>读取接口描述符，例如HID接口、UAC接口，可以激活或禁用特定接口；<br>端点配置，根据端点描述符配置数据传输；在数据传输过程中，主机使用端点描述符中提供的信息来控制数据的发送和接收。</p><h4 id="雷电接口与USB接口的区别、联系？"><a href="#雷电接口与USB接口的区别、联系？" class="headerlink" title="雷电接口与USB接口的区别、联系？"></a>雷电接口与USB接口的区别、联系？</h4><p>USB：由多家公司合作开发，包括英特尔、微软、IBM等，目的是创建一个通用的接口标准<br>雷电接口：由英特尔和苹果公司合作开发，旨在提供一种高速数据传输接口</p><p>雷电接口：可以兼容USB设备，但提供了额外的功能和更高的性能。</p><h4 id="USB接口的端点数受到什么限制？"><a href="#USB接口的端点数受到什么限制？" class="headerlink" title="USB接口的端点数受到什么限制？"></a>USB接口的端点数受到什么限制？</h4><p>为什么有些USB设备端点数有限？</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.usbzh.com/">USB中文网</a></li><li><a href="https://blog.csdn.net/jimaofu0494/article/details/109233087">USB原理：从零基础入门到放弃</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> USB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【音频】嵌入式之音频开发知识概述</title>
      <link href="/2024/07/16/%E3%80%90%E9%9F%B3%E9%A2%91%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9F%B3%E9%A2%91%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/07/16/%E3%80%90%E9%9F%B3%E9%A2%91%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9F%B3%E9%A2%91%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>未完待续…</p><p>以一个嵌入式音频新人的角度，对日常的嵌入式音频知识作系统总结。</p><h2 id="嵌入式开发之音频知识概述"><a href="#嵌入式开发之音频知识概述" class="headerlink" title="嵌入式开发之音频知识概述"></a>嵌入式开发之音频知识概述</h2><h3 id="音频之本质概述"><a href="#音频之本质概述" class="headerlink" title="音频之本质概述"></a>音频之本质概述</h3><p>正弦波是最简单的周期性信号之一，其数学表达式非常简单，如下：</p><p><strong>y(t)&#x3D;Asin(2πft+ϕ)</strong></p><p>其中：<br>y(t) 是正弦波在时间 t 处的值。<br>A 是振幅，表示波形的最大振动幅度。<br>f 是频率，表示波形的周期性变化次数。<br>ϕ 是相位，表示波形在时间轴上的偏移。</p><p>正弦波是分析和合成其它信号的基础，因为所有的复杂信号、波形都可以看作为由不同的正弦波叠加而成。（傅里叶变换可以将波形信号分解为一系列的正弦波）</p><p><strong>模拟信号-&gt;声音的过程：</strong> 音频在模拟信号中表现为<code>一个随时间变化的电压波形</code>，该电压波形输出到喇叭（喇叭内部有音圈），会产生电流的变化，从而产生变化的磁场，使得音圈产生相应的振动；音圈的振动带动了振膜振动，在空气中形成了压力波，即声波。</p><p><strong>声音-&gt;模拟信号的过程：</strong> 声波传播使得麦克风内的声学敏感元件振动，这些振动即反映了声波的频率和幅度等。通过线圈、振膜、压电材料、电容器等，<code>将机械振动波形转化为电压的变化波形</code>，此即初始的模拟信号。可能需要麦克风内的放大器进行放大，再传输到模数转换器，被进一步转换为数字信号，便于存储、传输、或者数字处理。</p><br><p><strong>模拟信号-&gt;数字信号：</strong> </p><ol><li>采样：采样频率至少应为信号最高频率的两倍</li><li>量化：采样后的信号在幅度上被分割为有限数量的级别。每个采样值被近似到最接近的级别，这个过程称为量化。量化精度决定了数字信号的比特深度，通常为8、16、24或32比特。</li><li>编码：量化后的样本值被转换为数字代码，通常是二进制形式，以便于存储和传输</li></ol><p><strong>数字信号-&gt;模拟信号：</strong> </p><ol><li>解码：</li><li>插值：由于数字信号是离散的，插值过程用于在样本点之间生成连续的信号。这通常通过低通滤波器实现，以平滑信号并消除重建过程中可能产生的高频噪声</li><li>重建：</li></ol><p>采样率（采样的频率）、比特深度（采的样本精度）、转换误差</p><h2 id="音频格式-常识"><a href="#音频格式-常识" class="headerlink" title="音频格式&#x2F;常识"></a>音频格式&#x2F;常识</h2><h3 id="PCM（脉冲编码调制）"><a href="#PCM（脉冲编码调制）" class="headerlink" title="PCM（脉冲编码调制）"></a>PCM（脉冲编码调制）</h3><ul><li><a href="https://blog.csdn.net/qq_28258885/article/details/120197122">参照PCM数据格式详解博客链接</a></li></ul><p>采集声音从模拟信号转换成数字信号，重要的两个衡量标准就是 采样率、位数（量化精度）。</p><p>PCM数据格式常用指标：</p><ul><li>采样率：如通话采样率为8KHz，常用媒体采样率为44.1KHz 等等</li><li>位深度：一般为16bit（有65,536个等级可以用于衡量真实的模拟信号），也有24bit</li><li>字节端序：大端或者小端</li><li>声道数：单、双、2.1、3.1、5.1声道等</li><li>样本对齐方式：多通道下的样本不同声道交错对齐？</li><li>采样数据符号？<blockquote><p>如 FFmpeg中常见的PCM数据格式s16le为例：它描述的是有符号16位小端PCM数据。s表示有符号，16表示位深，le表示小端存储。</p></blockquote></li></ul><p>PCM存储数据流Stream：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 8-bit有符号单声道，分割符&quot;|&quot;分割字节，采样的范围为-128～128</span><br><span class="line">+---------+-----------+-----------+----</span><br><span class="line"> binary | 0010 0000 | 1010 0000 | ...</span><br><span class="line"> decimal| 32        | -96       | ...</span><br><span class="line">+---------+-----------+-----------+----  </span><br></pre></td></tr></table></figure><p>实现播放速度调整：加载好PCM数据后，需要送到音频设备驱动程序中播放，这时我们应该能听到声音。与PCM数数据一同到达驱动程序的通常还有采样率（sample rate），用来告诉驱动每秒钟应该播放多少个采样数据。如果传递给驱动程序的采样率大于PCM实际采样率，那么声音的播放速度将比实际速度快，反之亦然。</p><p>常用的多声道PCM数据流排列方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2:  FL FR                       (stereo)</span><br><span class="line">3:  FL FR LFE                   (2.1 surround)</span><br><span class="line">4:  FL FR BL BR                 (quad)</span><br><span class="line">5:  FL FR FC BL BR              (quad + center)</span><br><span class="line">6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)</span><br><span class="line">7:  FL FR FC LFE BC SL SR       (6.1 surround)</span><br><span class="line">8:  FL FR FC LFE BL BR SL SR    (7.1 surround)</span><br></pre></td></tr></table></figure><p>如上述，具体能够支持多少声道，得看芯片硬件通道是否支持。<br>FL：前置左声道<br>FR：前置右声道<br>FC：前置中置声道<br>LFE：重低音声道<br>BL：后置左环绕声道<br>BR：后置右环绕声道<br>SL：侧置左环绕声道<br>SR：侧置右环绕声道</p><h4 id="PCM数据流结构及封装"><a href="#PCM数据流结构及封装" class="headerlink" title="PCM数据流结构及封装"></a>PCM数据流结构及封装</h4><p>对于一个16位、立体双声道、44.1kHz采样率的PCM数据流，每个样本占用2字节（16位），每秒钟会产生44100 * 2 * 2 &#x3D; 176400字节的数据。在交错模式下，PCM格式数据流的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1字节：第一个左声道样本的低位字节。</span><br><span class="line">第2字节：第一个左声道样本的高位字节。</span><br><span class="line">第3字节：第一个右声道样本的低位字节。</span><br><span class="line">第4字节：第一个右声道样本的高位字节。</span><br><span class="line">...</span><br><span class="line">第5字节：第二个左声道样本的低位字节。</span><br><span class="line">第6字节：第二个左声道样本的高位字节。</span><br><span class="line">第7字节：第二个右声道样本的低位字节。</span><br><span class="line">第8字节：第二个右声道样本的高位字节。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>数据流封装：</strong> PCM数据流通常会被封装在一个容器格式中，如WAV、AIFF或RAW等，这些容器格式提供了额外的信息，如采样率、位深度、通道数等元数据，以及可能的头部信息和尾部信息。</p><h3 id="dB-分贝"><a href="#dB-分贝" class="headerlink" title="dB 分贝"></a>dB 分贝</h3><p>在音频处理和日常生活中提到的“dB”（分贝）都是衡量声音强度的单位，但它们的使用场景和参照点有所不同。</p><p>dB是对数单位，用于表达两个量的比值，用于描述声音强度、功率、电压或电流等物理量的<strong>相对变化</strong>。</p><p>生活中的dB：通常用于描述声压级，即声音在空气中的压力波动相对于基准声压的比值。其中基准声压，即0dB（通常为20uPa）是人耳能听到的最低声压。</p><p>音频处理中的dB：通常用于表示信号电平的相对变化（可以有不同的参照点，常见的是dBFS），以满刻度为基准。</p><p>以<code>16bit</code>位深度的PCM音频数据为例，那么其最大值<code>0xFFFF</code>则表示为0dB。</p><blockquote><p>相应的dBFS计算公式为<code>dBFS = 20 * lg (signal / 0xFFFF)</code>。 其中，signal为实际的采样值。<br>dBFS &#x3D; 20 * lg (0x01 &#x2F; 0xFFFF) &#x3D; -96dB<br>所以，16bit位深的峰值表为 0dB到-96dB<br>可推算，24bit位深，峰值表为 0dB到-144dB</p></blockquote><h3 id="声音能量"><a href="#声音能量" class="headerlink" title="声音能量"></a>声音能量</h3><p>声音能量：其计算通常用于音频信号处理中，以量化声音的强度或音量。（通过积分？）常用计算方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">均方根能量（RMS Energy）： 均方根能量是最常用的音频能量计算方法之一，它通过计算信号样本值的平方平均值的平方根来衡量信号的平均功率。公式如下： [ E_&#123;RMS&#125; = \sqrt&#123;\frac&#123;1&#125;&#123;N&#125;\sum_&#123;i=1&#125;^&#123;N&#125;x_i^2&#125; ] 其中，(x_i)是第(i)个样本值，(N)是样本总数。</span><br><span class="line"></span><br><span class="line">峰值能量： 峰值能量是信号最大幅度的平方，它反映信号的最大强度。公式如下： [ E_&#123;peak&#125; = \max(x_i)^2 ]</span><br><span class="line"></span><br><span class="line">总能量： 总能量是信号所有样本值平方的总和，它表示信号在整个时间窗口内的总能量。公式如下： [ E_&#123;total&#125; = \sum_&#123;i=1&#125;^&#123;N&#125;x_i^2 ]</span><br><span class="line"></span><br><span class="line">平均能量： 平均能量是信号样本值平方的平均值，它类似于均方根能量的平方。公式如下： [ E_&#123;avg&#125; = \frac&#123;1&#125;&#123;N&#125;\sum_&#123;i=1&#125;^&#123;N&#125;x_i^2 ]</span><br></pre></td></tr></table></figure><h3 id="音频文件格式"><a href="#音频文件格式" class="headerlink" title="音频文件格式"></a>音频文件格式</h3><p>WAV</p><p>MP3</p><p>M4A</p><p>WTG</p><p>APE</p><h3 id="音频编码格式"><a href="#音频编码格式" class="headerlink" title="音频编码格式"></a>音频编码格式</h3><p>MP3<br>FLAC<br>AAC<br>SBC<br>MSBC</p><h2 id="音频流处理"><a href="#音频流处理" class="headerlink" title="音频流处理"></a>音频流处理</h2><h3 id="EQ-均衡器"><a href="#EQ-均衡器" class="headerlink" title="EQ-均衡器"></a>EQ-均衡器</h3><p>EQ英文全称Equaliser，中文也就是均衡器的意思。它的基本作用是通过对声音某一个或多个频段进行增益或衰减，从而达到调整音色的目的。EQ通常包括以下三个参数：<br>Frequency，频率：这是用于设定你要进行调整的频率点的参数；<br>Gain，增益：用于调整在你设定好的F值上进行增益或衰减的参数；<br>Quantize，频宽比（中心频率与控制带宽的比例，Q值越小，控制范围越大，越模糊）：用于设定要进行增益或衰减的频段“宽度”的参数。Q值越小处理的频段就越宽。</p><h3 id="DRC-动态范围控制"><a href="#DRC-动态范围控制" class="headerlink" title="DRC-动态范围控制"></a>DRC-动态范围控制</h3><p>DRC，Dynamic Range Control(DRC)：动态范围控制提供压缩和放大能力，可以使声音听起来更柔和或者更大声，即一种信号幅度调节方式。</p><p>限幅器</p><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><h3 id="直接对PCM数据处理、数字增益、模拟增益"><a href="#直接对PCM数据处理、数字增益、模拟增益" class="headerlink" title="直接对PCM数据处理、数字增益、模拟增益"></a>直接对PCM数据处理、数字增益、模拟增益</h3><p>直接对PCM数据处理：直接修改传输中的PCM样本值，以改变音频信号的电平。这通常涉及乘法运算或者移位，将每个样本值乘以一个增益因子。</p><p>数字增益：在数字信号处理DSP域中，对音频信号进行增益控制。主要为对处理器的参数化接口调整<br>    灵活性：可以在软件中动态调整，便于实现复杂的音频处理算法。<br>    无失真：只要不超过数字信号处理器的动态范围，数字增益不会引入额外的失真。<br>    易于集成：可以与其他数字信号处理功能（如均衡、压缩、限幅等）无缝结合。</p><p>模拟增益：在信号链的模拟域中对音频信号进行放大的过程。<br>    直接影响功率：模拟增益直接影响输出信号的功率，从而影响扬声器或耳机的音量。<br>    可能引入失真：当信号电平过高时，模拟增益可能导致削波失真。<br>    硬件限制：模拟增益受硬件的限制，可能有固定的增益步进或范围。</p><h3 id="噪声门限"><a href="#噪声门限" class="headerlink" title="噪声门限"></a>噪声门限</h3><h3 id="DAC-数模转换器"><a href="#DAC-数模转换器" class="headerlink" title="DAC-数模转换器"></a>DAC-数模转换器</h3><h3 id="功率放大器"><a href="#功率放大器" class="headerlink" title="功率放大器"></a>功率放大器</h3><h3 id="扬声器"><a href="#扬声器" class="headerlink" title="扬声器"></a>扬声器</h3><h3 id="其它音效处理"><a href="#其它音效处理" class="headerlink" title="其它音效处理"></a>其它音效处理</h3><p>移频</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>音频播放流程：</strong> 从 文件&#x2F;蓝牙音频&#x2F;IIS&#x2F;SPDIF 到 PCM数据流，到发声，有一整条串行处理流：<strong>直接PCM数据处理、EQ&#x2F;DRC处理、DSP数字增益、DAC、模拟增益、输出</strong></p><blockquote><p>处理节点可以自行进行适当配置， user_handler？</p></blockquote><p>LADC：高分辨率ADC？</p><p>AUX接口，模拟到模拟的增益控制？：</p><h2 id="音频接口-协议标准"><a href="#音频接口-协议标准" class="headerlink" title="音频接口&#x2F;协议标准"></a>音频接口&#x2F;协议标准</h2><h3 id="A2DP协议标准（无线音频流配置）"><a href="#A2DP协议标准（无线音频流配置）" class="headerlink" title="A2DP协议标准（无线音频流配置）"></a>A2DP协议标准（无线音频流配置）</h3><p>A2DP并不是物理意义上的音频接口，而是蓝牙技术中的一种协议。其配置定义了如何通过蓝牙无线连接来传输立体声音频。（主要为音频流）</p><p><strong>关键特征如下：</strong></p><ul><li>音频质量：<strong>主要支持高质量的立体声音频传输</strong>，使用<strong>SBC、AAC、或者aptX、aptXHD、LDAC等编解码器</strong>来压缩&#x2F;解压音频数据，以减少带宽需求并保持良好音质。（LDAC：高分辨率音质编解码器）</li><li>无线传输及设备兼容性：无须依赖物理音频线，利用蓝牙技术，实现音频数据的无线传输。并支持广泛设备连接。</li><li>应用场景包括但不限于：蓝牙耳机、手机&#x2F;电脑音乐无线输出至蓝牙音响等。主要用于播放音乐、电影音轨、游戏音频等非通话相关的音频内容。</li><li>角色定义：SRC（Source，源设备），负责音频编码和传输；SNK（Sink，接收设备），负责接收和解码音频。</li><li>传输机制：A2DP的音频数据通过ACL（Asynchronous Connection-Less）Link传输（一种异步、无连接的数据传输方式，适合于音频流的连续传输）</li><li>多编解码器支持：A2DP协议规范允许设备协商使用最佳可用的编解码器，以适应不同的音频质量和带宽需求。</li></ul><br><p><strong>A2DP的工作流程：</strong></p><ul><li>设备发现：蓝牙设备通过广播信号互相发现对方的存在。</li><li>配对与连接：用户确认配对请求，设备建立安全连接。</li><li>服务发现：通过L2CAP（Logical Link Control and Adaptation Protocol）查询对方设备支持的A2DP服务。</li><li>编解码器协商：双方设备协商使用哪种音频编解码器进行传输。</li><li>音频流传输：SRC设备将音频数据编码并发送给SNK设备，后者解码并播放音频。</li></ul><h3 id="HSP-HFP（语音通话流配置）"><a href="#HSP-HFP（语音通话流配置）" class="headerlink" title="HSP&#x2F;HFP（语音通话流配置）"></a>HSP&#x2F;HFP（语音通话流配置）</h3><p><strong>关键特征如下：</strong></p><ul><li>语音通话质量：HSP&#x2F;HFP配置文件优化了语音通话质量，通常使用 CVSD 或 其它专为语音设计的编解码器</li><li>传输机制：使用SCO（Synchronous Connection-Oriented）Link，是一种同步、面向连接的传输方式，特别适合于语音通话的实时性要求</li><li>应用场景：用于手机通话、VoIP通话或会议电话等</li></ul><p>HSP&#x2F;HFP主要关注语音通话的清晰度，不支持立体声，且音频质量较低，不足以满足音乐播放的需求。</p><p>HFP扩展了HSP的功能，不仅支持语音通话，还增加了对电话控制的支持，如接听、挂断电话、拒接来电等。</p><blockquote><p>HFP同样使用CVSD或类似的语音编解码器，以确保通话质量，但它其注重于提供免提通话的便利性，尤其是在驾驶或无法手持电话的情况下。</p></blockquote><h3 id="BT-Audio接口之-A2DP-HSP-HFP-配置小结"><a href="#BT-Audio接口之-A2DP-HSP-HFP-配置小结" class="headerlink" title="BT Audio接口之 A2DP&#x2F;HSP&#x2F;HFP 配置小结"></a>BT Audio接口之 A2DP&#x2F;HSP&#x2F;HFP 配置小结</h3><p>BT Audio接口使用蓝牙无线技术，无需物理线缆即可传输音频数据。<br>配置文件支持：依赖于蓝牙协议中的特定配置文件，如A2DP（高级音频分配配置文件）用于高质量音频流传输，或者HFP&#x2F;HSP（免提配置文件&#x2F;耳机配置文件）用于语音通话。</p><br><p><strong>A2DP与HSP&#x2F;HFP的差异：</strong></p><ul><li>A2DP针对高质量音频传输，而HSP&#x2F;HFP专注于清晰的语音通话</li><li>A2DP用于音频的下行传输，HSP&#x2F;HFP配置文件支持音频的上行和下行双向传输，但音频质量较A2DP低。如果要同时使用高音质音频及语音上行，如游戏耳机，可以组合使用多个配置文件实现。</li><li>A2DP使用ACL Link，适合连续的音频流传输；HSP&#x2F;HFP使用SCO Link，适合实时的语音通话。</li><li>A2DP支持多种音频编解码器，以适应不同的音频质量需求；HSP&#x2F;HFP使用专为语音设计的编解码器</li></ul><p>蓝牙设备可以同时支持A2DP（Advanced Audio Distribution Profile）和HSP&#x2F;HFP（Headset Profile &#x2F; Hands-Free Profile）配置文件</p><p>例如，当将一部支持A2DP和HFP的手机与一副同样支持这两种配置文件的蓝牙耳机配对时，手机会自动检测并建立与耳机的连接。在大多数情况下，手机会优先使用A2DP进行音频流传输，而当有来电时，连接会自动切换到HFP，以确保高质量的语音通话。</p><p>在某些情况下，设备可能需要手动或自动切换配置文件。例如，当用户正在通过A2DP听音乐时，如果接收到电话呼叫，设备通常会自动暂停音乐播放并切换到HFP进行通话。通话结束后，设备会自动返回到A2DP继续播放音乐。</p><p>注：ACL Link 和 SCO Link 是蓝牙技术中定义的两种不同的物理链路类型，它们分别用于不同的数据传输场景，并且具有不同的特性和优点。</p><p>（非限制一对一连接）<br>ACL Link 是一种异步无连接的数据传输链路，主要用于传输分组数据，如文件传输、互联网数据和高质量音频（通过A2DP配置文件）。ACL Link 的关键特性包括：<br>异步无连接：数据包可以随时发送，不需要预先建立连接，这使得ACL Link非常适合于突发性的数据传输。<br>可变数据速率：根据蓝牙版本的不同，ACL Link的数据速率可以从较低的1Mbps到较新的版本中的2Mbps甚至更高。<br>错误检测与重传：ACL Link支持错误检测机制，如果数据包丢失或损坏，可以请求重传。<br>适用于大量数据传输：由于其较高的数据速率和错误纠正能力，ACL Link非常适合于大数据量的传输，如文件传输和高质量音频流。</p><p>SCO Link 是一种同步面向连接的数据传输链路，主要用于传输实时性要求高的数据，如语音通话（通过HSP或HFP配置文件）。SCO Link 的关键特性包括：<br>同步面向连接：在数据传输前需要建立连接，数据包按照固定的时间间隔发送，保证了数据的实时性。<br>固定数据速率：SCO Link通常以固定的速率传输数据，如64kbps，以确保语音通话的连续性和清晰度。<br>不支持错误重传：由于实时性要求，SCO Link不支持数据包的重传，如果数据包丢失，则会被丢弃。<br>适用于实时音频传输：由于其低延迟和固定速率的特性，SCO Link非常适合于语音通话和实时音频流传输。</p><p>通常情况下：当音乐正在播放时（通过A2DP），如果电话呼入，耳机将自动暂停音乐播放，并切换到HFP&#x2F;HSP模式以处理通话。通话结束后，音乐会自动恢复播放。（但有些耳机能够同时进行）</p><h3 id="LINEIN-AUX-音频输入接口"><a href="#LINEIN-AUX-音频输入接口" class="headerlink" title="LINEIN&#x2F;AUX 音频输入接口"></a>LINEIN&#x2F;AUX 音频输入接口</h3><p>AUX接口通常采用3.5毫米（1&#x2F;8英寸）TRS插头，与标准的耳机插头兼容，便于连接。</p><ul><li>直接连接外部音频源，如平板、手机、笔记本等通过AUX连接到音响、音箱等</li><li>音频信号：AUX接口支持模拟音频信号的传输，无须数模、或模数转换。保证了连接的简便性和即插即用的特性</li></ul><p>与 LINEIN 相对应的是 LINEOUT 接口，与耳机3.5mm接口兼容，当然电气特性不完全相同。如：耳机接口可能包含音频输出和麦克风输入功能，而LINEOUT只有音频输出功能。</p><h3 id="IIS接口"><a href="#IIS接口" class="headerlink" title="IIS接口"></a>IIS接口</h3><p>IIS（Inter-IC Sound），又称集成电路内置音频总线，是飞利浦在1986年定义的数字音频传输标准，与IIC并无相关性。</p><p>相对其它协议，IIS接口协议相对简单，没有地址和片选机制。在总线上，只能同时存在一个主设备和发射设备：提供时钟的为主设备，主设备可以是发射设备、接收设备或者协调两者的其它控制设备皆可。</p><blockquote><p>主要应用于处理器与音频编解码器之间的音频数据传输<br><br></p></blockquote><p>IIS协议定义了三根信号线：<strong>时钟信号SCK、数据信号SD、左右声道选择信号WS</strong></p><ul><li>SCK&#x2F;BCLK 位时钟：等于通道数 * 位宽 * 采样率</li><li>SDIN&#x2F;DIN 数据线：串行数据，以二进制补码形式在数据线上传输，在WS变化后的第一个SCK脉冲先传输最高位</li><li>WS&#x2F;LRCLK 声道选择信号：用于区分左右声道的数据，0表示左声道，1表示右声道。也叫帧时钟，等于声音的采样频率</li><li>MCLK 主时钟（可选）：提供主时钟频率给接收端，确保采样率的准确性。 在高质量音频输出、使用外部音频解码器、多通道音频传输时，主时钟是必须的。</li></ul><p>时分复用，用于IIS实现多通道音频数据传输情况？</p><h3 id="USB-Audio-Class接口（UAC）"><a href="#USB-Audio-Class接口（UAC）" class="headerlink" title="USB Audio Class接口（UAC）"></a>USB Audio Class接口（UAC）</h3><p>UAC规范的组成部分：<br>音频控制接口（Audio Control Interface）：这部分定义了音频设备的控制信号，包括音量调节、静音、采样率选择等。</p><p>音频流接口（Audio Streaming Interface）：这部分定义了音频数据的传输方式，包括数据格式、采样率、位深度、通道数等。</p><h3 id="SPDIF接口"><a href="#SPDIF接口" class="headerlink" title="SPDIF接口"></a>SPDIF接口</h3><p>SPDIF定义了一种数字音频信号的传输方式，包括数据的格式和编码，以及如何在设备间传输这些数据。</p><p>SPDIF接口主要用于家用音频设备之间，如CD播放机、数字录音机、AV接收器、电视和声卡等，以实现高质量的数字音频传输。</p><p>物理接口有：同轴电缆、光纤</p><p>数据格式：SPDIF定义了如何将数字音频数据打包成帧，包括采样率、位深度、通道数量等信息。<br>编码方式：使用脉冲编码调制（PCM）或压缩格式（如Dolby Digital或DTS）来编码音频数据。<br>传输机制：规定了如何在设备间同步传输这些数据，包括时钟信号的同步。</p><h3 id="HDMI-ARC接口"><a href="#HDMI-ARC接口" class="headerlink" title="HDMI-ARC接口"></a>HDMI-ARC接口</h3><h3 id="PDM接口"><a href="#PDM接口" class="headerlink" title="PDM接口"></a>PDM接口</h3><p>PDM（Pulse Density Modulation）接口是一种用于传输音频信号的接口，特别是在数字麦克风和扬声器系统中。PDM是一种调制技术，用于将模拟音频信号转换为数字信号，这种数字信号由一系列脉冲组成，脉冲的密度反映了模拟信号的幅度。</p><p>PDM接口中，音频信号是以极高的频率（远远高于标准的PCM采样率，如44.1kHz或48kHz）进行采样的，通常在数兆赫兹（MHz）。由于采样率非常高，PDM信号可以使用单个比特（1位）来表示每个样本，这意味着信号在传输时要么为0，要么为1。</p><p>PDM接口不需要复杂的模数转换器（ADC）和数模转换器（DAC）</p><p>PDM接口常用于数字麦克风，如MEMS麦克风，以及一些音频编解码器中。在数字信号处理器（DSP）或专用集成电路（ASIC）中，PDM信号通常会被转换回更高分辨率的数字信号（如16位或24位PCM），以便进一步处理和播放。</p><h2 id="音频开发相关概念"><a href="#音频开发相关概念" class="headerlink" title="音频开发相关概念"></a>音频开发相关概念</h2><h3 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h3><p>声卡的基本功能：将来自话筒、磁带、光盘、电脑USB设备等的原始声音信号或者数字音频信号，进行转换，再输出到耳机、扬声器或者扩音机等声响设备。</p><p>比如，电脑的音频文件进行解码后，可以通过其内置声卡，将音频输出到主机自带的AUX接口中。</p><p>也可以通过电脑USB将音频流输出到外挂的设备，再由外挂USB设备进行高质量的音频输出到扬声器。此时外挂的嵌入式设备，称为声卡。</p><p>进行嵌入式音频设备开发，通常在PC-USB模式下，将自身作为声卡功能</p><h3 id="混响"><a href="#混响" class="headerlink" title="混响"></a>混响</h3><h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><p>麦克风：动圈麦克风</p><p>混合录音</p><p>音频流以及MIC输入流，混合输入编码到PCM，再存储到文件中</p><p>如果音频流频率跟MIC采样频率不一样，则进行 SRC 变采样处理</p><p>音频流如 eq、drc、移频（避免啸叫）、变声、谐波、混响（空间、回声） -&gt; 低中高频 DRC -&gt; 输出</p><h2 id="业务层音频功能开发"><a href="#业务层音频功能开发" class="headerlink" title="业务层音频功能开发"></a>业务层音频功能开发</h2><h3 id="音频功能配置"><a href="#音频功能配置" class="headerlink" title="音频功能配置"></a>音频功能配置</h3><p>输出模式？  单端隔直、差分输出、VCOM直推</p><p>VCM电容</p><p>等</p><h3 id="音效调试"><a href="#音效调试" class="headerlink" title="音效调试"></a>音效调试</h3><p>如何调试？</p><h2 id="注意项及扩展思考"><a href="#注意项及扩展思考" class="headerlink" title="注意项及扩展思考"></a>注意项及扩展思考</h2><p>关机时需要先把功放给关掉，  另外ES8388音频解码器也要等电容的电放完 才能再次上电通讯，否则iic会通讯失败</p><h3 id="为什么直接断电时，扬声器会嘭的一声"><a href="#为什么直接断电时，扬声器会嘭的一声" class="headerlink" title="为什么直接断电时，扬声器会嘭的一声"></a>为什么直接断电时，扬声器会嘭的一声</h3><p>功放与扬声器的关系，为什么直接断电时 扬声器会嘭的一声： 功放电容直接关闭时瞬间放电导致SPK发声</p><p>通常在关闭功放或者音响时，先将功放设置为静音（MUTE）状态后，再断电。</p><p>避免开关冲击噪声，即功放内部可能的瞬态电流波动。</p><p>在开启功放时，也建议先将功放设置为静音状态，然后再启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扬声器的末端有一个电容，电容会有一个偏置电压，通常为 VDD/2 。在上电时，该电容瞬间上电会导致扬声器 peng 的一声。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="音频开发中出现底噪、电流声的分析流程"><a href="#音频开发中出现底噪、电流声的分析流程" class="headerlink" title="音频开发中出现底噪、电流声的分析流程"></a>音频开发中出现底噪、电流声的分析流程</h3><p>噪声问题主要通过优化硬件处理， 如果硬件处理无法达到理想效果，则通过软件加噪声门处理（反相底噪的PCM数据，做音效抵消）</p><p>1、模拟地短接到数字地，导致模拟地有电压波动，导致音频噪声。<br>2、功放带宽大，导致DAC输出的信号有折回，会导致喇叭有明显噪声。 在DAC输出端加二阶低通滤波。</p><p>头戴式耳机本身模具决定电池线和喇叭线需要共同紧贴着走一段很长的距离，然后接到主板端上。此时电池上的干扰很容易就通过平行线耦合干扰到喇叭线。</p><blockquote><p>硬件上做对应处理。</p></blockquote><h3 id="开发中出现音频数据没声音的问题排查"><a href="#开发中出现音频数据没声音的问题排查" class="headerlink" title="开发中出现音频数据没声音的问题排查"></a>开发中出现音频数据没声音的问题排查</h3><ul><li>音频管脚是否配置正确，是否为复用引脚</li><li>时钟是由处理器还是编解码器提供？主从模式是否正确</li><li>通信双方的通道数、位宽、采样率是否配置正确</li><li>LRCK、SCK是否输出正确，其中<code>LRCK=采样率</code>、<code>SCK=通道数*位宽*采样率</code></li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://mp.weixin.qq.com/s/fIm5XtPUa8UWWpVJ-7lhBg">【技术帖】一些关于音频功放的小秘密，你都知道吗？</a></li></ul><h2 id="附录-备忘录"><a href="#附录-备忘录" class="headerlink" title="附录&#x2F;备忘录"></a>附录&#x2F;备忘录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 音频播放原理概述</span><br><span class="line"></span><br><span class="line">将mp3文件通过esp32自带的转换工具转成bin文件，而后烧录到esp32的指定地址。（mp3文件命名转换与esp32代码中mp3命名一一对应） </span><br><span class="line"></span><br><span class="line">esp32调用库接口解码播放相应的mp3歌曲，通过IIS将数字音频信号输出到ES8388音频解码器，转换成相应的交流信号（模拟信号），再经过功率放大器放大 音频的电信号，最后输出到扬声器将 电信号转换成声音</span><br><span class="line"></span><br><span class="line">ESP32 IIC IIS-&gt;音频解码-&gt;功率放大器-&gt;扬声器</span><br><span class="line"></span><br><span class="line">### 语音识别开发流程</span><br><span class="line"></span><br><span class="line">离线语音识别：</span><br><span class="line">电脑端模型训练词条，完成模型训练后，针对特定平台编译成相应的库（输入声音流，输出词条的库），编译部署到设备上运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在线语音识别</span><br><span class="line"></span><br><span class="line">语音识别和回音消除，  通过ES7243E模数转换器，将外界的声音转换成数字信号给ESP32识别，采集MIC的声音减去SPK的声音就是真实的外界声音。 （另外 IIS具有区分左右声道的能力）</span><br><span class="line"></span><br><span class="line">声学算法如回声消除、噪声抑制等的部署，</span><br><span class="line"></span><br><span class="line">编程初始化算法、处理音频数据、调用算法接口等</span><br><span class="line"></span><br><span class="line">### 语音控制功能简述</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【蓝牙】经典蓝牙和TWS的连接原理</title>
      <link href="/2024/07/15/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E5%92%8CTWS%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/15/%E3%80%90%E8%93%9D%E7%89%99%E3%80%91%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E5%92%8CTWS%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文内容摘抄自前人笔记，暂略</p><h2 id="蓝牙状态"><a href="#蓝牙状态" class="headerlink" title="蓝牙状态"></a>蓝牙状态</h2><p>经典蓝牙的基本状态如下：</p><ul><li>Page寻呼：主动对其它蓝牙设备发起连接</li><li>Page Scan：可被其它蓝牙设备发起连接。（当设备处于Page Scan状态时，才能被发起Page的蓝牙设备连接）</li><li>Inquiry扫描：主动搜索和发现周围的蓝牙设备。（通常由手机发起）</li><li>Inquiry Scan：可被其它蓝牙设备搜索与发起连接。（当设备处于Inquiry Scan状态时，才能被发起Inquiry的蓝牙设备搜索）</li><li>standby：蓝牙设备默认状态，此模式下设备处于低功耗状态</li></ul><blockquote><p>经典蓝牙不讲述广播概念，其广播过程可以理解为设备通过 Inquiry 和 Inquiry Scan 状态进行发现和建立连接的过程。</p></blockquote><h2 id="蓝牙连接"><a href="#蓝牙连接" class="headerlink" title="蓝牙连接"></a>蓝牙连接</h2><h3 id="首次配对流程："><a href="#首次配对流程：" class="headerlink" title="首次配对流程："></a>首次配对流程：</h3><ul><li>由手机发起Inquiry，搜索周围的蓝牙设备</li><li>蓝牙设备要处于Inquiry Scan状态，才能被手机搜索与发起连接</li></ul><p>配对完成：手机和耳机都会记录配对信息，配对信息中包含对方的蓝牙地址</p><p>关键词<code>Link Key</code>：Link Key 通常是在两个设备首次配对时生成的，用于身份验证和加密通信，便于后续回连</p><h3 id="回连流程"><a href="#回连流程" class="headerlink" title="回连流程"></a>回连流程</h3><p>即 Page 和 Pagescan</p><ul><li>手机发起Page，设备处于Pagescan状态，即为手机回连设备</li><li>设备发起Page，手机处于Pagescan状态，即为设备回连手机</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通常，手机蓝牙打开后，本身即在Inquiryscan、Pagescan状态来回切换</span><br><span class="line"></span><br><span class="line">首次打开手机蓝牙时，手机会尝试去 Page 记忆的设备</span><br><span class="line"></span><br><span class="line">用户刷新蓝牙搜索时，相当于操作手机轮询去 Inquiry 蓝牙设备</span><br></pre></td></tr></table></figure><p>能够实现回连的前提下，是设备、手机双方都保存有Link Key</p><p>如果有任何一方取消配对或者清除配对记录，则无法回连，需要重新 Inquiry</p><h2 id="TWS连接"><a href="#TWS连接" class="headerlink" title="TWS连接"></a>TWS连接</h2><p>inquiry inquiry scan<br>page<br>page scan</p><p>通常手机才会去 inquiry 扫描周围的设备</p><p>TWS配对时，两个设备分别在page和page scan来回切换，当有一个处于page，一个处于page scan时，则可以建立连接</p><p>TWS配对慢时，可能是因为状态切换周期过长，没卡上时间</p><h3 id="TWS之使用公共地址"><a href="#TWS之使用公共地址" class="headerlink" title="TWS之使用公共地址"></a>TWS之使用公共地址</h3><p>主从切换</p><h3 id="TWS之不使用公共地址"><a href="#TWS之不使用公共地址" class="headerlink" title="TWS之不使用公共地址"></a>TWS之不使用公共地址</h3><p>主从角色、手机介入</p><h2 id="思考与拓展"><a href="#思考与拓展" class="headerlink" title="思考与拓展"></a>思考与拓展</h2><h3 id="杰理SDK之蓝牙连接相关代码"><a href="#杰理SDK之蓝牙连接相关代码" class="headerlink" title="杰理SDK之蓝牙连接相关代码"></a>杰理SDK之蓝牙连接相关代码</h3><p>c表示page，设备主动进行TWS Page<br>cp表示tws状态回来切换配对中；小p表示设备处于tws_page_scan<br>I表示可搜索可发现连接<br>大P表示可被手机回连，即 page scan<br>C表示设备主动Page手机</p><h3 id="Link-Key是什么？"><a href="#Link-Key是什么？" class="headerlink" title="Link Key是什么？"></a>Link Key是什么？</h3><p>Link Key 通常是在两个设备首次配对时生成的，并且在后续的连接中用于快速建立信任关系</p><p>作用：身份验证、加密通信</p><h3 id="TWS的MAC地址，使用公共地址和不使用公共地址的区别"><a href="#TWS的MAC地址，使用公共地址和不使用公共地址的区别" class="headerlink" title="TWS的MAC地址，使用公共地址和不使用公共地址的区别"></a>TWS的MAC地址，使用公共地址和不使用公共地址的区别</h3><p>local bt_addr common remote</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/augusdi/article/details/25887395">BlueTooth: 蓝牙基础知识进阶——链路控制操作</a></li><li><a href="https://wenku.baidu.com/view/36706bd80142a8956bec0975f46527d3240ca62e.html?_wkts_=1724220665713&needWelcomeRecommand=1">蓝牙设备发现与同步</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 蓝牙 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>杰理科技SDK开发笔记</title>
      <link href="/2024/07/12/%E3%80%90%E6%9D%B0%E7%90%86%E3%80%91%E6%9D%B0%E7%90%86%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/12/%E3%80%90%E6%9D%B0%E7%90%86%E3%80%91%E6%9D%B0%E7%90%86%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>本文从新人角度，暂且以<code>jl701n_soundbox_release_v1.4.2/sdk</code>为例，讲述对杰理SDK的入门与开发理解。</p><h3 id="杰理系列芯片介绍"><a href="#杰理系列芯片介绍" class="headerlink" title="杰理系列芯片介绍"></a>杰理系列芯片介绍</h3><ul><li><p>br23 br25 br28等，与芯片型号的关联，芯片丝印与SDK包命名的关系 等等需要理清</p></li><li><p>不同内核、不同型号的芯片，具体的业务方案应用场景，为何做这样的区分，概述</p></li></ul><p>此部分内容暂略…</p><h2 id="杰理SDK软件架构解析"><a href="#杰理SDK软件架构解析" class="headerlink" title="杰理SDK软件架构解析"></a>杰理SDK软件架构解析</h2><h3 id="SDK框架总体概览"><a href="#SDK框架总体概览" class="headerlink" title="SDK框架总体概览"></a>SDK框架总体概览</h3><ul><li><a href="https://gitee.com/Jindu-Chen/jindu-chen_-jie-li_-doc/blob/master/%E6%9D%B0%E7%90%86SDK%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%90%84%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/%E6%9D%B0%E7%90%86SDK%E4%B8%BB%E6%A1%86%E6%9E%B6.drawio">点击跳转：SDK框架总体概览</a></li></ul><p><img src="/../pictures/AC701N_SDK%E6%A1%86%E6%9E%B6%E7%A4%BA%E6%84%8F.png" alt="SDK框架总体概览"></p><h3 id="SDK文件目录概览"><a href="#SDK文件目录概览" class="headerlink" title="SDK文件目录概览"></a>SDK文件目录概览</h3><p>以SDK包为根，主要有以下子目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//SDK</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">├── apps</span><br><span class="line">│      │</span><br><span class="line">│      ├── common         # 通用中间层文件，如音频、蓝牙、全局通用配置、设备管理、文件系统等</span><br><span class="line">│      │</span><br><span class="line">│      └── soundbox       # 应用层的业务逻辑代码</span><br><span class="line">│</span><br><span class="line">├── cpu/br25             # 内核、芯片外设层的相关代码</span><br><span class="line">│      │</span><br><span class="line">│      ├── audio_common/</span><br><span class="line">│      │</span><br><span class="line">│      ├── tools/        # 工具集，包含有配置工具、烧录脚本等</span><br><span class="line">│      │</span><br><span class="line">│      └── ...           # </span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">└── include_lib          # 封装好，以供调用或者链接的库，包含OS、FS、外设底层驱动等</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开发思路流程概览"><a href="#开发思路流程概览" class="headerlink" title="开发思路流程概览"></a>开发思路流程概览</h2><p>在<code>//apps/soundbox/board/brxx/board_config.h</code>进行板级的宏定义配置选择</p><blockquote><p>其包含了所有板级配置.h文件，通过配置宏定义选择性编译 <code>#ifdef xxx #endif</code>从而决定采用何种板级配置</p></blockquote><br><p>板级宏定义配置决定了采用何种<code>//apps/soundbox/board/br23/board_xxx_xxx/board_xxx_cfg.h</code>文件，其业务功能实现则位于相应的<code>//apps/soundbox/board/br28/board_xxx_xxx/</code>中</p><h3 id="SDK级宏定义配置"><a href="#SDK级宏定义配置" class="headerlink" title="SDK级宏定义配置"></a>SDK级宏定义配置</h3><h3 id="外设驱动抽象层宏配置"><a href="#外设驱动抽象层宏配置" class="headerlink" title="外设驱动抽象层宏配置"></a>外设驱动抽象层宏配置</h3><h2 id="SDK之初始化流程概述"><a href="#SDK之初始化流程概述" class="headerlink" title="SDK之初始化流程概述"></a>SDK之初始化流程概述</h2><h3 id="上电初始化至main"><a href="#上电初始化至main" class="headerlink" title="上电初始化至main"></a>上电初始化至main</h3><p><code>main</code>函数之前的源码不可见</p><p>猜测是通过指定链接相应的.a库或者段 到上电入口地址，完成必要的上电初始化后，再跳转至<code>main</code>函数执行用户级的初始化</p><p>这部分用户不可见的工作可能包括如下：</p><ol><li>芯片上电从0地址，或者是所映射的其它原始入口地址，开始执行</li><li>进行CPU寄存器比如栈指针、CPU内核等芯片内核初始化</li><li>C语言运行环境的初始化，包括栈指针设置、可读写数据区、堆区、栈区的初始化，具体代码实现取决于cpu内核架构</li><li>原始时钟系统、中断向量、内部Flash的读写等初始化</li><li>程序执行流-&gt;跳转至声明的<code>main</code>函数，正式执行用户级代码，并在<code>main</code>函数里面初始化及启动OS，开启线程调度</li></ol><br><p>从<code>sdk.map</code>文件可知，芯片代码段起始地址为 0x06000100，并说明了全局符号<code>text_rodata_begin</code>的地址即为 0x06000100，该全局符号的链接地址由<code>sdk_ld.c</code>或<code>sdk.ld</code>链接脚本确定。</p><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//cpu/br28/tools/sdk.map</span><br><span class="line">.text           0x06000100    0xc2610</span><br><span class="line">                [!provide]                PROVIDE (text_rodata_begin, .)</span><br><span class="line"> *(.startup.text)</span><br><span class="line"> .startup.text  0x06000100       0x8e cpu/br28/liba/cpu.a(startup.S.o)</span><br><span class="line">                0x06000100                _start</span><br><span class="line"> *(.text)</span><br><span class="line"> .text          0x0600018e    0x11efe cpu/br28/tools/sdk.elf.o</span><br><span class="line">                0x060014ae                update_result_get</span><br><span class="line">                0x060019fc                __errno</span><br><span class="line">                0x06001cd4                main</span><br></pre></td></tr></table></figure><p>通过以上节选map文件推测可知，芯片上电后，会首先执行<code>_start</code>汇编初始化函数，其实现位于<code>cpu/br28/liba/cpu.a(startup.S.o)</code>，而后即跳转至<code>main</code>函数</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>用户入口<code>int main()</code>位于<code>//SDK/apps/soundbox/common/init.c/main()</code>，实现以及解释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    wdt_close();    <span class="comment">// 关看门狗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化`FreeRTOS`或其它RTOS的任务调度器链表、</span></span><br><span class="line"><span class="comment">    以及定时器任务链表、消息队列链表、事件链表等必要内核组件数据结构 */</span></span><br><span class="line">    os_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    架构级设置，路径位于 //cpu/br28/setup.c/setup_arch()，里面所作设置如下：</span></span><br><span class="line"><span class="comment">    1. 开启DSP核的bpu配置，暂没了解</span></span><br><span class="line"><span class="comment">    2. 定义芯片复位引脚的复位电平，以及长置该电平复位的时间</span></span><br><span class="line"><span class="comment">    3. 调用memory_init，应为 用户动态内存堆的初始化</span></span><br><span class="line"><span class="comment">    4. p11_init()，电源管理相关API，源码不可见</span></span><br><span class="line"><span class="comment">    5. 初始化看门狗复位时间</span></span><br><span class="line"><span class="comment">    6. efuse_init() ，推测为芯片flash相关的初始化</span></span><br><span class="line"><span class="comment">    7. clk_voltage_init，配置时钟模式及系统电压初始化</span></span><br><span class="line"><span class="comment">    8. xosc_hcs_trim()，外部晶振相关调整设置</span></span><br><span class="line"><span class="comment">    9. clk_early_init 时钟源的早期配置，晶振频率、时钟频率、系统时钟源等</span></span><br><span class="line"><span class="comment">    10. tick_timer_init OS节拍定时器初始化，实现链接可见于cpu/br28/liba/system.a(os_cpu_c.c.o)</span></span><br><span class="line"><span class="comment">    11. port_init() 所有IO的必要初始化，或者复位</span></span><br><span class="line"><span class="comment">    12. debug_uart_init 日志输出串口初始化，默认为uart0，实现位于//apps/soundbox/board/br28/board_xxx_xxx/board_xxx_xxx.c。</span></span><br><span class="line"><span class="comment">        (该文件体现了不同板级间的配置差异)</span></span><br><span class="line"><span class="comment">    13. log_early_init(1024);</span></span><br><span class="line"><span class="comment">    14. 一些模块的dump</span></span><br><span class="line"><span class="comment">    15. 调用中断注册接口，进行必要中断的注册设置</span></span><br><span class="line"><span class="comment">    16. sys_timer_init();</span></span><br><span class="line"><span class="comment">    17. debug_init(); 异常检测模块初始化，推测可能会初始化一个任务，检测cpu或者os任务控制块相关数据情况</span></span><br><span class="line"><span class="comment">    18. __crc16_mutex_init();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    setup_arch();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行操作系统前之必要的板级初始化，本文件内为弱函数，具体所链接的函数实现位于.a库中，不可见（当然，.a库也可能没有该实现）</span></span><br><span class="line">    board_early_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个OS任务，入口函数为 app_task_handler，入参为 NULL，name为 app_core</span></span><br><span class="line"><span class="comment">    注意该任务：该任务包含了大部分的模式业务逻辑，其内实现了一个简易切换模式枚举的设计</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    task_create(app_task_handler, <span class="literal">NULL</span>, <span class="string">&quot;app_core&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能OS内核的任务调度接口</span></span><br><span class="line">    os_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能全局中断，当中断使能后，系统节拍定时器中断会立即切入，然后调用任务调度器切入优先级最高的任务执行</span></span><br><span class="line">    local_irq_enable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="app-init-用户级初始化"><a href="#app-init-用户级初始化" class="headerlink" title="app_init 用户级初始化"></a>app_init 用户级初始化</h3><p>在<code>main</code>函数创建<code>app_task_handler()</code>的app任务入口函数后，即开始调度至该入口函数执行，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_task_handler</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    app_init();</span><br><span class="line">    app_main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><code>app_init()</code>函数路径位于<code>//apps/soundbox/common/init.c/app_init()</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do...call 皆为自动初始化，指向指定的目标段，执行其首尾之间的所有函数指针，从而完成必要的一些初始化动作</span></span><br><span class="line">    do_early_initcall();</span><br><span class="line">    do_platform_initcall();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 板级初始化</span></span><br><span class="line">    board_init();</span><br><span class="line"></span><br><span class="line">    do_initcall();</span><br><span class="line"></span><br><span class="line">    do_module_initcall();</span><br><span class="line">    do_late_initcall();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化音频编码器和解码器</span></span><br><span class="line">    audio_enc_init();</span><br><span class="line">    audio_dec_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是配置了有升级功能，则进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!UPDATE_SUPPORT_DEV_IS_NULL()) &#123;</span><br><span class="line">        <span class="comment">// 升级后，在此进行结果处理：</span></span><br><span class="line">        <span class="comment">// 无更新，则直接返回；更新成功，则以一半的音量播报5次？更新失败，则以最大音量播报同一句语音？.......</span></span><br><span class="line">        update = update_result_deal();  <span class="comment">// apps/common/update/update.c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app_var.play_poweron_tone = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有插入充电，则检查开机电压</span></span><br><span class="line">    <span class="keyword">if</span> (!get_charge_online_flag()) &#123;</span><br><span class="line">        check_power_on_voltage();   <span class="comment">// 循环判断指定次数电池电压，如果正常则开机，电压过低则设置软关机</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_POWER_ON_NEED_KEY  <span class="comment">// 是否需要按键才能开机</span></span></span><br><span class="line">        <span class="comment">/*充电拔出,CPU软件复位, 不检测按键，直接开机*/</span></span><br><span class="line">        <span class="keyword">extern</span> u8 <span class="title function_">get_alarm_wkup_flag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_CHARGE_OFF_POWERON_NE</span></span><br><span class="line">        <span class="keyword">if</span> ((!update &amp;&amp; cpu_reset_by_soft()) || is_ldo5v_wakeup() || get_alarm_wkup_flag()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((!update &amp;&amp; cpu_reset_by_soft()) || get_alarm_wkup_flag()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            app_var.play_poweron_tone = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            check_power_on_key();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_SHARE_OSC_EN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">share_osc_pull_down_io</span><span class="params">()</span>;</span><br><span class="line">    share_osc_pull_down_io();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_UART_1T2_EN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_1t2_pull_down_io</span><span class="params">()</span>;</span><br><span class="line">    uart_1t2_pull_down_io();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (TCFG_MC_BIAS_AUTO_ADJUST == MC_BIAS_ADJUST_POWER_ON)</span></span><br><span class="line">    u8 por_flag = <span class="number">0</span>;</span><br><span class="line">    u8 cur_por_flag = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined(CONFIG_CPU_BR23) || defined(CONFIG_CPU_BR25))</span></span><br><span class="line">    <span class="keyword">extern</span> u8 power_reset_src;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *1.update</span></span><br><span class="line"><span class="comment">     *2.power_on_reset(BIT0:上电复位)</span></span><br><span class="line"><span class="comment">     *3.pin reset(BIT4:长按复位)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (update || (power_reset_src &amp; BIT(<span class="number">0</span>)) || (power_reset_src &amp; BIT(<span class="number">4</span>))) &#123;</span><br><span class="line">        <span class="comment">//log_info(&quot;reset_flag:0x%x&quot;,power_reset_src);</span></span><br><span class="line">        cur_por_flag = <span class="number">0xA5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* #if defined(CONFIG_CPU_BR23) */</span></span></span><br><span class="line">    u32 reset_src = is_reset_source(BIT(MSYS_POWER_RETURN) | BIT(P33_PPINR_RST));</span><br><span class="line">    <span class="keyword">if</span> (update || reset_src) &#123;</span><br><span class="line">        cur_por_flag = <span class="number">0xA5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #if defined(CONFIG_CPU_BR23) */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = syscfg_read(CFG_POR_FLAG, &amp;por_flag, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((cur_por_flag == <span class="number">0xA5</span>) &amp;&amp; (por_flag != cur_por_flag)) &#123;</span><br><span class="line">        <span class="comment">//log_info(&quot;update POR flag&quot;);</span></span><br><span class="line">        ret = syscfg_write(CFG_POR_FLAG, &amp;cur_por_flag, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (TCFG_CHARGE_ENABLE &amp;&amp; TCFG_CHARGE_POWERON_ENABLE)</span></span><br><span class="line">    <span class="keyword">if</span> (is_ldo5v_wakeup()) &#123; <span class="comment">//LDO5V唤醒</span></span><br><span class="line">        <span class="keyword">extern</span> u8 <span class="title function_">get_charge_online_flag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (get_charge_online_flag()) &#123; <span class="comment">//关机时，充电插入</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//关机时，充电拔出</span></span><br><span class="line">            power_set_soft_poweroff();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(TCFG_CHARGE_BOX_ENABLE)</span></span><br><span class="line">    <span class="comment">/* clock_add_set(CHARGE_BOX_CLK); */</span></span><br><span class="line">    chgbox_init_app();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述<code>app_init</code>代码暂作部分解释，其余后续补充</p><h4 id="板级初始化-board-init"><a href="#板级初始化-board-init" class="headerlink" title="板级初始化 board_init()"></a>板级初始化 board_init()</h4><p><code>board_init()</code>在<code>app_init</code>函数中被调用，其路径位于<code>//apps/soundbox/board/br28/board_jl701n_demo/board_jl701n_demo.c/board_init()</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    board_power_init(); <span class="comment">// 实现位于当前模块内，包括电源管理，如唤醒源IO配置等功能</span></span><br><span class="line">    <span class="comment">//adc_vbg_init();</span></span><br><span class="line">    adc_init(); <span class="comment">// 实现位于 //cpu/br28/adc_api.c</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析蓝牙配置文件，实现位于 //apps/soundbox/common/user_cfg_new.c</span></span><br><span class="line">    <span class="comment">// 蓝牙配置，如名字、Mac地址等，在此函数内进行结构体设置</span></span><br><span class="line">    cfg_file_parse(<span class="number">0</span>);  </span><br><span class="line">    <span class="comment">/* devices_init(); */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_CHARGE_ENABLE  <span class="comment">// 是否支持芯片内置充电</span></span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">charge_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dev_node *node, <span class="type">void</span> *arg)</span>;</span><br><span class="line">    charge_init(<span class="literal">NULL</span>, (<span class="type">void</span> *)&amp;charge_data);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">CHARGE_EN(<span class="number">0</span>);</span><br><span class="line">    CHGGO_EN(<span class="number">0</span>);</span><br><span class="line">    gpio_longpress_pin1_reset_config(IO_LDOIN_DET, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if (!get_charge_online_flag()) &#123; */</span></span><br><span class="line">        <span class="comment">/* check_power_on_voltage(); */</span></span><br><span class="line">    <span class="comment">/* &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (TCFG_SD0_ENABLE || TCFG_SD1_ENABLE)</span></span><br><span class="line">sdpg_config(<span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_FM_ENABLE</span></span><br><span class="line">fm_dev_init(&amp;fm_dev_data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_NOR_REC</span></span><br><span class="line">    nor_fs_ops_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_NOR_FS</span></span><br><span class="line">    init_norsdfile_hdl();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FLASH_INSIDE_REC_ENABLE</span></span><br><span class="line">    sdfile_rec_ops_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">dev_manager_init();</span><br><span class="line">    dev_manager_set_valid_by_logo(<span class="string">&quot;res_nor&quot;</span>, <span class="number">0</span>);<span class="comment">///将设备设置为无效设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备驱动层初始化，比如按键驱动在此内进行注册</span></span><br><span class="line">board_devices_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_CHARGE_ENABLE</span></span><br><span class="line">    <span class="keyword">if</span>(get_charge_online_flag())</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    power_set_mode(PWR_LDO15);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    power_set_mode(TCFG_LOWPOWER_POWER_SEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> TCFG_UART0_ENABLE  <span class="comment">// 如果使能日志打印，则设置该串口的rx为普通io？</span></span></span><br><span class="line">    <span class="keyword">if</span> (uart0_data.rx_pin &lt; IO_MAX_NUM) &#123;</span><br><span class="line">        gpio_set_die(uart0_data.rx_pin, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_SMART_VOICE_ENABLE</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">audio_smart_voice_detect_init</span><span class="params">(<span class="keyword">struct</span> vad_mic_platform_data *mic_data)</span>;</span><br><span class="line">    audio_smart_voice_detect_init((<span class="keyword">struct</span> vad_mic_platform_data *)&amp;vad_mic_data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #if TCFG_SMART_VOICE_ENABLE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(AUDIO_PCM_DEBUG)</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">uartSendInit</span><span class="params">()</span>;</span><br><span class="line">    uartSendInit();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_RTC_ENABLE</span></span><br><span class="line">    alarm_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="app-main-用户级初始化"><a href="#app-main-用户级初始化" class="headerlink" title="app_main 用户级初始化"></a>app_main 用户级初始化</h3><p><code>app_main()</code>函数路径位于<code>//apps/soundbox/app_main.c/app_main()</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    log_info(<span class="string">&quot;app_main \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_UNISOUND_ENABLE</span></span><br><span class="line">    unisound_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// app_var是个结构体，包含了音量、音量效果等的参数</span></span><br><span class="line">    app_var.start_time = timer_get_ms();    <span class="comment">// 获取OS当前时间，作为app的开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有充电插入</span></span><br><span class="line">    <span class="keyword">if</span> (get_charge_online_flag()) &#123;</span><br><span class="line"></span><br><span class="line">        app_var.poweron_charge = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (TCFG_SYS_LVD_EN == 1)</span></span><br><span class="line">        vbat_check_init();  <span class="comment">// 如果电量检测使能，则调用，其内会初始化电池检测定时器用于检测电压</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  PC_POWER_ON_CHARGE <span class="comment">// 没有定义此项</span></span></span><br><span class="line">        app_curr_task = APP_IDLE_TASK;  <span class="comment">// 直接进入此处</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        app_curr_task = APP_POWERON_TASK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_RTC_ENABLE</span></span><br><span class="line">    <span class="comment">// 如果没插充电，且使能了实时时钟，则进入此处</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (alarm_active_flag_get()) &#123;</span><br><span class="line">        app_curr_task = APP_RTC_TASK;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0 <span class="comment">//SOUNDCARD_ENABLE</span></span></span><br><span class="line">        soundcard_peripheral_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_HOST_AUDIO_ENABLE</span></span><br><span class="line">        <span class="comment">/* void usb_host_audio_init(int (*put_buf)(void *ptr, u32 len), int *(*get_buf)(void *ptr, u32 len)); */</span></span><br><span class="line">        <span class="comment">/* usb_host_audio_init(usb_audio_play_put_buf, usb_audio_record_get_buf); */</span></span><br><span class="line">        uac_host_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* endless_loop_debug_int(); */</span></span><br><span class="line">        <span class="comment">// 更新led的灯效设置状态，实现位于 //apps/soundbox/ui/led/pwm_led_api.c。如果没有配置，则是空实现</span></span><br><span class="line">        ui_update_status(STATUS_POWERON);   </span><br><span class="line"></span><br><span class="line">        app_curr_task = APP_POWERON_TASK;   <span class="comment">// 非插充电下，无RTC使能，app while 1 轮询该模式业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_CHARGE_BOX_ENABLE</span></span><br><span class="line">    app_curr_task = APP_IDLE_TASK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TCFG_CHARGE_ENABLE</span></span><br><span class="line">    set_charge_event_flag(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    app_task_loop(); <span class="comment">// app任务进入 while 1 轮询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="app-task-loop之APP顶层模式业务"><a href="#app-task-loop之APP顶层模式业务" class="headerlink" title="app_task_loop之APP顶层模式业务"></a>app_task_loop之APP顶层模式业务</h4><p>app_task_loop 代码节选如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_task_loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (app_curr_task) &#123;</span><br><span class="line">        <span class="keyword">case</span> APP_POWERON_TASK:</span><br><span class="line">            log_info(<span class="string">&quot;APP_POWERON_TASK \n&quot;</span>);    <span class="comment">// 开机临时模式</span></span><br><span class="line">            app_poweron_task();     <span class="comment">// 检测到任何的公共消息事件，则将 app_next_task 设置相应的模式枚举，并退出其内的 while1 等等</span></span><br><span class="line">            app_task_exit_ok();     <span class="comment">// if (app_next_task) &#123; app_curr_task = app_next_task; app_next_task = 0; task_exitting = 0;&#125;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> APP_POWEROFF_TASK:</span><br><span class="line">            log_info(<span class="string">&quot;APP_POWEROFF_TASK \n&quot;</span>);</span><br><span class="line">            app_poweroff_task();</span><br><span class="line">            app_task_exit_ok();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> APP_BT_TASK:</span><br><span class="line">            log_info(<span class="string">&quot;APP_BT_TASK \n&quot;</span>);</span><br><span class="line">            app_bt_task();</span><br><span class="line">            app_task_exit_ok();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> APP_LIVE_IIS_TASK:</span><br><span class="line">            log_info(<span class="string">&quot;APP_LIVE_IIS_ACTION_TASK \n&quot;</span>);</span><br><span class="line">            app_live_iis_task();</span><br><span class="line">            app_task_exit_ok();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        app_task_clear_key_msg();<span class="comment">//清理按键消息</span></span><br><span class="line">        <span class="comment">//检查整理VM</span></span><br><span class="line">        vm_check_all(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="app-各模式业务设计解析"><a href="#app-各模式业务设计解析" class="headerlink" title="app 各模式业务设计解析"></a>app 各模式业务设计解析</h3><p>结合代码，概述顶层应用的模式业务逻辑</p><p> APP_POWERON_TASK<br> APP_POWEROFF_TASK<br> APP_BT_TASK<br> APP_MUSIC_TASK<br> APP_LINEIN_TASK<br> APP_PC_TASK<br> APP_IDLE_TASK<br> APP_SLEEP_TASK</p><h2 id="板子基本功能及系统级API简述"><a href="#板子基本功能及系统级API简述" class="headerlink" title="板子基本功能及系统级API简述"></a>板子基本功能及系统级API简述</h2><h3 id="板子通用基本功能概述"><a href="#板子通用基本功能概述" class="headerlink" title="板子通用基本功能概述"></a>板子通用基本功能概述</h3><h3 id="系统级API应用开发简述"><a href="#系统级API应用开发简述" class="headerlink" title="系统级API应用开发简述"></a>系统级API应用开发简述</h3><h4 id="系统任务创建"><a href="#系统任务创建" class="headerlink" title="系统任务创建"></a>系统任务创建</h4><p>创建新任务，调用OS API</p><p>另外，要在<code>//apps/soundbox/common/task_table.c</code>表增加相应的任务参数配置。为何这样设计，结合代码分析</p><p>其关联调用关系是怎样的</p><p>具体调用逻辑，后续补充</p><h4 id="系统定时器API"><a href="#系统定时器API" class="headerlink" title="系统定时器API"></a>系统定时器API</h4><p>sys_timer：软件定时器，定时到达后，发送事件到相应线程响应。属于同步接口</p><p>usr_timer：定时到达之后，直接在硬件中断服务函数执行 回调函数。属于异步接口</p><p>time与timeout： timeout只会被执行一次即结束</p><h4 id="事件上报及处理流程"><a href="#事件上报及处理流程" class="headerlink" title="事件上报及处理流程"></a>事件上报及处理流程</h4><h2 id="各模块业务功能开发"><a href="#各模块业务功能开发" class="headerlink" title="各模块业务功能开发"></a>各模块业务功能开发</h2><h3 id="APP-TASK框架设计解析"><a href="#APP-TASK框架设计解析" class="headerlink" title="APP_TASK框架设计解析"></a>APP_TASK框架设计解析</h3><p>等等</p><h3 id="日志打印配置"><a href="#日志打印配置" class="headerlink" title="日志打印配置"></a>日志打印配置</h3><p>在板级配置文件，如<code>//apps/soundbox/board/br28/board_jl701n_demo/board_jl701n_demo_cfg.hs</code>，配置使能串口打印，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCFG_UART0_ENABLEENABLE_THIS_MOUDLE <span class="comment">//串口打印模块使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCFG_UART0_RX_PORTNO_CONFIG_PORT      <span class="comment">//串口接收脚配置（用于打印可以选择NO_CONFIG_PORT）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USER_CDC_TEST_ENABLE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCFG_UART0_TX_PORT  IO_PORTA_06<span class="comment">//IO_PORTA_06//IO_PORT_DP //串口发送脚配置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCFG_UART0_TX_PORT  IO_PORT_DP<span class="comment">//IO_PORTA_06//IO_PORT_DP //串口发送脚配置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCFG_UART0_BAUDRATE  1000000       <span class="comment">//串口波特率配置</span></span></span><br></pre></td></tr></table></figure><p>在<code>//apps/soundbox/include/app_config.h</code>有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_DEBUG_ENABLE       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开断言</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> config_asser         = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开整个库打印</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_DEBUG    1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///打印是否时间打印信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> config_printf_time         = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="按键模块功能"><a href="#按键模块功能" class="headerlink" title="按键模块功能"></a>按键模块功能</h3><p><strong>系统上电初始化时，调用<code>key_driver_init()</code>进行按键驱动初始化</strong></p><ul><li>进行iokey、adkey等key的IO初始化，此部分IO配置句柄（包括获取键值函数、定义消抖、长按等参数）实现位于<code>apps/soundbox/board/br28/board_jl701n_demo/board_jl701n_demo.c</code>中，句柄的配置宏定义则位于相应的板级配置.h文件中</li><li>将按键句柄、配置参数、按键扫描函数添加到<code>usr_timer_add</code>硬件定时器中（可进入低功耗）</li></ul><br><p><strong>按键定时扫描-&gt;触发上报-&gt;按键-事件-任务表映射-&gt;发送打包后的消息</strong></p><ul><li>当按键扫描函数判断到有相应按键触发后，则触发通知<br>  （事件结构体指明：事件类型为<code>SYS_KEY_EVENT</code>、事件参数为<code>DEVICE_EVENT_FROM_KEY</code>、按键类型、按键事件如单击、长按等）</li><li><code>key_event_remap(&amp;e)</code>-&gt;<code>app_key_event_remap()</code>将触发的事件进行映射：判断当前app_curr_task，再转换成不同task下的 任务-按键事件-枚举表<br>  （总映射管理位于<code>apps/soundbox/task_manager/task_key.c</code>）</li><li>调用<code>sys_event_notify(struct sys_event *e)</code>向系统发送事件通知</li><li>事件API会给sys_event再封包，加上包头<code>APP_MSG_SYS_EVENT</code>，作为app消息发送至系统中</li></ul><br><p><strong>由当前app_task接收msg-&gt;解析按键事件-&gt;case相应事件枚举-&gt;执行相应操作</strong></p><ul><li>每个app任务下有个while1，通过调用<code>app_task_get_msg(msg, ARRAY_SIZE(msg), 1);</code>接收到系统app消息</li><li>进行包头消息判断，如<code>case APP_MSG_SYS_EVENT</code>，符合则进入私有任务的事件处理函数中</li><li>在私有任务的事件处理中，<code>case SYS_KEY_EVENT</code>则表示进入按键事件处理；再往下，则可以根据不同的按键事件进行相应处理，如下，表示音量增加。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>  KEY_VOLUP_HOLD:</span><br><span class="line">    log_info(<span class="string">&quot;    KEY_VOLUP_HOLD \n&quot;</span>);</span><br><span class="line">    bt_key_vol_up();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li>在私有任务事件进行处理后，则可以<code>return 1</code>表示成功处理；否则，调用<code>app_default_event_deal((struct sys_event *)(&amp;msg[1]));</code>将消息缓存由通用事件处理函数进行处理</li></ul><br><p>另外，每个app任务在退出切换时，会清除按键事件缓存，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">app_task_exitting</span><span class="params">()</span><span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sys_event</span> <span class="title">clear_key_event</span> =</span> &#123;.type =  SYS_KEY_EVENT, .arg = (<span class="type">void</span> *)DEVICE_EVENT_FROM_KEY&#125;;</span><br><span class="line">    <span class="keyword">if</span> (app_next_task &amp;&amp; !task_exitting) &#123;</span><br><span class="line">        <span class="comment">/* app_curr_task = app_next_task; */</span></span><br><span class="line">        <span class="comment">/* app_next_task = 0; */</span></span><br><span class="line">        task_exitting = <span class="number">1</span>;</span><br><span class="line">        sys_key_event_disable();</span><br><span class="line">        sys_event_clear(&amp;clear_key_event);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UI-LED模块"><a href="#UI-LED模块" class="headerlink" title="UI-LED模块"></a>UI-LED模块</h3><p>灯随音动的实现</p><h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><p>dev_manager提供了设备上下线、设备状态查询等api操作接口，可以支持U盘&#x2F;SD等设备挂载、查找、激活等操作，接口汇总概括如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(1) 支持设备上下线（添加/删除）</span><br><span class="line">(2) 支持设备查找</span><br><span class="line">    1) 查找第一个设备</span><br><span class="line">    2) 查找最后一个设备</span><br><span class="line">    3) 查找当前设备上一个设备</span><br><span class="line">    4) 查找当前设备下一个设备</span><br><span class="line">    5) 查找最后活动设备</span><br><span class="line">    6) 查找指定设备</span><br><span class="line">    7) 查找指定序号的设备</span><br><span class="line">(3) 支持设置设备信息</span><br><span class="line">    1) 设置设备有效/无效</span><br><span class="line">    2) 设置设备为活动设备</span><br><span class="line">(4) 支持获取设备信息</span><br><span class="line">    1) 获取设备逻辑盘符</span><br><span class="line">    2) 获取音乐设备逻辑盘符</span><br><span class="line">    3) 获取录音播放设备逻辑盘符</span><br><span class="line">    4) 获取设备根目录</span><br><span class="line">    5) 获取设备文件浏览根目录</span><br><span class="line">(5) 支持设备在线检查</span><br><span class="line">(6) 其他</span><br><span class="line">    1) 设备扫盘及扫盘释放</span><br></pre></td></tr></table></figure><h3 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h3><p>文件系统接口模块提供包含文件浏览，文件删除，打开，创建，读写，等接口</p><p>音乐，录音，解码等模式会使用到</p><h3 id="音频模块相关功能"><a href="#音频模块相关功能" class="headerlink" title="音频模块相关功能"></a>音频模块相关功能</h3><p>解码任务，用于串联所有音频流处理。</p><p>相应地有打开通道和关闭通道，相当于打开在解码任务中的 串行流 通道。  解码流都是走的解码线程</p><p>（录音编码流也有对应的 编码线程、录音线程、mix_buffer、pcm_buf 等等）</p><p><code>init.c -&gt; cpu\br28\audio_dec\audio_dec.c\audio_dec_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">audio_dec_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;audio_dec_init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建解码任务</span></span><br><span class="line">    err = audio_decoder_task_create(&amp;decode_task, <span class="string">&quot;audio_dec&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="蓝牙A2DP音频处理"><a href="#蓝牙A2DP音频处理" class="headerlink" title="蓝牙A2DP音频处理"></a>蓝牙A2DP音频处理</h4><p>何处发送该事件：</p><ol><li>底层协议栈自动发送</li><li>bt_switch_fun.c <code>a2dp_media_packet_user_handler-&gt;a2dp_media_packet_play_start</code>，后台模式下检测到有音频流，则切换至APP_BT_TASK并发送<code>BT_STATUS_A2DP_MEDIA_START</code>事件到APP_BT_TASK接收进行打开音频流</li></ol><p>bt.c-&gt;<br>app_bt_task while1-&gt; 接收到事件<br>bt_sys_event_handler-&gt;<br>bt_sys_event_office-&gt;<br>bt_connction_status_event_handler<br>-&gt; case BT_STATUS_A2DP_MEDIA_START 事件</p><p>-&gt;<br>bt_event_func.c<br>bt_status_a2dp_media_start</p><p>在文件<code>audio_dec_bt.c</code>中<br><code>a2dp_dec_open-&gt;audio_decoder_task_add_wait（a2dp_wait_res_handler）-&gt;a2dp_dec_start</code></p><p>其中audio_decoder_task_add_wait接口实现不可见</p><p><strong>重点</strong> 对a2dp_dec_start函数的实现解析，以充分理解音频流的处理流程</p><p>文件 <code>audio_dec_bt.c-&gt;int zero_entry_handle(void *priv, struct audio_data_frame *in)</code>用于对PCM原始音频数据帧的处理</p><p>文件 audio_digital_vol.c audio_digital_vol.h 包含了音量初始化及处理的相关接口：</p><p>通过<code>int audio_digital_vol_run(dvol_handle *dvol, void *data, u32 len)</code>函数实现直接对PCM数据流的音量变化处理，并实现将当前音量平滑至目标音量的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u8 toggle;<span class="comment">/*数字音量开关*/</span></span><br><span class="line">    u8 fade;<span class="comment">/*淡入淡出标志*/</span></span><br><span class="line">    u8 vol;<span class="comment">/*淡入淡出当前音量(level)*/</span></span><br><span class="line">    u8 vol_max;<span class="comment">/*淡入淡出最大音量(level)*/</span></span><br><span class="line">    s16 vol_fade;<span class="comment">/*淡入淡出对应的起始音量*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BG_DVOL_FADE_ENABLE</span></span><br><span class="line">    s16 vol_bk;<span class="comment">/*后台自动淡出前音量值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">volatile</span> s16 vol_target;<span class="comment">/*淡入淡出对应的目标音量*/</span></span><br><span class="line">    <span class="keyword">volatile</span> u16 fade_step;<span class="comment">/*淡入淡出的步进*/</span></span><br><span class="line">&#125; dvol_handle;</span><br></pre></td></tr></table></figure><h4 id="声卡功能应用"><a href="#声卡功能应用" class="headerlink" title="声卡功能应用"></a>声卡功能应用</h4><p>app_var.music_volume</p><p> printf(“common vol+: %d”, app_audio_get_volume(APP_AUDIO_CURRENT_STATE));</p><p>app_audio_set_volume(__this-&gt;state, volume, 1);</p><h4 id="提示音模块功能"><a href="#提示音模块功能" class="headerlink" title="提示音模块功能"></a>提示音模块功能</h4><p><strong>通过SDK_config配置工具-&gt;进行提示音配置</strong></p><ol><li>打开<code>//sdk/cpu/br28/tools/*配置入口.jlxproj</code>配置工具，选择<code>提示音配置</code>，可配置相应提示音的文件、格式，最终点击保存即将提示音文件转化写入到<code>cfg_tool.bin</code>中</li><li>表格的提示音名字对应<code>//apps/soundbox/common/tone_table.c</code>的语音枚举，节选如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *tone_table[] = &#123;</span><br><span class="line">    [IDEX_TONE_NUM_0] = TONE_RES_ROOT_PATH<span class="string">&quot;tone/0.*&quot;</span>,</span><br><span class="line">    [IDEX_TONE_NUM_1] = TONE_RES_ROOT_PATH<span class="string">&quot;tone/1.*&quot;</span>,</span><br><span class="line">    [IDEX_TONE_NUM_2] = TONE_RES_ROOT_PATH<span class="string">&quot;tone/2.*&quot;</span>,</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>当然，提示音的存放路径也可以放到外部存储介质中，则需要在源文件额外配置路径等。</p><br><p><strong>提示音控制接口应用</strong></p><ul><li>提示音接口API声明位于<code>//apps/soundbox/include/tone_player.h</code>，代码节选及解析如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *tone_table[];</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_open_with_callback_base</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="built_in">list</span>, u8 follow, u8 preemption, <span class="type">void</span> (*evt_handler)(<span class="type">void</span> *priv, <span class="type">int</span> flag), <span class="type">void</span> *evt_priv, <span class="type">int</span> sync_confirm_time)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, u8 preemption)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_index</span><span class="params">(u8 index, u8 preemption)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_index_with_callback</span><span class="params">(u8 index, u8 preemption, <span class="type">void</span> (*user_evt_handler)(<span class="type">void</span> *priv), <span class="type">void</span> *priv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_file_list_play</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="built_in">list</span>, u8 preemption)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_stop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_stop_by_index</span><span class="params">(u8 index)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_stop_by_path</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_get_status</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, u8 preemption)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_dec_wait_stop</span><span class="params">(u32 timeout_ms)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_pp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按名字播放提示音，播放完毕后回调evt_handler</span></span><br><span class="line"><span class="comment">// 示例场景1：从后台返回蓝牙模式，播放蓝牙提示音后，回调启动播放器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_with_callback_by_name</span><span class="params">(<span class="type">char</span> *name, <span class="comment">// 带有路径的文件名</span></span></span><br><span class="line"><span class="params">                                    u8 preemption, <span class="comment">// 打断标记</span></span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> (*evt_handler)(<span class="type">void</span> *priv, <span class="type">int</span> flag), <span class="comment">// 事件回调接口 //flag: 0正常关闭，1被打断关闭</span></span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> *evt_priv <span class="comment">// 事件回调私有句柄</span></span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按列表播放提示音</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tone_play_with_callback_by_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **<span class="built_in">list</span>, <span class="comment">// 文件名列表</span></span></span><br><span class="line"><span class="params">                                    u8 preemption, <span class="comment">// 打断标记</span></span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> (*evt_handler)(<span class="type">void</span> *priv, <span class="type">int</span> flag), <span class="comment">// 事件回调接口 //flag: 0正常关闭，1被打断关闭</span></span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> *evt_priv <span class="comment">// 事件回调私有句柄</span></span></span><br><span class="line"><span class="params">                                   )</span>;</span><br></pre></td></tr></table></figure></li></ul><p>tone_play_by_path<br>tone_play_by_path(tone_table[IDEX_TONE_PAIRING], 1);</p><p>delay_play_conn_tone_status &#x3D; sys_timeout_add(NULL,delay_play_conn_tone,1500);</p><p>tone_get_status() &#x3D;&#x3D; TONE_START</p><h3 id="录音功能应用"><a href="#录音功能应用" class="headerlink" title="录音功能应用"></a>录音功能应用</h3><p>以<code>jl701n_soundbox_sdk142</code>为例，在<code>//apps/soundbox/task_manager/record/record.c</code>有如下录音API调用逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前为app_record_task</span></span><br><span class="line"><span class="comment">// app_record_task-&gt;record_sys_event_handler-&gt;record_key_event_opr-&gt;switch (key_event) </span></span><br><span class="line">    <span class="keyword">case</span> KEY_ENC_START:</span><br><span class="line">        log_i(<span class="string">&quot;  KEY_ENC_START \n&quot;</span>);</span><br><span class="line">        record_key_pp();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record_key_pp-&gt;recorder_mix_start</span></span><br><span class="line"><span class="comment">// record_key_pp-&gt;record_mic_start</span></span><br></pre></td></tr></table></figure><p>在<code>//apps/soundbox/task_manager/app_common.c</code>文件有如下API调用逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各自模式下的app_task未处理完的事件，会调用 app_default_event_deal 进行公共事件统一处理</span></span><br><span class="line"><span class="comment">// app_default_event_deal-&gt;app_common_key_msg_deal-&gt;case KEY_ENC_START:</span></span><br><span class="line"><span class="comment">// 如按键录音事件枚举为 KEY_ENC_START ，可见公共事件中只会在 混合录音使能时，进行录音处理</span></span><br><span class="line">    <span class="keyword">case</span> KEY_ENC_START:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (RECORDER_MIX_EN)</span></span><br><span class="line">        <span class="keyword">if</span> (recorder_mix_get_status()) &#123;</span><br><span class="line">            g_printf(<span class="string">&quot;recorder_encode_stop\n&quot;</span>);</span><br><span class="line">            recorder_mix_stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g_printf(<span class="string">&quot;recorder_encode_start\n&quot;</span>);</span><br><span class="line">            recorder_mix_start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*RECORDER_MIX_EN*/</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果音频流频率跟MIC采样频率不一样，则进行 SRC 变采样处理</p><h4 id="常规MIC录音"><a href="#常规MIC录音" class="headerlink" title="常规MIC录音"></a>常规MIC录音</h4><p><code>record_mic_start-&gt;recorder_encode_start-&gt;pcm2file_enc_open-&gt;audio_encoder_open-&gt;......</code></p><h4 id="混合录音"><a href="#混合录音" class="headerlink" title="混合录音"></a>混合录音</h4><p><code>//cpu/br28/audio_enc/audio_recorder_mix.c/</code>下有<code>recorder_mix_start-&gt;__recorder_mix_start-&gt;recorder_encode_start-&gt;pcm2file_enc_open</code></p><p>音频流以及MIC输入流，混合输入编码到PCM，再存储到文件中</p><p>行与不行，核心关注：<code>//cpu/br28/audio_enc/audio_enc_file.c/pcm2file_enc_open</code></p><p>关注<code>//cpu/br28/audio_enc/audio_enc_file.c/pcm2file_enc_pcm_get</code>，有没有进来</p><p>通常问题原因有：无法创建文件、</p><h3 id="电源管理模块"><a href="#电源管理模块" class="headerlink" title="电源管理模块"></a>电源管理模块</h3><p>&#x2F;&#x2F;apps&#x2F;soundbox&#x2F;power_manage&#x2F;app_power_manage.c 提供了电源管理相关接口，如读取电池电压电量百分比、初始化接口</p><p>具体涉及到哪些功能</p><p>电池电压电量检测？通过ADC检测并滤波会存在耗时吗？可以配置DMA-ADC吗？</p><p>充电管理？</p><h3 id="蓝牙模块功能"><a href="#蓝牙模块功能" class="headerlink" title="蓝牙模块功能"></a>蓝牙模块功能</h3><p><code>btstack_main.c</code>-&gt;<code>ble_profile_init</code>-&gt;<code>app_ble_profile_init()</code>-&gt;<code>att_server_init(multi_profile_data, att_read_callback, att_write_callback);</code></p><p>实际中打印发现：</p><p>cpu&#x2F;br28&#x2F;liba&#x2F;btstack.a.llvm.1119858.spp_update_profile.c,mutil_handle_data_deal</p><p>BLE收到透传数据时，会自动调用<code>mutil_handle_data_deal()-&gt;soundcore_spp_data_receive_cb()</code></p><h4 id="蓝牙相关功能部分概述"><a href="#蓝牙相关功能部分概述" class="headerlink" title="蓝牙相关功能部分概述"></a>蓝牙相关功能部分概述</h4><p>蓝牙相关部分具体会涉及到哪些内容、哪些业务功能</p><h4 id="蓝牙模块初始化配置"><a href="#蓝牙模块初始化配置" class="headerlink" title="蓝牙模块初始化配置"></a>蓝牙模块初始化配置</h4><p>结构体类型定义位于<code>//include_lib/system/user_config.h</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">BT_CONFIG</span> &#123;</span></span><br><span class="line">    u8 edr_name[LOCAL_NAME_LEN];       <span class="comment">//经典蓝牙名</span></span><br><span class="line">    u8 mac_addr[<span class="number">6</span>];                    <span class="comment">//蓝牙MAC地址</span></span><br><span class="line">    u8 rf_power;                       <span class="comment">//发射功率</span></span><br><span class="line">    u8 dac_analog_gain;                <span class="comment">//通话DAC模拟增益</span></span><br><span class="line">    u8 mic_analog_gain;                <span class="comment">//通话MIC增益</span></span><br><span class="line">    u16 tws_device_indicate;         <span class="comment">/*设置对箱搜索标识，inquiry时候用,搜索到相应的标识才允许连接*/</span></span><br><span class="line">    u8 tws_local_addr[<span class="number">6</span>];</span><br><span class="line">    u8 ble_name[LOCAL_NAME_LEN];       <span class="comment">//ble蓝牙名</span></span><br><span class="line">    u8 ble_mac_addr[<span class="number">6</span>];                <span class="comment">//ble蓝牙MAC地址</span></span><br><span class="line">    u8 ble_rf_power;                   <span class="comment">//ble发射功率</span></span><br><span class="line">&#125; _GNU_PACKED_  BT_CONFIG;</span><br></pre></td></tr></table></figure><p>蓝牙配置初始化代码位于<code>//apps/soundbox/common/user_cfg_new.c</code>，结构体配置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BT_CONFIG bt_cfg = &#123;</span><br><span class="line">    .edr_name        = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    .mac_addr        = &#123;<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>&#125;,</span><br><span class="line">    .tws_local_addr  = &#123;<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>&#125;,</span><br><span class="line">    .rf_power        = <span class="number">10</span>,</span><br><span class="line">    .dac_analog_gain = <span class="number">25</span>,</span><br><span class="line">    .mic_analog_gain = <span class="number">7</span>,</span><br><span class="line">    .tws_device_indicate = <span class="number">0x6688</span>,</span><br><span class="line">    .ble_name        = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">    .ble_mac_addr        = &#123;<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>&#125;,</span><br><span class="line">    .ble_rf_power        = <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，上述的配置信息仅作结构体展示用，并没有实际设置至程序中。</p><p>在当前文件下的<code>cfg_file_parse(u8 idx)</code>函数（入参“idx”没有被调用）会重新覆盖初始化设置该配置结构体参数，包括蓝牙名称，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ret = syscfg_read(CFG_BT_NAME, tmp, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    log_info(<span class="string">&quot;read bt name err\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt;= LOCAL_NAME_LEN) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(bt_cfg.edr_name, <span class="number">0x00</span>, LOCAL_NAME_LEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(bt_cfg.edr_name, tmp, LOCAL_NAME_LEN);</span><br><span class="line">    bt_cfg.edr_name[LOCAL_NAME_LEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    log_info(<span class="string">&quot;read new cfg bt name config:%s\n&quot;</span>, tmp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(bt_cfg.edr_name, <span class="number">0x00</span>, LOCAL_NAME_LEN);</span><br><span class="line">    <span class="built_in">memcpy</span>(bt_cfg.edr_name, tmp, ret);</span><br><span class="line">    log_info(<span class="string">&quot;read new cfg bt name config:%s\n&quot;</span>, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* g_printf(&quot;bt name config:%s\n&quot;, bt_cfg.edr_name); */</span></span><br><span class="line">log_info(<span class="string">&quot;bt name config:%s\n&quot;</span>, bt_cfg.edr_name);</span><br></pre></td></tr></table></figure><h2 id="芯片外设配置开发"><a href="#芯片外设配置开发" class="headerlink" title="芯片外设配置开发"></a>芯片外设配置开发</h2><h3 id="时钟系统配置"><a href="#时钟系统配置" class="headerlink" title="时钟系统配置"></a>时钟系统配置</h3><p>低速外设时钟源 LSB</p><p>时钟源打印 <code>clock_dump</code></p><h3 id="杰理音频芯片系列通用外设"><a href="#杰理音频芯片系列通用外设" class="headerlink" title="杰理音频芯片系列通用外设"></a>杰理音频芯片系列通用外设</h3><p>研读杰理<code>工程音频技术应用文档</code>，依照其资料大纲，按照个人理解方式，重述外设驱动应用开发部分。</p><h4 id="普通外设"><a href="#普通外设" class="headerlink" title="普通外设"></a>普通外设</h4><p>普通外设概览如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RESET：可配置作复位、唤醒、低功耗唤醒脚</span><br><span class="line">TIMER：</span><br><span class="line">UART：</span><br><span class="line">SPI：</span><br><span class="line">内部Flash：</span><br><span class="line">IIC：</span><br><span class="line">GPIO：</span><br><span class="line">PWM：</span><br><span class="line">SD&amp;USB：</span><br><span class="line">时钟外设（RTC、省晶振）：</span><br><span class="line">GPCNT：</span><br><span class="line">IOMAP（IO重映射）：</span><br><span class="line">复用应用：</span><br></pre></td></tr></table></figure><br><h4 id="音频外设"><a href="#音频外设" class="headerlink" title="音频外设"></a>音频外设</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUX/音频ADC：</span><br><span class="line">IIS：</span><br><span class="line">HDMI（ARC）：</span><br><span class="line">SPDIF：</span><br><span class="line">PDM LINK：</span><br></pre></td></tr></table></figure><h3 id="外设IO功能宏定义配置"><a href="#外设IO功能宏定义配置" class="headerlink" title="外设IO功能宏定义配置"></a>外设IO功能宏定义配置</h3><p>宏定义配置路径位于<code>//apps/soundbox/board/br28/board_jl791n_demo/board_jl701n_demo_cfg.h</code></p><h2 id="杰理SDK编译、构建、链接、下载流程概述"><a href="#杰理SDK编译、构建、链接、下载流程概述" class="headerlink" title="杰理SDK编译、构建、链接、下载流程概述"></a>杰理SDK编译、构建、链接、下载流程概述</h2><p>bootloader、app、备份区、数据区等</p><h3 id="SDK顶层Makefile结构解析"><a href="#SDK顶层Makefile结构解析" class="headerlink" title="SDK顶层Makefile结构解析"></a>SDK顶层Makefile结构解析</h3><h4 id="编译链、环境路径、特定工具设置"><a href="#编译链、环境路径、特定工具设置" class="headerlink" title="编译链、环境路径、特定工具设置"></a>编译链、环境路径、特定工具设置</h4><ul><li>根据<code>$(OS)</code>变量判断当前是Windows还是Linux，分别设置各系统下的编译工具链路径</li><li>设置工具链下的具体可执行程序路径，如CC、LD、AD等；设置一些通用CMD命令，如mkdir、rm -rf等</li><li>设置系统库及其库头文件搜索路径等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows下为</span><br><span class="line">SYS_LIB_DIR := C:/JL/pi32/pi32v2-lib/r3-large</span><br><span class="line">SYS_INC_DIR := C:/JL/pi32/pi32v2-include</span><br></pre></td></tr></table></figure></li><li>将工具链路径export到环境变量中（特别地 CC CXX LD AR这四个变量被强制使用指定工具链路径下的可执行程序）</li><li>设置输出文件和编译生成路径</li></ul><h4 id="编译参数、宏定义设置"><a href="#编译参数、宏定义设置" class="headerlink" title="编译参数、宏定义设置"></a>编译参数、宏定义设置</h4><h4 id="头文件搜索路径、源文件路径设置"><a href="#头文件搜索路径、源文件路径设置" class="headerlink" title="头文件搜索路径、源文件路径设置"></a>头文件搜索路径、源文件路径设置</h4><h4 id="链接参数设置"><a href="#链接参数设置" class="headerlink" title="链接参数设置"></a>链接参数设置</h4><h4 id="预构建流程"><a href="#预构建流程" class="headerlink" title="预构建流程"></a>预构建流程</h4><p>特别地，其中在实际编译和链接之前的<code>pre_build</code>过程需要注意：</p><ol><li>cpu&#x2F;br28&#x2F;sdk_used_list.c -o cpu&#x2F;br28&#x2F;sdk_used_list.used 链接选项用到</li><li>cpu&#x2F;br28&#x2F;sdk_ld.c -o cpu&#x2F;br28&#x2F;sdk.ld 链接选项用到</li><li>cpu&#x2F;br28&#x2F;tools&#x2F;download.c -o $(POST_SCRIPT) 编译链接完成后执行此脚本</li><li>$(FIXBAT) $(POST_SCRIPT) 格式转换</li><li>cpu&#x2F;br28&#x2F;tools&#x2F;isd_config_rule.c -o cpu&#x2F;br28&#x2F;tools&#x2F;isd_config.ini 固件下载升级时用到的配置文件？</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pre_build:</span><br><span class="line">$(info +PRE-BUILD)</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/sdk_used_list.c -o cpu/br28/sdk_used_list.used</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/sdk_ld.c -o cpu/br28/sdk.ld</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/tools/download.c -o $(POST_SCRIPT)</span><br><span class="line">$(QUITE) $(FIXBAT) $(POST_SCRIPT)</span><br><span class="line">$(QUITE) $(CC) $(CFLAGS) $(DEFINES) $(INCLUDES) -D__LD__ -E -P cpu/br28/tools/isd_config_rule.c -o cpu/br28/tools/isd_config.ini</span><br></pre></td></tr></table></figure><p>上述预构建过程解析如下：<br>-E: 这个选项告诉编译器只执行预处理阶段，不进行实际的编译。这意味着编译器将读取源代码，执行宏替换、文件包含等预处理操作，然后停止，不生成任何机器代码。</p><p>-P: 这个选项请求预处理器不生成传统的预处理输出，而是生成更易读的输出，这通常意味着移除行号和文件名标记，使得输出更适合进一步处理，比如用作脚本的一部分。</p><h4 id="源文件构建流程"><a href="#源文件构建流程" class="headerlink" title="源文件构建流程"></a>源文件构建流程</h4><ul><li>使用通配符和转换规则，使<code>c_OBJS, S_OBJS, s_OBJS, cpp_OBJS, cxx_OBJS, cc_OBJS</code>分别映射包含所有源文件编译生成对应的 .o 目标文件</li><li>定义<code>OBJS</code>包含所有类型的目标文件；定义<code>DEP_FILES</code>包含所有的.d依赖文件，用于增量编译判断用。</li><li>修改 OBJS 和 DEP_FILES 的值，增加BUILD_DIR前缀，使得所有构建过程输出都位于BUILD_DIR目录下</li><li><code>VERBOSE</code>控制编译过程输出详细日志，默认为0，可设置为1，如<code>make VERBOSE=1</code>; <code>LINK_AT</code>用于决定是否使用file函数</li><li>定义构建伪目标<code>all、pre_build、clean</code>，规则、编译、依赖文件包含等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all依赖于pre_build和OUT_ELF（即sdk.elf）（层层目标依赖，直至源文件-&gt;目标文件的编译），直接输入make时，默认执行make all。其执行完编译链接流程后，最后调用脚本`cpu\br28\tools\download.bat`进行下载</span><br><span class="line"></span><br><span class="line">pre_build用于执行预处理步骤，如生成配置文件、链接脚本、下载脚本</span><br><span class="line"></span><br><span class="line">clean用于清理构建过程产生的中间文件，如rm -rf BUILD_DIR xxx</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="相关的配置、链接、下载脚本解析"><a href="#相关的配置、链接、下载脚本解析" class="headerlink" title="相关的配置、链接、下载脚本解析"></a>相关的配置、链接、下载脚本解析</h3><h4 id="cpu-br28-sdk-used-list-c"><a href="#cpu-br28-sdk-used-list-c" class="headerlink" title="cpu&#x2F;br28&#x2F;sdk_used_list.c"></a>cpu&#x2F;br28&#x2F;sdk_used_list.c</h4><h4 id="cpu-br28-sdk-ld-c"><a href="#cpu-br28-sdk-ld-c" class="headerlink" title="cpu&#x2F;br28&#x2F;sdk_ld.c"></a>cpu&#x2F;br28&#x2F;sdk_ld.c</h4><p>段分配、地址分配等</p><p>各模块的链接</p><h4 id="cpu-br28-tools-download-c"><a href="#cpu-br28-tools-download-c" class="headerlink" title="cpu&#x2F;br28&#x2F;tools&#x2F;download.c"></a>cpu&#x2F;br28&#x2F;tools&#x2F;download.c</h4><p>生成了download.bat，其里调用了子目录download.bat</p><p>fw_add 固件打包流程</p><h4 id="cpu-br28-tools-isd-config-rule-c"><a href="#cpu-br28-tools-isd-config-rule-c" class="headerlink" title="cpu&#x2F;br28&#x2F;tools&#x2F;isd_config_rule.c"></a>cpu&#x2F;br28&#x2F;tools&#x2F;isd_config_rule.c</h4><h3 id="杰理程序烧录、下载、升级等概述"><a href="#杰理程序烧录、下载、升级等概述" class="headerlink" title="杰理程序烧录、下载、升级等概述"></a>杰理程序烧录、下载、升级等概述</h3><p>cpu&#x2F;br28&#x2F;tools&#x2F;download&#x2F;soundbox&#x2F;download.bat的执行流程</p><p>检测到目标设备当前固件与下载固件一致，则不进行升级，此部分代码体现在何处？</p><p>USB DP&#x2F;DM 通信传输代码实现？</p><h4 id="升级实现"><a href="#升级实现" class="headerlink" title="升级实现"></a>升级实现</h4><p>串口升级设计代码实现？</p><p>蓝牙升级部分代码实现？<br>蓝牙BLE主要走SPP串口透传<br>EDR蓝牙升级<br>U盘升级：.ufw文件<br>串口升级</p><h2 id="简单思考及拓展"><a href="#简单思考及拓展" class="headerlink" title="简单思考及拓展"></a>简单思考及拓展</h2><h3 id="是如何通过宏定义进行不同板级选择的？不同配置的板级代码之间有何异同？"><a href="#是如何通过宏定义进行不同板级选择的？不同配置的板级代码之间有何异同？" class="headerlink" title="是如何通过宏定义进行不同板级选择的？不同配置的板级代码之间有何异同？"></a>是如何通过宏定义进行不同板级选择的？不同配置的板级代码之间有何异同？</h3><p>Makefile把所有源文件都包含了进去，通过 xxx_config.h 对相应的板级配置.h文件开启 条件编译，同样的，相应的 .c 实现文件也开启了条件编译。</p><p>那不同板级的配置差异体现在哪里？为何存在这些差异？他们的业务应用区别是？<br>：</p><h3 id="杰理codeblock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？效率有何差异？"><a href="#杰理codeblock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？效率有何差异？" class="headerlink" title="杰理codeblock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？效率有何差异？"></a>杰理codeblock工程是如何进行构建编译的？与SDK根目录的Makefile构建方式的具体异同？效率有何差异？</h3><h3 id="下载脚本download-bat执行的详细链路解析？具体是如何通过USB-DP-DM，以何种协议进行程序下载升级的？"><a href="#下载脚本download-bat执行的详细链路解析？具体是如何通过USB-DP-DM，以何种协议进行程序下载升级的？" class="headerlink" title="下载脚本download.bat执行的详细链路解析？具体是如何通过USB DP&#x2F;DM，以何种协议进行程序下载升级的？"></a>下载脚本download.bat执行的详细链路解析？具体是如何通过USB DP&#x2F;DM，以何种协议进行程序下载升级的？</h3><h3 id="不同芯片的SDK，其软件设计框架具体有何异同？为何？举实例分析与软件设计的相关因素？"><a href="#不同芯片的SDK，其软件设计框架具体有何异同？为何？举实例分析与软件设计的相关因素？" class="headerlink" title="不同芯片的SDK，其软件设计框架具体有何异同？为何？举实例分析与软件设计的相关因素？"></a>不同芯片的SDK，其软件设计框架具体有何异同？为何？举实例分析与软件设计的相关因素？</h3><h3 id="杰理不同系列芯片SDK的适用业务方案范围大概是怎样的？概括一下？"><a href="#杰理不同系列芯片SDK的适用业务方案范围大概是怎样的？概括一下？" class="headerlink" title="杰理不同系列芯片SDK的适用业务方案范围大概是怎样的？概括一下？"></a>杰理不同系列芯片SDK的适用业务方案范围大概是怎样的？概括一下？</h3><h3 id="在底层驱动代码或者库源码不可见的情况下，如何界定某些bug是出自于上层业务还是底层代码？通常的方法论是？举实用实例？"><a href="#在底层驱动代码或者库源码不可见的情况下，如何界定某些bug是出自于上层业务还是底层代码？通常的方法论是？举实用实例？" class="headerlink" title="在底层驱动代码或者库源码不可见的情况下，如何界定某些bug是出自于上层业务还是底层代码？通常的方法论是？举实用实例？"></a>在底层驱动代码或者库源码不可见的情况下，如何界定某些bug是出自于上层业务还是底层代码？通常的方法论是？举实用实例？</h3><h3 id="设备的各种提示音的内容定义、播放逻辑、业务流程、提示音文件打包下载-具体是如何做的？"><a href="#设备的各种提示音的内容定义、播放逻辑、业务流程、提示音文件打包下载-具体是如何做的？" class="headerlink" title="设备的各种提示音的内容定义、播放逻辑、业务流程、提示音文件打包下载 具体是如何做的？"></a>设备的各种提示音的内容定义、播放逻辑、业务流程、提示音文件打包下载 具体是如何做的？</h3><h3 id="不同业务模式，如耳机、蓝牙、音箱等的主要业务代码区别体现在何处？"><a href="#不同业务模式，如耳机、蓝牙、音箱等的主要业务代码区别体现在何处？" class="headerlink" title="不同业务模式，如耳机、蓝牙、音箱等的主要业务代码区别体现在何处？"></a>不同业务模式，如耳机、蓝牙、音箱等的主要业务代码区别体现在何处？</h3><p>如开机后进入<code>POWERON_TASK</code>模式，轮询检测各模块的消息从而决定进入哪个工作模式，当音频蓝牙连接时，app_task则切换至<code>APP_BT_TASK</code></p><h3 id="是如何实现声音播放淡入淡出的？具体代码原理分析？"><a href="#是如何实现声音播放淡入淡出的？具体代码原理分析？" class="headerlink" title="是如何实现声音播放淡入淡出的？具体代码原理分析？"></a>是如何实现声音播放淡入淡出的？具体代码原理分析？</h3><p>通过对PCM数据流的处理，作渐进比例控制，从而实现声音淡入淡出效果</p><h3 id="具体分别说下模式主任务app-task与各子模块的交互设计及切换流程？"><a href="#具体分别说下模式主任务app-task与各子模块的交互设计及切换流程？" class="headerlink" title="具体分别说下模式主任务app_task与各子模块的交互设计及切换流程？"></a>具体分别说下模式主任务app_task与各子模块的交互设计及切换流程？</h3><p>各模块的任务检测到有事件发生后，通过消息队列发送至 app_task，app_task接收到消息后进行相应的处理</p><p>如 按键模块，代码实现：<br>蓝牙连接事件通知处理如：<br>等等</p><h3 id="APP-TASK各模式处理接收的事件的具体流程？"><a href="#APP-TASK各模式处理接收的事件的具体流程？" class="headerlink" title="APP_TASK各模式处理接收的事件的具体流程？"></a>APP_TASK各模式处理接收的事件的具体流程？</h3><h3 id="如何具体基于release-SDK作增量-二次业务开发？"><a href="#如何具体基于release-SDK作增量-二次业务开发？" class="headerlink" title="如何具体基于release_SDK作增量&#x2F;二次业务开发？"></a>如何具体基于release_SDK作增量&#x2F;二次业务开发？</h3><p>二次业务开发，通常是新起文件夹，新建文件，并将其加入Makefile中，然后编译链接即可</p><p>当然，其实也可以拷贝一份板级配置以及板级相关源文件，改为新的板级配置，在此基础上进行开发。</p><h3 id="公版SDK是？与手上的SDK-Release有何区别？如何添加Key？"><a href="#公版SDK是？与手上的SDK-Release有何区别？如何添加Key？" class="headerlink" title="公版SDK是？与手上的SDK_Release有何区别？如何添加Key？"></a>公版SDK是？与手上的SDK_Release有何区别？如何添加Key？</h3><p>release即公版SDK</p><p>Key是一个文件，在实际的下载脚本中，添加<code>-key &lt;param&gt;</code>下载带有相关代理商Key的固件到目标芯片。</p><p>空片则对应无Key下载，带Key的芯片则要带相应Key参数进行下载升级。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 杰理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【编程】私有通信协议栈的开发设计与应用</title>
      <link href="/2024/04/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2024/04/02/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果日常的工作开发中，经常涉及到多设备&#x2F;多模块协同工作的软件设计，那么定义一个基于硬件通信接口之上的私有通信协议规范是必不可少的。</p><p>稳定、可靠、规范的通用通信协议，有利于模块化、提高复用、抗干扰能力强、方便做扩展设计等等，本文以私有串口通信协议为例，分享个人对自定义协议的理解、中间层组件库软件（句柄数据结构、组包解包函数）设计以及业务设计等内容。</p><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><p>通信协议通常表现为数据包的格式定义，其可以概括为 <strong>起始位、包头部分、数据部分、检验位、结束位</strong> 这几项。</p><h3 id="包的构成要素"><a href="#包的构成要素" class="headerlink" title="包的构成要素"></a>包的构成要素</h3><p>首先，在通信协议中，定义一个数据包的起始位和结束位是必要的，由此来识别收到一个完整的数据包。以下为一个包的常见构成要素：<br><strong>协议版本、包序号、包类型、控制位、保留位、数据长度、指令、数据、检验位</strong></p><p>注意：多设备设计时需要设计地址，本文主要讲述两设备间的串口通信协议，不涉及多设备间的通信。</p><p>在通信过程中，设备在收到一个包后，其也要有针对这个包的回复包。所以，定义发送包和回复包格式有一定必要性，具体取决于实际需求。发送包可以有多种包类型，针对发送包的回复包也要相应的回复响应包类型。 回复包需要包含所要回复的发送包包序号。发送方向可以是 控制器 to 控制器， 控制器 to 模块，也可以是 模块 to 控制器，等等不固定</p><h4 id="发送包格式"><a href="#发送包格式" class="headerlink" title="发送包格式"></a>发送包格式</h4><p>协议数据发送包–包括以下元素：</p><ul><li>起始位</li><li>协议版本：用于区分不同版本的通信协议</li><li>包序号：用于指示当前的包的序号，用于指示</li><li>包类型：用于区分不同类型的发送包，还是不同类型的回复包，具体设计取决于开发者</li><li>控制位：用于指示包的特性，比如是否需要校验、是否有分包、是否是分包中的结束包等等，用于满足开发者的特殊需求</li><li>保留位：用于可能的后续扩展设计</li><li>数据长度：可以用于指示 指令码 + 数据 的长度</li><li>指令码：用于指示私有协议中的交互控制命令</li><li>数据：指令码附带的设置数据</li><li>检验位：对包数据的检验，可以定义为 CRC 校验，也可以是和校验等等</li><li>结束位</li></ul><h4 id="回复包格式"><a href="#回复包格式" class="headerlink" title="回复包格式"></a>回复包格式</h4><p>协议数据回复包–包括以下元素：</p><ul><li>起始位</li><li>协议版本：用于区分不同版本的通信协议</li><li>包序号：用于指示当前的包的序号，用于指示</li><li>包类型：用于区分不同类型的发送包，还是不同类型的回复包，具体设计取决于开发者</li><li>控制位：用于指示包的特性，比如是否需要校验、是否有分包、是否是分包中的结束包等等，用于满足开发者的特殊需求</li><li>保留位：用于可能的后续扩展设计</li><li>数据长度：可以用于指示 指令码 + 数据 的长度</li><li>接收的包序号：用于指示是针对收到哪一个包的回复</li><li>指令码：用于指示收到私有协议的交互控制命令</li><li>数据：指令码附带的设置数据，可以用于指示确认结果、执行结果、或者执行完命令后附带的回复数据</li><li>检验位：对包数据的检验</li><li>结束位</li></ul><h3 id="包类型"><a href="#包类型" class="headerlink" title="包类型"></a>包类型</h3><p>包类型的设计不是必须的，由开发者根据实际的业务需要进行评估</p><p>以本文设计为例，将发送包类型大致分为以下几种：</p><ul><li>发送命令包：发送方指示接收方执行相应的动作指令，可指定是否需要接收方回复</li><li>发送数据请求包：发送方指示接收方回复其所需要的业务数据</li><li>发送通知包：发送方主动通知接收方在己方所变化的一些事件，可指定是否需要接收方回复</li></ul><p>回复包类型分为以下几种：</p><ul><li>命令响应包：接收到发送命令包，接收方进行响应，并回复一个命令响应包至发送方</li><li>数据响应包：接收到发送方的数据请求，回复数据响应包至发送方</li><li>通知响应包：接收到发送方的通知，回复通知响应包至发送方</li></ul><h3 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h3><p>此部分略，主要为双方开始建立通信，进行初始化的流程，由开发者根据实际需要进行设计即可。</p><p>如：握手、回复、交互获取、通知进行基本信息初始化、心跳包</p><h2 id="通用中间件软件设计"><a href="#通用中间件软件设计" class="headerlink" title="通用中间件软件设计"></a>通用中间件软件设计</h2><p>在本文的私有通信协议开发中，</p><p>设计通用中间件，主要有两点，一是私有句柄的数据结构设计，二是软件函数设计</p><h3 id="软件设计要素"><a href="#软件设计要素" class="headerlink" title="软件设计要素"></a>软件设计要素</h3><p>回调函数（包括私有句柄、包类型、命令码、数据缓存指针、数据长度）</p><p>超时设计</p><p>分包设计</p><p>发送间隔设计</p><p>最大最小包限制设计</p><p><strong>应用状态机进行解包设计</strong></p><h4 id="容错设计"><a href="#容错设计" class="headerlink" title="容错设计"></a>容错设计</h4><p>滑动窗口设计：一次传入的并不是整包，而是半包，后面再递进传入后半包。<br>每个通信接口实现都维护有一个私有句柄，其中包含私有的Buffer，当一次性传入半包数据时，将包数据拷贝到私有Buffer中，而后会停留在解包状态中，而不会认为此包数据无效</p><p>粘包：一次读取到两个包<br>根据Buffer顺序递增解包，解完一包后触发回调函数，返回后接着解Buffer中剩下的包</p><h3 id="宏定义及数据类型设计"><a href="#宏定义及数据类型设计" class="headerlink" title="宏定义及数据类型设计"></a>宏定义及数据类型设计</h3><h3 id="私有句柄结构设计"><a href="#私有句柄结构设计" class="headerlink" title="私有句柄结构设计"></a>私有句柄结构设计</h3><p>注册回调函数和硬件层的发送驱动</p><h3 id="解包函数设计"><a href="#解包函数设计" class="headerlink" title="解包函数设计"></a>解包函数设计</h3><p>提供多个接口包括：逐个字节解包，多个字节解包</p><p>应用状态机的迭代循环解包方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组包函数设计"><a href="#组包函数设计" class="headerlink" title="组包函数设计"></a>组包函数设计</h3><h2 id="串行通信业务软件设计"><a href="#串行通信业务软件设计" class="headerlink" title="串行通信业务软件设计"></a>串行通信业务软件设计</h2><h3 id="初始化软件设计"><a href="#初始化软件设计" class="headerlink" title="初始化软件设计"></a>初始化软件设计</h3><h3 id="业务处理软件设计"><a href="#业务处理软件设计" class="headerlink" title="业务处理软件设计"></a>业务处理软件设计</h3><p>可以应用命令模式，在业务上层将接收到的串口命令与执行函数建立一个映射执行关系</p><h2 id="疑惑解答"><a href="#疑惑解答" class="headerlink" title="疑惑解答"></a>疑惑解答</h2><h3 id="复杂度分析及软件方案取舍"><a href="#复杂度分析及软件方案取舍" class="headerlink" title="复杂度分析及软件方案取舍"></a>复杂度分析及软件方案取舍</h3><p>包含所有容错的软件设计，对接收到的包逐字节分析，时间复杂度：O(n^2)</p><p>在迭代循环里判断，空间复杂度为：O(1)</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/ybhuangfugui/article/details/123143683">通信教程 | 自定义串口通信协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【编程】嵌入式单片机C语言开发之设计模式概述</title>
      <link href="/2024/03/01/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/03/01/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚入职时就听导师谈起设计模式，也被建议去看《设计模式》这本书，当时只觉高深莫测，兴冲冲地去买了书籍回来打算在工作之余细细研读一番，脑海里还臆想着通读完此书即可功力大成</p><p>只可惜，作为一名嵌入式C语言开发小白，根本看不懂用 Java语言 写的《设计模式》，硬着头皮读了几天书也就弃下了。眼瞅着看书这条路径走不通，当然要换种思路了，总要跟设计模式扯上点关系不是？</p><p>于是，又去网上搜罗拜读了一堆适宜小白阅览的文章，想着如何给私有的C业务代码应用上各种设计模式，好展示一番代码功底</p><p>后来，在知乎看到了一条评论：“<strong>往往都是那些毕业一两年的小白楞头青，才会整天想着设计模式如此如此，非得本末倒置地给业务强行用上各种设计模式，仿佛只有这样才能满足其那颗躁动的心</strong>”。受此评论触动，深觉业务开发才是技术之本，应当去多研读工程业务之源码，没必要硬磕设计模式，当所了解与所开发的业务越来越繁杂的时候，那么设计模式及其相关思想的应用落地也就是必然的事情了。</p><hr><p>现如今，已工作一年有余，也接触开发了不少项目，个中也有较多业务逻辑用到设计模式的思想，因此有必要系统回顾并总结一下在嵌入式开发中所应用到的设计模式</p><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>本章节阐述本人对设计模式浅薄的书面理解。</p><p>首先，我们需要理清<strong>设计思想</strong>与<strong>设计模式</strong>这两个概念：</p><p>通常我们会说，进行软件设计，最重要的是思想，对于一个嵌入式软件工程师来说，首要的就是设计思想。当一个项目交到手上，我们会想这个工程能不能实现、其功能业务理论可行性，而<strong>探讨可行性，即是在构思软件的大致解决思路和方法，这就是软件顶层思想的具体实践</strong>了。而在正式开展编码工作之前，当然要明确下代码的架构设计，比如：如何对业务进行划分具体模块、如何对整体工程划分层次、如何设计交互接口等等，这些都是属于设计思想的范畴。</p><p>当然，只有设计理论，没有编码设计实践是万万不行的。而设计模式即是设计思想的具体实践，我们说想要在代码上应用到我们的思想，最好是不要闭门造车，要多参考他人的代码设计方法，如设计模式，其是前人基于设计思想提炼出来的经过无数验证的成熟模型。参考使用设计模式可以帮助更好地组织代码、提高可维护性、保证软件的可靠性。</p><p>以上纯属废话，鄙人对设计模式其实也没明确的概念，也不建议事事都要扯上设计模式，私以为如果<strong>一个软件模块的可读性良好、逻辑层次清晰明了、方便进行扩展设计和维护、能够很好地实现目标业务功能</strong>，那么其即属于优秀的软件设计。</p><h2 id="实际开发应用分析"><a href="#实际开发应用分析" class="headerlink" title="实际开发应用分析"></a>实际开发应用分析</h2><p>未完待续。。。。。。</p><h3 id="状态模式及其应用分析"><a href="#状态模式及其应用分析" class="headerlink" title="状态模式及其应用分析"></a>状态模式及其应用分析</h3><p>状态机广泛应用于嵌入式业务开发中</p><ul><li>设备状态机：整机设备在其工作周期中存在不同的状态，每个状态下接收到不同的事件，会有不同的响应操作，此时在整个设备顶层业务开发中可以应用状态模式。</li><li>通信协议封包、解包设计：解包时，可以定义当前对 缓存数据 的解包状态，如获取到起始位、包头解析、数据解析、包校验等等、通过状态机设计，可以实现高效严谨通用的解包库函数设计。</li><li>通信协议应用业务：在通信协议处理中，也存在状态的切换和不同状态下的处理回复，比如握手、握手回复、获取相关信息、等等，可以应用状态模式来设计 设备间通信协议的交互。</li></ul><p>当然模块内业务根据需要也可以应用状态模式，在不同的状态下接收到不同的事件，从而执行相应的操作</p><h3 id="观察者模式及其应用分析"><a href="#观察者模式及其应用分析" class="headerlink" title="观察者模式及其应用分析"></a>观察者模式及其应用分析</h3><p>观察者模式：</p><p>如：在按键示例中，按键事件可以当作被观察者，受按键触发的其它操作为观察者，当轮询检测到按键按下时，调用所有观察者回调函数</p><p>如：温度监控</p><p>如：状态变化</p><h3 id="命令模式及其应用分析"><a href="#命令模式及其应用分析" class="headerlink" title="命令模式及其应用分析"></a>命令模式及其应用分析</h3><p>命令模式，通俗点理解就是通过一层转换，将输入的命令码对应成相应的执行操作。（<strong>ps：有大神说该模式的核心在于把命令下达与命令执行在时间上进行分离</strong>）</p><p>一个代码实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tiny_ev_map_func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> cmd;</span><br><span class="line">  <span class="type">void</span> (*func)(<span class="type">void</span>);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tiny_ev_map_func</span> <span class="title">main_ev_func_list</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;MAIN_EV_CHARGER_INSERT, func_ev_pm_charge_insert&#125;,</span><br><span class="line">    &#123;MAIN_EV_CHARGER_FINISH, func_ev_pm_charge_finish&#125;,</span><br><span class="line">    &#123;MAIN_EV_BAT_ELE_QUANTITY, func_ev_pm_ele_quantity&#125;,</span><br><span class="line">    &#123;MAIN_EV_BAT_TEMPERATURE, func_ev_pm_temperture&#125;,</span><br><span class="line">    &#123;MAIN_EV_BAT_TEMP_ABNORMAL, func_ev_pm_temp_abnormal&#125;,</span><br><span class="line">    &#123;MAIN_EV_BTN_FIRST, func_ev_btn_first&#125;,</span><br><span class="line">    &#123;MAIN_EV_BTN_SECOND, func_ev_btn_second&#125;,</span><br><span class="line">    &#123;MAIN_EV_HEATER_COMPLEX, func_ev_heater_complex&#125;,</span><br><span class="line">    &#123;MAIN_EV_HEATER_SWITCH, func_ev_heater_switch&#125;,</span><br><span class="line">    &#123;MAIN_EV_HEATER_TEMP_USER, func_ev_heater_temp_user&#125;,</span><br><span class="line">    &#123;MAIN_EV_HEATER_TEMP_RT, func_ev_heater_temp_rt&#125;,</span><br><span class="line">    &#123;MAIN_EV_HEATER_ERROR, func_ev_heater_error&#125;,</span><br><span class="line">    &#123;MAIN_EV_MASSAGE_EV_SWITCH, func_ev_massage_switch&#125;,</span><br><span class="line">    &#123;MAIN_EV_MASSAGE_EV_MODE, func_ev_massage_mode&#125;,</span><br><span class="line">    &#123;MAIN_EV_MASSAGE_EV_ERROR, func_ev_massage_error&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_func_map_cmd</span><span class="params">(<span class="type">uint16_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(main_ev_func_list); ++i)</span><br><span class="line">        <span class="keyword">if</span> (main_ev_func_list[i].cmd == cmd)</span><br><span class="line">            main_ev_func_list[i].func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式及其应用分析"><a href="#适配器模式及其应用分析" class="headerlink" title="适配器模式及其应用分析"></a>适配器模式及其应用分析</h3><p>用于将一个接口转换成另一个接口，从而实现更好的模块层级间调用、接口兼容、解耦</p><p>用于不同硬件设备的兼容、不同软件模块的兼容等</p><h3 id="外观模式及其应用分析"><a href="#外观模式及其应用分析" class="headerlink" title="外观模式及其应用分析"></a>外观模式及其应用分析</h3><p>外观模式用于隐藏一系列复杂接口，为外部或者上层应用提供一个统一简单的接口，使得开发者无须关心其内复杂的实现，并可降低代码耦合度</p><p>如 RT-Thread 设备驱动框架：</p><ul><li>I&#x2F;O 设备管理层：应用程序通过 I&#x2F;O 设备提供的标准接口访问底层设备，使得设备驱动的升级和迭代不会对上层应用产生影响</li><li>设备驱动框架层：抽象同类硬件设备驱动，如 ADC、PWM、UART等分类</li><li>设备驱动层：驱使硬件设备工作的底层程序</li></ul><h3 id="中介者模式及其应用分析"><a href="#中介者模式及其应用分析" class="headerlink" title="中介者模式及其应用分析"></a>中介者模式及其应用分析</h3><p>该模式通过引入一个中介者对象，将原本需要直接交互的多个对象之间的关系转化为中介者与这些对象之间的关系，从而实现了解耦。</p><p>中介者模式用于协调复杂交互，使得各个硬件接口不需要显式地相互引用，从而降低耦合度。</p><h3 id="访问者模式及其应用分析"><a href="#访问者模式及其应用分析" class="headerlink" title="访问者模式及其应用分析"></a>访问者模式及其应用分析</h3><p>较为复杂，暂未理解，后续补充</p><h2 id="示例代码实现"><a href="#示例代码实现" class="headerlink" title="示例代码实现"></a>示例代码实现</h2><p>此处略，后续文章补充</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/104212509">C常用设计模式——命令模式</a></p></li><li><p><a href="https://blog.csdn.net/wqx521/article/details/93589663">C语言设计模式——命令模式</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> C语言 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】嵌入式开发之命令行调试-Shell全剖析</title>
      <link href="/2024/02/08/%E3%80%90MCU%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
      <url>/2024/02/08/%E3%80%90MCU%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人初次接触命令行调试，还是在大学时初学正点原子 STM32 教程，其提供了一个软件组件用于调试：（<strong>只要你在串口输入相应的函数名，单片机就能执行相应的函数</strong>），当时真的惊为天人，觉得这种调试方法很神奇也很有意思。</p><p>那时不了解什么是命令行，什么是Shell，也没有能力或者精力去了解其原理实现，即使那软件组件并不具备一个 Shell 的完整功能，但也足以震惊初学STM32点灯的我</p><p>随着开发经历多起来，日常Linux Shell、PowerShell、嵌入式Shell 等等各种什么 Shell 的字眼充斥耳边，本人也对 Shell 这个词有了新的理解，因此也就写下这篇文章，主要为总结和升华个人对嵌入式 Shell 的应用及理解，当然也包括其它的一些方面，或者说在研读源码过程中，能够学习到一些编程方式&#x2F;方法&#x2F;思想，那就更好不过了</p><h2 id="命令行概述"><a href="#命令行概述" class="headerlink" title="命令行概述"></a>命令行概述</h2><p>官方百科：Shell，即命令行解释器，是计算机操作系统的一种用户界面，用户可以通过Shell与操作系统进行交互，输入命令来执行各种操作、控制系统的各种功能。Bash、Windows CMD、PowerShell等都是属于命令行解释器</p><p>那么嵌入式Shell也是同理，只不过用户是使用上位机串口软件输入命令与嵌入式设备进行交互而已（通常是通过UART串口与外界交互，但其实也可以将输入输出流设置到其它外设上，如蓝牙BLE透传、TCP&#x2F;IP等）</p><p>比如在Linux Shell中，用户在命令行界面输入如<code>ls cd touch gcc make</code>等这些命令，使得Shell解释器会调用相对应名称的可执行程序，当然了通常输入命令还可以附带参数，这就跟C函数也有入口参数一样。</p><blockquote><p>换句话说，命令就是可执行程序，其就是一个被封装好的功能函数。</p></blockquote><br><p>另外，命令行能够直接调用这些可执行程序，是因为它们的绝对路径被声明到环境变量路径中了，这样使得Shell解释器能够找到它们</p><blockquote><p>所以，不管是在Linux，还是Windows中，环境变量都是个重要概念</p></blockquote><br><hr><p>下面主要以 Letter-Shell、RT-Thread FinSH 控制台为例，讲述嵌入式Shell的应用及原理分析</p><h2 id="引出命令行函数原理"><a href="#引出命令行函数原理" class="headerlink" title="引出命令行函数原理"></a>引出命令行函数原理</h2><p>从通俗的角度来说，命令行调用就相当于：用户向设备发送一个指令，这个指令约定好跟一个指定操作有着映射关系，于是设备收到该指令后，去查询并执行其对应映射的操作。</p><p>就 Letter-Shell 为例（其它嵌入式Shell同理），通常移植完成后，其引出命令行的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cmd_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world ! \\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), cmdTest, cmd_test, test cmd);</span><br></pre></td></tr></table></figure><p>如上，当在Shell中输入<code>cmdTest</code>时，程序则会调用执行<code>cmd_test()</code>函数，而<code>test cmd</code>则是命令的说明部分。</p><p>其主要是通过定义<code>SHELL_EXPORT_CMD</code>宏，将函数添加到shell的可执行命令列表中，该宏涉及预处理和链接特性，其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_EXPORT_CMD(_attr, _name, _func, _desc) \\</span></span><br><span class="line"><span class="meta">const char shellCmd##_name[] = #_name; \\</span></span><br><span class="line"><span class="meta">const char shellDesc##_name[] = #_desc; \\</span></span><br><span class="line"><span class="meta">SHELL_USED const ShellCommand \\</span></span><br><span class="line"><span class="meta">shellCommand##_name SHELL_SECTION(\<span class="string">&quot;shellCommand\&quot;) = \\</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123; \\</span></span></span><br><span class="line"><span class="string"><span class="meta">    .attr.value = _attr, \\</span></span></span><br><span class="line"><span class="string"><span class="meta">    .data.cmd.name = shellCmd##_name, \\</span></span></span><br><span class="line"><span class="string"><span class="meta">    .data.cmd.function = (int (*)())_func, \\</span></span></span><br><span class="line"><span class="string"><span class="meta">    .data.cmd.desc = shellDesc##_name \\</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure><p>这个宏接受四个参数：_attr、_name、_func和_desc，分别代表命令的属性、命令名、函数和描述。这个宏的作用是生成一个 ShellCommand 类型的全局变量，这个变量会被放在一个特殊的段（shellCommand）中。</p><p>上述代码详细解释如下：</p><ul><li><code>SHELL_USED</code>即<code>__attribute__((used))</code>，指示编译器不要优化这个变量</li><li><code>SHELL_USED const ShellCommand \\</code>中的<code>ShellCommand</code>是一个结构体（联合体）变量类型，其元素包含命令的属性、命令名、函数指针、或者存放按键键值、用户名、用户密码等等信息</li><li><code>SHELL_SECTION(\&quot;shellCommand\&quot;)</code>即<code>__attribute__((section(shellCommand)))</code>，指示将定义的这个结构体变量声明到这个段中</li></ul><p>另外，<strong>值得注意的是</strong>，其声明的<code>ShellCommand</code>结构体变量类型节选如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">shell_command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> permission : <span class="number">8</span>;                       <span class="comment">/**&lt; command权限 */</span></span><br><span class="line">            ShellCommandType type : <span class="number">4</span>;                          <span class="comment">/**&lt; command类型 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> enableUnchecked : <span class="number">1</span>;                  <span class="comment">/**&lt; 在未校验密码的情况下可用 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> disableReturn : <span class="number">1</span>;                    <span class="comment">/**&lt; 禁用返回值输出 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span>  readOnly : <span class="number">1</span>;                        <span class="comment">/**&lt; 只读 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> reserve : <span class="number">1</span>;                          <span class="comment">/**&lt; 保留 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> paramNum : <span class="number">4</span>;                         <span class="comment">/**&lt; 参数数量 */</span></span><br><span class="line">        &#125; attrs;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">    &#125; attr;                                                     <span class="comment">/**&lt; 属性 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *name;                                   <span class="comment">/**&lt; 命令名 */</span></span><br><span class="line">            <span class="type">int</span> (*function)();                                  <span class="comment">/**&lt; 命令执行函数 */</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *desc;                                   <span class="comment">/**&lt; 命令描述 */</span></span><br><span class="line">        &#125; cmd;                                                  <span class="comment">/**&lt; 命令定义 */</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; data; </span><br><span class="line">&#125; ShellCommand;</span><br></pre></td></tr></table></figure><p>在上述代码中，在声明宏的时候会执行变量初始化有<code>.data.cmd.function = (int (*)())_func</code>，这里以及变量定义中的<code>int (*function)();</code>都是指<strong>声明一个函数指针，此函数接受任意数量和类型的参数，并返回一个整数</strong>。</p><p>但是从 C99 开始，该种声明方式已经被弃用，其有可能会导致<strong>未定义的行为</strong>。因此，在使用 Letter_Shell 时，建议确保编译器的C语言标准为 C89&#x2F;C99&#x2F;GNU89&#x2F;GNU99 均可。如在 GCC 开发环境中添加编译选项<code>-std=gnu99</code>。</p><br><p>在链接阶段，链接器会将同一段中的所有变量放在一起，形成一个数组。这样，Shell就可以通过遍历这个数组来获取所有的命令，如下：</p><p>不同的编译器特性不一样，但程序都是通过获取<strong>这个段的首末地址</strong>，然后在输入命令时，轮询这个段并执行相应的命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为针对不同编译器，声明外部链接器中给段定义好的 段 的首末地址变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__CC_ARM) || (defined(__ARMCC_VERSION) &amp;&amp; __ARMCC_VERSION &gt;= 6000000)</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> shellCommand$$Base;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> shellCommand$$Limit;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__ICCARM__) || defined(__ICCRX__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> section=<span class="string">&quot;shellCommand&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> _shell_command_start;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> _shell_command_end;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为记录 shellCommand 段的首末地址，并计算出有多少个命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__CC_ARM) || (defined(__ARMCC_VERSION) &amp;&amp; __ARMCC_VERSION &gt;= 6000000)</span></span><br><span class="line">    shell-&gt;commandList.base = (ShellCommand *)(&amp;shellCommand$$Base);</span><br><span class="line">    shell-&gt;commandList.count = ((<span class="type">unsigned</span> <span class="type">int</span>)(&amp;shellCommand$$Limit)</span><br><span class="line">                            - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;shellCommand$$Base))</span><br><span class="line">                            / <span class="keyword">sizeof</span>(ShellCommand);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__ICCARM__) || defined(__ICCRX__)</span></span><br><span class="line">    shell-&gt;commandList.base = (ShellCommand *)(__section_begin(<span class="string">&quot;shellCommand&quot;</span>));</span><br><span class="line">    shell-&gt;commandList.count = ((<span class="type">unsigned</span> <span class="type">int</span>)(__section_end(<span class="string">&quot;shellCommand&quot;</span>))</span><br><span class="line">                            - (<span class="type">unsigned</span> <span class="type">int</span>)(__section_begin(<span class="string">&quot;shellCommand&quot;</span>)))</span><br><span class="line">                            / <span class="keyword">sizeof</span>(ShellCommand);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__GNUC__)</span></span><br><span class="line">    shell-&gt;commandList.base = (ShellCommand *)(&amp;_shell_command_start);</span><br><span class="line">    shell-&gt;commandList.count = ((<span class="type">unsigned</span> <span class="type">int</span>)(&amp;_shell_command_end)</span><br><span class="line">                            - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;_shell_command_start))</span><br><span class="line">                            / <span class="keyword">sizeof</span>(ShellCommand);</span><br></pre></td></tr></table></figure><p>其中，如果是在GCC编译环境下，那么需要在链接脚本中加入以下代码，以使得C源程序能够获取<code>ShellCommand</code>的首末地址，不然程序编译会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.rodata :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">  *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">_shell_command_start = .;</span><br><span class="line">KEEP (*(shellCommand))</span><br><span class="line">_shell_command_end = .;</span><br><span class="line">&#125; &gt;FLASH</span><br></pre></td></tr></table></figure><p>综上所述，引出命令行的原理是：<strong>通过一个宏，定义一个全局结构体变量（其包含要引出的命令函数及其相关属性信息），并将该变量声明到一个指定的段中。Shell在接受外界命令时，会轮询这个段内的所有结构体变量，找到对应的命令函数指针并执行调用。</strong></p><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellTaskPoll</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">shellTask((<span class="type">void</span> *)&amp;shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为在移植 Letter_Shell 组件，需要添加的核心轮询函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellTask</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    Shell *shell = (Shell *)param;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_TASK_WHILE == 1</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (shell-&gt;read &amp;&amp; shell-&gt;read(&amp;data, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shellHandler(shell, data);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_TASK_WHILE == 1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在每次读取到终端的一个字节数据，而后都会调用到<code>shellHandler</code>函数，<code>shellHandler</code>函数的主要执行如下：</p><ul><li>首先将字节与键值表查看是否匹配，如果匹配，则执行相应的键值处理函数。比如检测匹配收到了一个回车键，则会执行相应的回车处理函数<code>shellEnter</code></li><li>如果字节与键值都不匹配，则认为是正常输入字符，从而调用<code>shellNormalInput</code>函数，将字符数据记录到 buffer 中，并调用<code>shell-&gt;write</code>即<code>userShellWrite</code>函数将输入的字符回显到终端上</li><li>其中也插有各种附带的功能，比如权限检查的条件判断等等，此处不讲述</li></ul><p>在 Letter_Shell 中，其对所有的命令行函数解析，都会记录下<code>argc</code>和<code>argv[]</code>，最终在调用时，才会根据先前宏定义声明的函数类型进行 函数指针 + 参数 的强制指向调用</p><h3 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h3><p><code>Letter_Shell</code>在轮询收到回车键时，会调用回车键值处理函数<code>shellEnter</code> -&gt; 调用<code>shellExec()</code>运行命令函数（先检查密码是否已验证） -&gt; 调用<code>shellSeekCommand</code>匹配命令 -&gt; 匹配非空，且权限检查通过 -&gt; 则调用<code>shellRunCommand()</code>根据不同的类型执行相应的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell匹配命令</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param shell shell对象</span></span><br><span class="line"><span class="comment"> * @param cmd 命令</span></span><br><span class="line"><span class="comment"> * @param base 匹配命令表基址</span></span><br><span class="line"><span class="comment"> * @param compareLength 匹配字符串长度</span></span><br><span class="line"><span class="comment"> * @return ShellCommand* 匹配到的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ShellCommand* <span class="title function_">shellSeekCommand</span><span class="params">(Shell *shell,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">char</span> *cmd,</span></span><br><span class="line"><span class="params">                               ShellCommand *base,</span></span><br><span class="line"><span class="params">                               <span class="type">unsigned</span> <span class="type">short</span> compareLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> count = shell-&gt;commandList.count -</span><br><span class="line">        ((<span class="type">int</span>)base - (<span class="type">int</span>)shell-&gt;commandList.base) / <span class="keyword">sizeof</span>(ShellCommand);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base[i].attr.attrs.type == SHELL_TYPE_KEY</span><br><span class="line">            || shellCheckPermission(shell, &amp;base[i]) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        name = shellGetCommandName(&amp;base[i]);</span><br><span class="line">        <span class="keyword">if</span> (!compareLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, name) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;base[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, name, compareLength) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;base[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-类型函数"><a href="#main-类型函数" class="headerlink" title="main 类型函数"></a>main 类型函数</h4><p>用户在终端输入命令执行时，shell通过识别<code>空格键</code>、<code>回车键</code>，累计计算得出函数的入参个数，存放至<code>shell-&gt;parser.paramCount</code>，将入参以字符串的形式存放于二级指针数组中，最终调用<code>main</code>类型函数时将参数个数以及参数二级指针作为入参。</p><p>如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (command-&gt;attr.attrs.type == SHELL_TYPE_CMD_MAIN)</span><br><span class="line">&#123;</span><br><span class="line">    shellRemoveParamQuotes(shell);</span><br><span class="line">    returnValue = command-&gt;data.cmd.function(shell-&gt;parser.paramCount,</span><br><span class="line">                                             shell-&gt;parser.param);</span><br><span class="line">    <span class="keyword">if</span> (!command-&gt;attr.attrs.disableReturn)</span><br><span class="line">    &#123;</span><br><span class="line">        shellWriteReturnValue(shell, returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shellExtRun</span><span class="params">(Shell *shell, ShellCommand *command, <span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> params[SHELL_PARAMETER_MAX_NUMBER] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> paramNum = command-&gt;attr.attrs.paramNum &gt; (argc - <span class="number">1</span>) ? </span><br><span class="line">        command-&gt;attr.attrs.paramNum : (argc - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        params[i] = shellExtParsePara(shell, argv[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (paramNum)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_PARAMETER_MAX_NUMBER &gt;= 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> command-&gt;data.cmd.function();</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/** SHELL_PARAMETER_MAX_NUMBER &gt;= 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_PARAMETER_MAX_NUMBER &gt;= 2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> command-&gt;data.cmd.function(params[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/** SHELL_PARAMETER_MAX_NUMBER &gt;= 2 */</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="键值的匹配与引出"><a href="#键值的匹配与引出" class="headerlink" title="键值的匹配与引出"></a>键值的匹配与引出</h2><p>通过宏定义<code>SHELL_EXPORT_KEY</code>引出</p><p>其中一些按键如：退格、回车、左右方向，是声明了不用权限检查的，即是不用通过密码通过或者等级检查等等，也能直接调用相关键值执行函数。（因为输入密码时也需要用到这些键值，，这里扯多了）</p><p>而一些按键如：Tab，是需要权限检查的；当密码尚未验证时，输入这个键，会提示请输入密码相关信息</p><h2 id="Shell-附加功能"><a href="#Shell-附加功能" class="headerlink" title="Shell 附加功能"></a>Shell 附加功能</h2><h3 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h3><p>用户通过宏定义设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief shell默认用户密码</span><br><span class="line"> *        若默认用户不需要密码，设为&quot;&quot;</span><br><span class="line"> */</span><br><span class="line">#define     SHELL_DEFAULT_USER_PASSWORD &quot;&quot;</span><br></pre></td></tr></table></figure><p>程序在初始化时会设置值<code>shell-&gt;status.isChecked</code>，如果定义了密码字符，则定义其值为 1。执行流为：<code>shellInit</code> -&gt; <code>shellSetUser</code> -&gt; <code>shell-&gt;status.isChecked</code></p><p>而后，Shell在每次的字符输入和命令执行时，都会检查这个<code>shell-&gt;status.isChecked</code>值</p><h3 id="实时操作系统下获取当前线程运行状态"><a href="#实时操作系统下获取当前线程运行状态" class="headerlink" title="实时操作系统下获取当前线程运行状态"></a>实时操作系统下获取当前线程运行状态</h3><p>这个没啥好说的，实时系统自己针对Shell内置的一些命令罢了。</p><p>每个线程都有自己的句柄，其记录下线程状态的各个标记位，或者各种信息，可以通过命令行函数展示打印出来</p><h3 id="线程栈最大使用率"><a href="#线程栈最大使用率" class="headerlink" title="线程栈最大使用率"></a>线程栈最大使用率</h3><p>主要原理为：在线程初始化时，将线程栈（即一个静态数组）全部初始化为一个特定的字节，比如 1。在查看最大使用率时，从栈底往栈顶方向计数，算出字节 1 的数量占整个栈大小的比例，将 100% 减去这个比例即是最大使用率</p><h3 id="CPU空闲率"><a href="#CPU空闲率" class="headerlink" title="CPU空闲率"></a>CPU空闲率</h3><p>需要上实时操作系统才能支持，通过计算单元时间内 空闲任务的运行时间占比即可</p><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>颜色的标准配置</p><p>日志等级</p><h2 id="Shell-移植适配"><a href="#Shell-移植适配" class="headerlink" title="Shell 移植适配"></a>Shell 移植适配</h2><p>此处不过多赘述</p><h2 id="注意项及疑惑解答"><a href="#注意项及疑惑解答" class="headerlink" title="注意项及疑惑解答"></a>注意项及疑惑解答</h2><h3 id="实际应用中避免串口回环，导致函数陷入死循环"><a href="#实际应用中避免串口回环，导致函数陷入死循环" class="headerlink" title="实际应用中避免串口回环，导致函数陷入死循环"></a>实际应用中避免串口回环，导致函数陷入死循环</h3><p>如使用串口作为终端，则要考虑到串口 tx、rx 可能的短接导致的问题</p><h3 id="声明的命令行函数接受任何类型的参数并返回int型"><a href="#声明的命令行函数接受任何类型的参数并返回int型" class="headerlink" title="声明的命令行函数接受任何类型的参数并返回int型"></a>声明的命令行函数接受任何类型的参数并返回int型</h3><p>在 Letter_Shell 中，其使用的仍然是旧式声明，（如<code>int foo();</code>）</p><p>此旧式声明只是阻止编译器检查参数类型和数量，但假如传入的参数不符合函数定义中的要求，则导致未定义行为</p><p>旧式的声明&#x2F;定义已经在新的 C2x 标准草案中被移除了。此后，<code>int foo(); </code>等价于 <code>int foo(void);</code> 。</p><h3 id="按键键值匹配设置"><a href="#按键键值匹配设置" class="headerlink" title="按键键值匹配设置"></a>按键键值匹配设置</h3><p>换行，tab等标准功能 参照Shell</p><p>串口软件之按键键值映射，参照SecureCRT</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://github.com/NevermindZZT/letter-shell/blob/master/README.md">letter shell 3.x</a></li><li><a href="https://zhuanlan.zhihu.com/p/128960695">letter-shell | 一个功能强大的嵌入式shell</a></li><li><a href="https://blog.csdn.net/jisuanji111111/article/details/126719491">C基础 – SHELL_EXPORT_CMD(_attr, _name, _func, _desc)宏注册函数详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Harmony】OpenHarmony轻量系统--XTS子系统编译适配及测试</title>
      <link href="/2024/02/02/%E3%80%90Harmony%E3%80%91OpenHarmony%E8%BD%BB%E9%87%8F%E7%B3%BB%E7%BB%9F-XTS%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E9%80%82%E9%85%8D%E5%8F%8A%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/02/02/%E3%80%90Harmony%E3%80%91OpenHarmony%E8%BD%BB%E9%87%8F%E7%B3%BB%E7%BB%9F-XTS%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E9%80%82%E9%85%8D%E5%8F%8A%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<br><p>本文内容为<strong>本人在移植国民技术N32G452适配OpenHarmony轻量系统的过程中，以添油方式仓促写就，其中或有不少相互矛盾或有失偏颇之处，但对于初入此道之开发者应能有一定的启迪作用。</strong></p><p><a href="https://github.com/Jindu-Chen/OpenHarmony_Adaptation_Pack">国民技术-OpenHarmony轻量系统适配源码包</a></p><hr><h2 id="轻量系统应用兼容性测试适配"><a href="#轻量系统应用兼容性测试适配" class="headerlink" title="轻量系统应用兼容性测试适配"></a>轻量系统应用兼容性测试适配</h2><ul><li><p>前提：基于OpenHarmony-V4.0-Release全量代码仓</p></li><li><p>在vendor目录下产品的config.json文件中，添加XTS子系统组件定义</p></li><li><p><a href="https://www.openharmony.cn/certification/document/guid">兼容性测评官网</a></p></li></ul><h3 id="如何添加XTS子系统"><a href="#如何添加XTS子系统" class="headerlink" title="如何添加XTS子系统"></a>如何添加XTS子系统</h3><p>执行编译XTS组件的指令不唯一，取决于gn构建文件内的私有工程设置</p><ul><li>通常为：<code>hb build -f -b debug --gn-args build_xts=true</code>，build_xts是一个变量，如果使能了该变量，则会增加相关的编译部分。另外在用户私有的BUILD.gn文件里，也有该变量的相关依赖部分。<code>--gn-args</code>用于传递构建参数至GN构建系统</li><li><code>hb build -b debug</code>，执行此条指令生成调试版本镜像，与 XTS 编译无关</li></ul><p>就本人目前理解而言，要添加XTS子系统，前期需要实现的几点工作如下：</p><ul><li>首先完成基于私有开发板的 OpenHarmony 工程移植适配工作，使得基于内核子系统的最简工程可以运行</li><li>而后建议在<code>target_config.h</code>添加启动shell功能配置，同时完成串口外设调试终端的移植适配，<code>hb build</code>，并烧录须测试验证ok。当然期间内必存在各种各样的编译报错，包括依赖关系不全、代码工程的不适配等</li><li>添加各项子系统并使其构建成功，如启动恢复子系统、DFX子系统，等等，</li><li>最后添加XTS子系统配置及其依赖，当然测试套件的静态库文件相当大，可以分批测试并保存测试结果，每次链接一部分库进行测试<ul><li>一般在<code>//device/board/xxx/xxx/BUILD.gn</code>文件里的 <code>if(build_xts=true)</code>选项卡内添加相关的链接选项，其中<code>hctest、sysparam、bootstrap</code>等静态库是必须的，在添加XTS子系统之前，应完成相关部分部件的编写编译构建与测试，此部分是测试框架基石</li></ul></li></ul><br><p><strong>添加编译XTS子系需要执行的步骤：</strong></p><ul><li>在工程配置<code>target_config.h</code>宏定义中使能Test测试项<ul><li>使得系统启动初始化时会进行相关函数调用</li></ul></li><li>在<code>//kernel/liteos_m</code>中make menuconfig中，使能测试相关配置 – 实际上为配置<code>//vendor/xxx/kernel_configs/debug.config</code>选项</li><li>在<code>//vendor/xxx/config.json</code>添加合适的子系统配置<ul><li>补全文件末尾的<code>third_patry</code>和<code>product_adapt_dir</code></li></ul></li><li>在<code>//device/board/xxx/liteos_m/config.gni</code>添加适配的头文件路径<ul><li>链接选项中增添合适的静态库链接，以实现链接测试用例相关库，其中测试静态库文件生成于<code>//out/$&#123;company&#125;//$&#123;product&#125;//libs</code></li><li>还须添加源文件路径？</li></ul></li><li>在<code>//device/board/xxx/xxx.ld</code>链接脚本中<strong>添加OpenHarmony特有的测试段</strong></li></ul><h3 id="XTS子系统编译流程"><a href="#XTS子系统编译流程" class="headerlink" title="XTS子系统编译流程"></a>XTS子系统编译流程</h3><ul><li>通过hb工具读取系统配置文件(即vendor目录下产品的config.json)，获取参与编译的子系统以及部件信息</li><li>通过gn工具会读取XTS子系统BUILD.gn–all_features会读取轻量系统全部acts测试套件<ul><li>判断是否debug版本<code>if (ohos_build_type == &quot;debug&quot; &amp;&amp; ohos_test_args != &quot;notest&quot;) </code>，非debug版本XTS不参与编译</li></ul></li><li>将轻量系统全部acts测试套件与产品的config.json子系统组件对比，存在的子系统部件参与最终编译</li><li>最终生成静态库.a归档路径：<code>out/.../.../libs</code><ul><li>XTS子系统: libmodule_xxx.a，测试框架：libhctest.a</li></ul></li><li>.a库链接操作</li></ul><h2 id="XTS子系统兼容性测评"><a href="#XTS子系统兼容性测评" class="headerlink" title="XTS子系统兼容性测评"></a>XTS子系统兼容性测评</h2><h3 id="规范编码以通过兼容性测试"><a href="#规范编码以通过兼容性测试" class="headerlink" title="规范编码以通过兼容性测试"></a>规范编码以通过兼容性测试</h3><ul><li><p>遵循 OpenHarmony 的开发规范。OpenHarmony 提供了完善的开发规范，包括代码风格、命名规范、注释规范等</p></li><li><p>使用 OpenHarmony 的标准 API</p></li></ul><h3 id="XTS子系统测试项"><a href="#XTS子系统测试项" class="headerlink" title="XTS子系统测试项"></a>XTS子系统测试项</h3><p>轻量系统的全部测试项包含有：应用管理(Ability和Bundle)、网络通信(LwIP)、文件系统、系统参数、Wi-Fi IOT、分布式数据管理、安全、日志、事件、分布式调度、系统更新、系统引导</p><h3 id="XTS测试库链接报错问题"><a href="#XTS测试库链接报错问题" class="headerlink" title="XTS测试库链接报错问题"></a>XTS测试库链接报错问题</h3><p>不同的 OpenHarmony 发布版本，其所要求的测试模块及套件有所区别，通常情况下链接相应的测试库，报错是因为没有在<code>vendor/xxx/xxx/config.json</code>配置好相应的模块和组件、部件，导致工程找不到相应的函数实现</p><p>另外，用户也需要添加自己的工程对模块组件的适配</p><h4 id="module-ActsUpdaterFuncTest-编译链接错误"><a href="#module-ActsUpdaterFuncTest-编译链接错误" class="headerlink" title="module_ActsUpdaterFuncTest 编译链接错误"></a>module_ActsUpdaterFuncTest 编译链接错误</h4><p>更新功能测试库链接报错信息节选如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">reference to `HotaWrite&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: ota_func_test.c:(.text.subUpgradeAPI1000_runTest+0x64): undefined reference to `HotaCancel&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsUpdaterFuncTest.a(libmodule_ActsUpdaterFuncTest.ota_func_test.o): in function `subUpgradeAPI1200_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] ota_func_test.c:(.text.subUpgradeAPI1200_runTest+0xe): undefined reference to `HotaCancel&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsUpdaterFuncTest.a(libmodule_ActsUpdaterFuncTest.ota_func_test.o): in function `subUpgradeAPI1100_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] ota_func_test.c:(.text.subUpgradeAPI1100_runTest+0x14): undefined reference to `HotaGetUpdateIndex&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: ota_func_test.c:(.text.subUpgradeAPI1100_runTest+0x24): undefined reference to `HotaSetPackageType&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: ota_func_test.c:(.text.subUpgradeAPI1100_runTest+0x46): undefined reference to `HotaWrite&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: ota_func_test.c:(.text.subUpgradeAPI1100_runTest+0x64): undefined reference to `HotaRead&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: ota_func_test.c:(.text.subUpgradeAPI1100_runTest+0x84): undefined reference to `HotaCancel&#x27;</span><br><span class="line">[OHOS ERROR] collect2: error: ld returned 1 exit status</span><br><span class="line">[OHOS ERROR] Traceback (most recent call last):</span><br></pre></td></tr></table></figure><p>其中，<code>HotaWrite</code>、<code>HotaRead</code>等函数实现位于文件<code>//base/update/sys_installer_lite/frameworks/source/updater/hota_updater.c</code>中。</p><p>经过分析，导致编译报错的原因有如下：</p><ul><li>用户私有板的相关配置不正确，比如缺少头文件包含、或者库文件包含、或者没有指定生成相应子系统的组件部件</li><li>OpenHarmony V4.0 轻量系统源码工程在此方面的XTS子系统测试并未完善</li></ul><p>而在细节测试，应用 Hi3861 芯片工程编译正常，但使用 <code>//vendor/xxx</code>一些其它例程，则也是 XTS 编译不通过</p><h4 id="module-ActsHuksHalFunctionTest-编译链接错误"><a href="#module-ActsHuksHalFunctionTest-编译链接错误" class="headerlink" title="module_ActsHuksHalFunctionTest 编译链接错误"></a>module_ActsHuksHalFunctionTest 编译链接错误</h4><p>环境硬件抽象层功能测试</p><p>在库链接选项里增添<code>&quot;-lhuks_test_common&quot;,</code>即可编译链接成功</p><h4 id="module-ActsSamgrTest-运行报错堆栈溢出"><a href="#module-ActsSamgrTest-运行报错堆栈溢出" class="headerlink" title="module_ActsSamgrTest 运行报错堆栈溢出"></a>module_ActsSamgrTest 运行报错堆栈溢出</h4><p>服务管理测试运行错误</p><p>可能是轻量系统的堆内存默认设置的 60K 过小</p><h4 id="module-ActsBundleMgrTest-编译链接错误"><a href="#module-ActsBundleMgrTest-编译链接错误" class="headerlink" title="module_ActsBundleMgrTest 编译链接错误"></a>module_ActsBundleMgrTest 编译链接错误</h4><p>包管理测试库编译报错节选如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testSetElementDeviceIDIllegal_runTest+0x84): undefined reference to `ClearWant&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsBundleMgrTest.a(libmodule_ActsBundleMgrTest.bundle_mgr_test.o): in function `testGetBundleInfoIllegal_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] bundle_mgr_test.c:(.text.testGetBundleInfoIllegal_runTest+0x28): undefined reference to `GetBundleInfo&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testGetBundleInfoIllegal_runTest+0x36): undefined reference to `GetBundleInfo&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testGetBundleInfoIllegal_runTest+0x4e): undefined reference to `GetBundleInfo&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testGetBundleInfoIllegal_runTest+0x5c): undefined reference to `GetBundleInfo&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsBundleMgrTest.a(libmodule_ActsBundleMgrTest.bundle_mgr_test.o): in function `testGetBundleInfosIllegal_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] bundle_mgr_test.c:(.text.testGetBundleInfosIllegal_runTest+0x1c): undefined reference to `GetBundleInfos&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testGetBundleInfosIllegal_runTest+0x2a): undefined reference to `GetBundleInfos&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: bundle_mgr_test.c:(.text.testGetBundleInfosIllegal_runTest+0x42): undefined reference to `GetBundleInfos&#x27;</span><br><span class="line">[OHOS ERROR] collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>其中，<code>SetElementDeviceID</code>、<code>ClearElement</code>等函数实现位于文件<code>foundation/bundlemanager/bundle_framework_lite/frameworks/bundle_lite/src/element_name.cpp</code>中</p><p>另外，提示在文件<code>test/xts/acts/appexecfwk_lite/appexecfwk_hal/src/bundle_mgr_test.c</code>中的<code>testGetBundleInfoIllegal_runTest</code>函数中找不到<code>GetBundleInfo</code>以及其它的一些函数实现</p><h4 id="module-ActsDeviceAttestTest-编译链接错误"><a href="#module-ActsDeviceAttestTest-编译链接错误" class="headerlink" title="module_ActsDeviceAttestTest 编译链接错误"></a>module_ActsDeviceAttestTest 编译链接错误</h4><p>设备认证测试模块编译链接报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsDeviceAttestTest.a(libmodule_ActsDeviceAttestTest.device_attest.o): in function `subDeviceAttest0100_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] device_attest.c:(.text.subDeviceAttest0100_runTest+0xe): undefined reference to `StartDevAttestTask&#x27;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libmodule_ActsDeviceAttestTest.a(libmodule_ActsDeviceAttestTest.device_attest.o): in function `subDeviceAttest0200_runTest&#x27;:</span><br><span class="line">[OHOS ERROR] device_attest.c:(.text.subDeviceAttest0200_runTest+0x1c): undefined reference to `GetAttestStatus&#x27;</span><br><span class="line">[OHOS ERROR] collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>其中，<code>StartDevAttestTask</code>、<code>GetAttestStatus</code>函数实现位于文件<code>test/xts/device_attest_lite/framework/mini/src/attest_framework_client_mini.c</code>中</p><h3 id="XTS子系统的兼容性测试用例适配开发"><a href="#XTS子系统的兼容性测试用例适配开发" class="headerlink" title="XTS子系统的兼容性测试用例适配开发"></a>XTS子系统的兼容性测试用例适配开发</h3><p>针对以上编译报错，可以通过自己编写相关的缺失函数实现通过编译测试</p><p>例如 UtilsFile 文件测试函数，需要编写能够符合测试用例（或者说符合API规范）的函数，例：当调用API删除不存在的文件时，函数应能返回异常</p><h2 id="OpenHarmony轻量系统认证流程"><a href="#OpenHarmony轻量系统认证流程" class="headerlink" title="OpenHarmony轻量系统认证流程"></a>OpenHarmony轻量系统认证流程</h2><p>准备烧录镜像、相关指导文档、XTS自测串口打印报告、PCS自检表、寄送样品及工具</p><p>通常情况下，由于芯片内存大小有限，无法一次性将所有的 XTS 测试用例库链接进程序中</p><p>因此，主要采用分批烧录、验证串口打印信息的方式，每一个测试模块都对应一个烧录镜像文件</p><p>另外，需要提供相关烧录工具以及指导文件</p><ul><li>如果是通过烧录口直接烧录的方式，那么寄送的样品可以把线路板暴露出来</li><li>当然，也可以通过 IAP 在应用编程方式，或者空中升级方式，只要能够达到目标即可</li></ul><h3 id="兼容性认证测评申报"><a href="#兼容性认证测评申报" class="headerlink" title="兼容性认证测评申报"></a>兼容性认证测评申报</h3><p>在兼容性平台上提请设备申报，包括有如下项：</p><p><strong>产品定义：</strong> 需要明确所应用操作系统的发布版本、设备版本号、芯片型号（此类型信息须与源码上填写保持一致）</p><p><strong>报告上传：</strong> 需要上传各个测试套的镜像文件、烧录以及测试指导文档、XTS自测导出的串口日志txt报告（每个测试模块对应一个txt文件），此外，软件版本号、安全补丁标签、版本ID、版本Hash须与测试模块中所打印日志保持一致</p><p><strong>样机寄送：</strong> 安排样机寄送</p><h3 id="兼容性认证测评驳回以及补充事项"><a href="#兼容性认证测评驳回以及补充事项" class="headerlink" title="兼容性认证测评驳回以及补充事项"></a>兼容性认证测评驳回以及补充事项</h3><h2 id="XTS子系统源码分析"><a href="#XTS子系统源码分析" class="headerlink" title="XTS子系统源码分析"></a>XTS子系统源码分析</h2><h3 id="XTS子系统软件工作流程"><a href="#XTS子系统软件工作流程" class="headerlink" title="XTS子系统软件工作流程"></a>XTS子系统软件工作流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LITE_TEST_CASE(IntTestSuite, TestCase001, Level0) </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="XTS子系统的疑惑解答"><a href="#XTS子系统的疑惑解答" class="headerlink" title="XTS子系统的疑惑解答"></a>XTS子系统的疑惑解答</h2><h3 id="相对于不同架构的工程，其XTS子系统源码是否也要更改？"><a href="#相对于不同架构的工程，其XTS子系统源码是否也要更改？" class="headerlink" title="相对于不同架构的工程，其XTS子系统源码是否也要更改？"></a>相对于不同架构的工程，其XTS子系统源码是否也要更改？</h3><h3 id="相对新移植的工程，是直接复制现有的XTS源码，还是要开发者基于移植工程、按照规范编写相关程序？"><a href="#相对新移植的工程，是直接复制现有的XTS源码，还是要开发者基于移植工程、按照规范编写相关程序？" class="headerlink" title="相对新移植的工程，是直接复制现有的XTS源码，还是要开发者基于移植工程、按照规范编写相关程序？"></a>相对新移植的工程，是直接复制现有的XTS源码，还是要开发者基于移植工程、按照规范编写相关程序？</h3><h3 id="在更换不同版本如-3-2-4-0-系统时，需要在哪些地方更改？更改哪些内容？"><a href="#在更换不同版本如-3-2-4-0-系统时，需要在哪些地方更改？更改哪些内容？" class="headerlink" title="在更换不同版本如 3.2 -&gt; 4.0 系统时，需要在哪些地方更改？更改哪些内容？"></a>在更换不同版本如 3.2 -&gt; 4.0 系统时，需要在哪些地方更改？更改哪些内容？</h3><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/Via6666/article/details/132093613">OpenHarmony L0级设备XTS适配经验分享</a></li><li><a href="https://bbs.huaweicloud.com/blogs/336717">移植案例与原理 - XTS子系统之应用兼容性测试套件</a></li><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/porting-stm32f407-on-minisystem-eth.md">轻量系统STM32F407芯片移植案例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenHarmony </category>
          
          <category> LiteOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】嵌入式单片机移植CmBacktrace</title>
      <link href="/2024/02/01/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E7%A7%BB%E6%A4%8DCmBacktrace/"/>
      <url>/2024/02/01/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E7%A7%BB%E6%A4%8DCmBacktrace/</url>
      
        <content type="html"><![CDATA[<p>工程源码移植见：<a href="https://github.com/Jindu-Chen/CmBacktrace_Adapt">CmBacktrace源码移植教程-github</a></p><p>官方源码地址 : <a href="https://github.com/armink/CmBacktrace">https://github.com/armink/CmBacktrace</a></p><p><strong>未完待续…</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>暂略</p><h2 id="移植适配与应用"><a href="#移植适配与应用" class="headerlink" title="移植适配与应用"></a>移植适配与应用</h2><ul><li><p>将相关源码加入工程</p></li><li><p>适配信息打印接口，如串口，将<code>printf</code>输出重定向至串口</p></li><li><p>注释掉原有的HardFault中断服务函数，避免与CmBacktrace源码的HardFault中断服务函数冲突</p></li><li><p>链接脚本中也要增加适配其宏定义（如果没有的话），如栈的起始结束地址<code>_bss</code>、代码段<code>__text_end</code>的起始结束地址等</p></li><li><p>在程序初始化时，调用CmBacktrace的初始化接口</p></li></ul><h3 id="程序报错及解析"><a href="#程序报错及解析" class="headerlink" title="程序报错及解析"></a>程序报错及解析</h3><p>当程序运行错误时，CmBacktrace会轮询栈空间，将其中指向的内容（为falsh代码段区间的函数地址部分）打印出来，此即函数地址调用链。</p><p>用户使用 addr2line 工具，配合 elf 文件，将函数地址转换为函数名，则可知函数调用链。</p><p>如：<code>addr2line -e app.elf -a -f 080154c2 0800a3b2 08009092</code></p><h3 id="addrline2工具"><a href="#addrline2工具" class="headerlink" title="addrline2工具"></a>addrline2工具</h3><p><code>addr2line</code> 是一个用于将程序地址转换为源代码文件名及行号的工具，其属于<code>GNU Binutils</code>工具包中的一部分。</p><blockquote><p><code>GNU Binutils</code>是GNU项目的一部分，是一套用于创建、修改和分析二进制文件的工具集合。其包括：汇编器（as）、链接器（ld）、反汇编器（objdump）、调试器、库管理器、对象查看器、地址转换工具（addr2line）等。<br>如WSL安装了GCC，则会包含整个GNU Binutils工具集。 如安装了<code>arm-none-eabi-</code>工具链，则会包含<code>arm-none-eabi-addr2line</code>。</p></blockquote><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>要理清CmBacktrace的实现原理，首先要<strong>了解<code>ARM Cortex-M</code>内核的堆栈布局与管理、以及该内核对异常的处理流程</strong>。</p><p>而CmBacktrace即是根据C语言的栈帧结构、以及Cortex-M内核的工作&#x2F;异常处理的原理，当触发异常时，对堆栈进行解析实现回溯，而后将信息输出至终端，如串口。</p><p>如何通过cortex-m4内核的cpu寄存器值分析当前的栈帧调用链</p><h3 id="堆栈布局与管理"><a href="#堆栈布局与管理" class="headerlink" title="堆栈布局与管理"></a>堆栈布局与管理</h3><h3 id="异常处理与上下文保存"><a href="#异常处理与上下文保存" class="headerlink" title="异常处理与上下文保存"></a>异常处理与上下文保存</h3><h3 id="CmBacktrace的工作原理"><a href="#CmBacktrace的工作原理" class="headerlink" title="CmBacktrace的工作原理"></a>CmBacktrace的工作原理</h3><p>核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">cm_backtrace_call_stack</span><span class="params">(<span class="type">uint32_t</span> *buffer, <span class="type">size_t</span> size, <span class="type">uint32_t</span> sp)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> stack_start_addr = main_stack_start_addr, pc;</span><br><span class="line">    <span class="type">size_t</span> depth = <span class="number">0</span>, stack_size = main_stack_size;</span><br><span class="line">    <span class="type">bool</span> regs_saved_lr_is_valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy called function address */</span></span><br><span class="line">    <span class="keyword">for</span> (; sp &lt; stack_start_addr + stack_size; sp += <span class="keyword">sizeof</span>(<span class="type">size_t</span>)) &#123;</span><br><span class="line">        <span class="comment">/* the *sp value may be LR, so need decrease a word to PC */</span></span><br><span class="line">        pc = *((<span class="type">uint32_t</span> *) sp) - <span class="keyword">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line">        <span class="comment">/* the Cortex-M using thumb instruction, so the pc must be an odd number */</span></span><br><span class="line">        <span class="keyword">if</span> (pc % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* fix the PC address in thumb mode */</span></span><br><span class="line">        pc = *((<span class="type">uint32_t</span> *) sp) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((pc &gt;= code_start_addr + <span class="keyword">sizeof</span>(<span class="type">size_t</span>)) &amp;&amp; (pc &lt;= code_start_addr + code_size) &amp;&amp; (depth &lt; CMB_CALL_STACK_MAX_DEPTH)</span><br><span class="line">                <span class="comment">/* check the the instruction before PC address is &#x27;BL&#x27; or &#x27;BLX&#x27; */</span></span><br><span class="line">                &amp;&amp; disassembly_ins_is_bl_blx(pc - <span class="keyword">sizeof</span>(<span class="type">size_t</span>)) &amp;&amp; (depth &lt; size)) &#123;</span><br><span class="line">            <span class="comment">/* the second depth function may be already saved, so need ignore repeat */</span></span><br><span class="line">            <span class="keyword">if</span> ((depth == <span class="number">2</span>) &amp;&amp; regs_saved_lr_is_valid &amp;&amp; (pc == buffer[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[depth++] = pc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数传入 栈顶SP 地址，而后主要进入一个循环，从栈顶往栈底回溯，每4个字节读取一次，<strong>如果其存放的数据是属于代码区的</strong>（说明此是一个函数地址，大概率是函数调用链的地址，当然也可能是函数中的一个函数指针），则将其地址存入数组，并继续回溯。</p><h2 id="注意点与扩展思考"><a href="#注意点与扩展思考" class="headerlink" title="注意点与扩展思考"></a>注意点与扩展思考</h2><h3 id="其它如Cortex-A内核如何回溯的？"><a href="#其它如Cortex-A内核如何回溯的？" class="headerlink" title="其它如Cortex-A内核如何回溯的？"></a>其它如Cortex-A内核如何回溯的？</h3><h3 id="RTOS与裸机下的CmBacktrace有何不同？"><a href="#RTOS与裸机下的CmBacktrace有何不同？" class="headerlink" title="RTOS与裸机下的CmBacktrace有何不同？"></a>RTOS与裸机下的CmBacktrace有何不同？</h3><p>裸机：只需关注当前执行流的堆栈跟踪，不需要考虑多线程或任务切换</p><p>RTOS：需要考虑多线程或任务切换，需要考虑线程切换时的堆栈跟踪。要捕获当前运行任务的堆栈回溯信息，还要获取其他任务的堆栈信息。涉及到与 RTOS 内核的API交互，获取当前任务指针、任务堆栈基址、栈顶指针等信息</p><h3 id="程序崩溃跳转至HardFault状态了，为何还能正常控制外设如DMA-UART打印故障信息？"><a href="#程序崩溃跳转至HardFault状态了，为何还能正常控制外设如DMA-UART打印故障信息？" class="headerlink" title="程序崩溃跳转至HardFault状态了，为何还能正常控制外设如DMA-UART打印故障信息？"></a>程序崩溃跳转至HardFault状态了，为何还能正常控制外设如DMA-UART打印故障信息？</h3><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/512902251">STM32上的backtrace原理与分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【硬件】嵌入式硬件--学习笔记</title>
      <link href="/2024/02/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E4%B9%8B%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>/2024/02/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E4%B9%8B%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="/2024/01/01/PCB%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0"><strong>PCB设计前置知识学习笔记</strong></a><br><a href="/2024/01/01/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%99%A8%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%AE%80%E8%BF%B0"><strong>硬件基础器件知识记录</strong></a></p><br><p><strong>未完待续…</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分为PCB设计部分、电路原理图设计部分、IC选型部分</p><h2 id="硬件开发概述"><a href="#硬件开发概述" class="headerlink" title="硬件开发概述"></a>硬件开发概述</h2><p>电路原理图设计（Schematic）</p><p>PCB布局（layout）</p><h2 id="电路原理图设计"><a href="#电路原理图设计" class="headerlink" title="电路原理图设计"></a>电路原理图设计</h2><h3 id="电流检测电路设计"><a href="#电流检测电路设计" class="headerlink" title="电流检测电路设计"></a>电流检测电路设计</h3><h3 id="DCDC电路"><a href="#DCDC电路" class="headerlink" title="DCDC电路"></a>DCDC电路</h3><p>Boost升压电路原理</p><p>Buck</p><p>升降压、稳压电路设计</p><p>DCDC外围电路</p><h3 id="LDO电路"><a href="#LDO电路" class="headerlink" title="LDO电路"></a>LDO电路</h3><h3 id="充电电路设计"><a href="#充电电路设计" class="headerlink" title="充电电路设计"></a>充电电路设计</h3><p>充电时 充电极接到电池正极，同时电池正极又接到负载端，那么设备是用的电池的电还是充电线的电？</p><p>充电器件外围电路</p><p>充满电后，电池有继续参与到充放电循环中吗</p><h3 id="其它电路设计"><a href="#其它电路设计" class="headerlink" title="其它电路设计"></a>其它电路设计</h3><p>按键复位电路</p><p>基本的电路原理</p><p>RC一阶</p><h4 id="交流放大电路"><a href="#交流放大电路" class="headerlink" title="交流放大电路"></a>交流放大电路</h4><p>采用三极管、电容等将交流信号放大，滤掉直流信号</p><h2 id="PCB-Layout设计"><a href="#PCB-Layout设计" class="headerlink" title="PCB Layout设计"></a>PCB Layout设计</h2><h3 id="PCB走线设计"><a href="#PCB走线设计" class="headerlink" title="PCB走线设计"></a>PCB走线设计</h3><p>避免直角走线</p><p>因为当PCB直角走线时，在传输线拐角处的线宽变大，约为正常线宽的1.414 倍。由于线宽改变，导致阻抗变小，产生一定的信号反射。同时，90度拐角处还会产生寄生电容&#x2F;寄生电感和尖端EMI</p><h2 id="PCB设计之基础术语解析"><a href="#PCB设计之基础术语解析" class="headerlink" title="PCB设计之基础术语解析"></a>PCB设计之基础术语解析</h2><h4 id="过孔设计"><a href="#过孔设计" class="headerlink" title="过孔设计"></a>过孔设计</h4><p>Via孔<br>Pad孔：烧录孔，适合排针类</p><p>通孔、埋孔、盲孔<br>盲孔：并非如通孔一般贯穿整个电路板，通常用于空间紧密的布置，节省空间，留出更多空间用于摆放其它器件或者走线，但其工艺价格较通孔高</p><h4 id="测试点设计"><a href="#测试点设计" class="headerlink" title="测试点设计"></a>测试点设计</h4><h3 id="电源规划"><a href="#电源规划" class="headerlink" title="电源规划"></a>电源规划</h3><p>电源规划属于布局设计和布线设计：<br>电源分配网络: 电源分配网络是将电源从电源插座分配到各个元件的网络。电源分配网络的设计应考虑以下因素：</p><p>电源纹波和噪声: 电源纹波和噪声会影响电路的性能。电源分配网络应设计得尽可能减少电源纹波和噪声。<br>电流负载: 电源分配网络应能够承受所有元件的最大电流负载。<br>热量: 电源分配网络会产生热量。电源分配网络应设计得能够散发出足够的热量。<br>去耦: 去耦是指使用电容器将高频噪声从电源线中去除。去耦可以减少电源纹波和噪声，并提高电路的稳定性。</p><p>电源线宽度: 电源线应足够宽，以承载所需的电流。<br>电源线布局: 电源线应远离信号线，以减少电磁干扰 (EMI)。<br>接地: 接地是电源规划的重要组成部分。PCB 应具有专用接地层，连接到所有元件的接地引脚。接地层应在单点连接到电源接地。</p><p>线发烫是由于电源宽度不够</p><h3 id="串扰抑制"><a href="#串扰抑制" class="headerlink" title="串扰抑制"></a>串扰抑制</h3><h3 id="阻抗匹配"><a href="#阻抗匹配" class="headerlink" title="阻抗匹配"></a>阻抗匹配</h3><p>理想的阻抗匹配状态是信号源的输出阻抗与负载阻抗相等，这时信号传输效率最高，几乎没有反射，能量损失最小。</p><p>如电池，输出阻抗主要是欧姆阻抗，反映电池内部的电阻特性。同一电池状态，不同供电电流下，电池电压不一样。可以说这个电压电流比值差，就是输出阻抗。</p><p>阻抗匹配不仅适用于高频信号传输（如微波电路中的传输线），也适用于低频电路，如音频放大器与扬声器之间的连接。</p><p>“反射”指的是当信号遇到阻抗不匹配的界面时，部分能量不能被负载吸收，而是被反射回信号源的现象<br>这种现象类似于光从一种介质进入另一种介质时发生的反射。在电信号传输中，如果信号源的输出阻抗（Source Impedance）与负载阻抗（Load Impedance）不相等，就会在它们的连接点产生阻抗失配，从而引发反射。</p><p><strong>如何匹配阻抗？</strong><br>终端匹配：在信号链路的末端添加一个与传输线阻抗相等的电阻，直接吸收反射信号。</p><h3 id="环路阻抗"><a href="#环路阻抗" class="headerlink" title="环路阻抗"></a>环路阻抗</h3><p>环路阻抗通常指的是在电路中形成闭合回路的阻抗特性，特别是在讨论反馈系统（如放大器的反馈网络）时。<br>它涉及到信号从输出到输入的整个路径上的总阻抗，包括所有元器件（如电阻、电容、电感）的贡献。<br>环路阻抗对系统的稳定性、增益以及频率响应有着直接影响。在反馈放大器设计中，环路增益的计算就需要考虑环路阻抗，以确保系统稳定工作，避免自激振荡。</p><h3 id="电磁兼容性（EMC）"><a href="#电磁兼容性（EMC）" class="headerlink" title="电磁兼容性（EMC）"></a>电磁兼容性（EMC）</h3><h3 id="静电测试（ESD）"><a href="#静电测试（ESD）" class="headerlink" title="静电测试（ESD）"></a>静电测试（ESD）</h3><h2 id="疑惑解答及扩展思考"><a href="#疑惑解答及扩展思考" class="headerlink" title="疑惑解答及扩展思考"></a>疑惑解答及扩展思考</h2><h3 id="MOS管的栅极G和源极S为啥要串100k电阻？"><a href="#MOS管的栅极G和源极S为啥要串100k电阻？" class="headerlink" title="MOS管的栅极G和源极S为啥要串100k电阻？"></a>MOS管的栅极G和源极S为啥要串100k电阻？</h3><p>在无驱动信号时，提供偏置，比如接地偏置等。</p><p>防止静电损伤：MOSFET的栅极非常敏感，容易受到静电放电（ESD）的影响。100kΩ的电阻可以限制流过栅极的瞬时电流，从而提供一定的静电保护</p><p>避免寄生振荡：在<strong>高频率或高速开关</strong>应用，MOSFET的栅极-漏极（Miller电容）可能会引起寄生振荡。100kΩ电阻有助于抑制这些振荡。</p><p>选择100K电阻会提供更慢的开关速度、更强的静电保护、更低的静态电流</p><ul><li>另外，通常从芯片的驱动口到MOSFET（金属-氧化物半导体场效应晶体管）栅极之间串联一个1kΩ电阻（也称为栅极电阻或GATE电阻），其作用包括有：限流保护、防止毛刺等</li></ul><h3 id="EMC测试fail，如何排查？"><a href="#EMC测试fail，如何排查？" class="headerlink" title="EMC测试fail，如何排查？"></a>EMC测试fail，如何排查？</h3><p>首先重点排查可能与软件相关的信号，超过1MHz的都要着重注意，走线过长的也要注意，如时钟线、数据线等信号线等，是否有串电阻以起到如下作用：</p><ul><li>阻抗匹配：串联一个匹配电阻（其值接近传输线的特征阻抗）可以在信号源处或接收端实现阻抗匹配，减少反射</li><li>吸收反射信号：长信号线仍可能因线路特性变化（如接头、分支等）引起微小的反射。在信号线上串联一个小电阻（如终端电阻）可以吸收这些反射回来的微弱信号，减少它们与原信号叠加造成的干扰</li><li>降低信号上升沿速度：快速变化的信号边缘（即上升沿和下降沿）会产生较强的电磁辐射。串联电阻可以稍微降低信号的边沿速率，减少高频成分</li><li>噪声抑制：在信号线上串联电阻可以作为一个简单的低通滤波器，帮助抑制高频噪声，这些噪声往往是EMC问题的主要来源</li></ul><br><p>排查与高频相关的器件，如开关电源、DCDC</p><p>布线设计、信号线与电源线的隔离、地平面的处理是否合理？</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.bilibili.com/video/BV1d4411R74r/?spm_id_from=333.337.search-card.all.click&vd_source=82e85569f7427ac31cbd67ec7206aa00">【Allegro教程】零基础小白快速入门4层板PCB设计</a></li><li><a href="https://mp.weixin.qq.com/s/YeJILgNylGv386t_LCj2zA">PCB为什么不能直角走线？三大理由！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【构建】Kconfig入门、常用语法学习笔记</title>
      <link href="/2024/01/05/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91Kconfig%E5%85%A5%E9%97%A8%E3%80%81%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/05/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91Kconfig%E5%85%A5%E9%97%A8%E3%80%81%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>此文章大部为参考&#x2F;复述整理编写，为私有理解回顾用</strong><br></p><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Kconfig是Linux内核及许多其它系统广泛使用的一款配置管理工具，用于配置选择功能模块的编译与否<br></p><ul><li>Kconfig是脚本语言，用于定义配置选项和配置菜单</li><li>Kconfig文件分布在各级目录下，构成一个分布式的配置数据库</li><li>一般来说，<code>make menuconfig</code>通过make命令执行menuconfig目标，来调用Kconfig生成界面</li></ul><p><strong>其单个配置项基本语法如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config &lt;option-name&gt;                # config：配置选项的名称</span><br><span class="line">        [depends on &lt;expr&gt;]         # depends on：该配置选项依赖的其它配置选项</span><br><span class="line">        [select &lt;expr&gt;]             # select：其下所包含的选择项</span><br><span class="line">        [default &lt;expr&gt;]            # default：该配置选项的默认值</span><br><span class="line">        [prompt &lt;string&gt;]           # prompt：提示信息</span><br><span class="line">        [help &lt;string&gt;]             # help：帮助信息</span><br></pre></td></tr></table></figure><br><p><strong>简单示例如下：</strong> 该Kconfig文件定义了两个配置选项：MY_FEATURE和MY_FEATURE_SUB_OPTION。MY_FEATURE是一个布尔类型的选项，默认值为y。MY_FEATURE_SUB_OPTION是一个布尔类型的选项，依赖于MY_FEATURE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config MY_FEATURE</span><br><span class="line">        bool &quot;My Feature&quot;</span><br><span class="line">        default y</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature.</span><br><span class="line"></span><br><span class="line">config MY_FEATURE_SUB_OPTION</span><br><span class="line">        depends on MY_FEATURE</span><br><span class="line">        bool &quot;My Feature Sub Option&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature sub option.</span><br></pre></td></tr></table></figure><p>在使用make menuconfig命令生成配置界面后，可以看到<strong>以下配置选项</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My Feature [y]</span><br><span class="line">    * My Feature Sub Option [n]</span><br></pre></td></tr></table></figure><p>用户可以选择将MY_FEATURE选项设置为y或n。如果将MY_FEATURE选项设置为y，则会显示MY_FEATURE_SUB_OPTION选项。用户可以选择将MY_FEATURE_SUB_OPTION选项设置为y或n</p><h3 id="Linux内核之make-menuconfig"><a href="#Linux内核之make-menuconfig" class="headerlink" title="Linux内核之make menuconfig"></a>Linux内核之make menuconfig</h3><p>以下部分复述自参考文章<br></p><p><code>menuconfig</code>目标是Linux内核的顶层Makefile中的目标之一，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config_cmd = menuconfig</span><br><span class="line">config_cmd_help = Configure the kernel</span><br></pre></td></tr></table></figure><p>该目标设置指定了<code>make menuconfig</code>命令执行步骤如下：</p><ul><li>调用make命令的config_cmd目标</li><li>config_cmd目标会调用<code>scripts/kconfig/Makefile:mconf</code>命令来生成配置界面</li><li>mconf命令会解析Kconfig文件，并将配置选项显示在配置界面中，mconf代码位于<code>//script/Kconfig/mconf.c</code><blockquote><p>解析Kconfig：.&#x2F;mconf Kconfig<br>生成对话框：init_dialog<br>配置界面：conf</p></blockquote></li></ul><br><p>在<code>make menuconfig</code>之后生成.config文件</p><ul><li>在编译链接时，Makefile会读取.config文件中的内容，从而决定是否编译或者链接相关代码</li><li><strong>此外，系统会将所有的选项以宏的形式保存在Linux内核根目录下的<code>include/generated/autoconf.h</code>文件，此头文件被包含于工程源文件中，用于决定源文件的条件编译选项</strong></li></ul><h2 id="Kconfig常用语法"><a href="#Kconfig常用语法" class="headerlink" title="Kconfig常用语法"></a>Kconfig常用语法</h2><p>在Kconfig文件中，如果配置项名字为<code>XXX</code>，则生成的.config文件中，会展示其变量为CONFIG_XXX</p><ul><li>如果设置了<code>CONFIG_=LINUX</code>，则变量名展示为<code>LINUX_XXX</code></li><li>not set，则表示配置选项未设置或依赖于其他配置选项（此其他选项未设置）</li><li>.config文件如下所示，设置了<code>CONFIG_=LOSCFG</code>，去掉前缀的变量即为Kconfig文件中的配置项名字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOSCFG_DEBUG_TOOLS=y</span><br><span class="line">LOSCFG_MEM_DEBUG=y</span><br><span class="line"># LOSCFG_DRIVERS is not set</span><br></pre></td></tr></table></figure></li></ul><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;test menu&quot;</span><br><span class="line">    config TEST_MENU_A</span><br><span class="line">        tristate &quot;menu test A&quot;</span><br><span class="line"></span><br><span class="line">    config TEST_MENU_B</span><br><span class="line">        bool &quot;menu test B&quot;</span><br><span class="line">        default n                           </span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line">    prompt &quot;The maximal size of fifo&quot;</span><br><span class="line">    default USB_FIFO_512</span><br><span class="line">    </span><br><span class="line">    config USB_FIFO_512</span><br><span class="line">        bool &quot;512&quot;</span><br><span class="line">        </span><br><span class="line">    config USB_FIFO_1024</span><br><span class="line">        bool &quot;1024&quot;</span><br><span class="line">        </span><br><span class="line">    config USB_FIFO_3072</span><br><span class="line">        bool &quot;3072&quot;</span><br><span class="line"></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure><h2 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h2><p>menuconfig XXX和config XXX类似， 唯一不同的是该选项除了能设置y&#x2F;m&#x2F;n外，还可以实现菜单效果(能回车进入该项内部)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menuconfig M</span><br><span class="line">  if M</span><br><span class="line">      config C1</span><br><span class="line">      config C2</span><br><span class="line">  endif</span><br></pre></td></tr></table></figure><hr><p>以下为Kconfig文件示例：其定义了一个名为My Menu的菜单，菜单下包含四个配置选项：MY_FEATURE_1、MY_FEATURE_2、MY_FEATURE_3和MY_FEATURE_4。其中，MY_FEATURE_4依赖于MY_FEATURE_1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;My Menu&quot;</span><br><span class="line"></span><br><span class="line">config MY_FEATURE_1</span><br><span class="line">        bool &quot;My Feature 1&quot;</span><br><span class="line">        default y</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature 1.</span><br><span class="line"></span><br><span class="line">config MY_FEATURE_2</span><br><span class="line">        bool &quot;My Feature 2&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature 2.</span><br><span class="line"></span><br><span class="line">config MY_FEATURE_3</span><br><span class="line">        bool &quot;My Feature 3&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature 3.</span><br><span class="line"></span><br><span class="line">config MY_FEATURE_4</span><br><span class="line">        depends on MY_FEATURE_1</span><br><span class="line">        bool &quot;My Feature 4&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature 4.</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><p>在使用make menuconfig命令生成配置界面后，可以看到以下配置选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">My Menu</span><br><span class="line">    * My Feature 1 [y]</span><br><span class="line">    * My Feature 2 [n]</span><br><span class="line">    * My Feature 3 [n]</span><br><span class="line">    * My Feature 4 [n]</span><br></pre></td></tr></table></figure><p>用户可以选择将菜单下的任意一个配置选项设置为y或n。如果将MY_FEATURE_1选项设置为y，则会显示MY_FEATURE_4选项。用户可以选择将MY_FEATURE_4选项设置为y或n。</p><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="source语句"><a href="#source语句" class="headerlink" title="source语句"></a>source语句</h3><p>source 语句用于读取另一个文件中的 Kconfig 文件</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句：用于根据条件来显示或隐藏配置选项<br></p><p>以下示例，如果CONFIG_CPU_32选项设置为n，则MY_FEATURE选项才会显示在配置界面中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if !CONFIG_CPU_32</span><br><span class="line">        config MY_FEATURE</span><br><span class="line">                bool &quot;My Feature&quot;</span><br><span class="line">                default y</span><br><span class="line">                help</span><br><span class="line">                  This option enables my feature, which is only available on 64-bit CPUs.</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="tristate语句"><a href="#tristate语句" class="headerlink" title="tristate语句"></a>tristate语句</h3><p>用于定义三态配置选项<br></p><p>以下示例，MY_FEATURE选项可以设置为y、n或m</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config MY_FEATURE</span><br><span class="line">        tristate &quot;My Feature&quot;</span><br><span class="line">        default n</span><br><span class="line">        help</span><br><span class="line">          This option enables my feature</span><br></pre></td></tr></table></figure><h2 id="OpenHarmony之Kconfig应用"><a href="#OpenHarmony之Kconfig应用" class="headerlink" title="OpenHarmony之Kconfig应用"></a>OpenHarmony之Kconfig应用</h2><p>在OpenHarmony轻量系统的编译链接配置过程中，有如下应用：</p><ul><li>用户在<code>//kernel/liteos_m/</code>目录下<code>make menuconfig</code>，结果生成于<code>//vendor/$&#123;company&#125;/$&#123;company_product&#125;/kernel_configs/debug.config</code>文件中（前提是先创建该文件）</li><li>而此debug.config文件的宏配置会公开可见于整个GN构建工程，使得系统可以进行选择性的条件编译链接</li><li>另外，会有mkconfig.sh脚本将此配置文件转化为C语言的宏定义，写入<code>los_config.h</code>文件，此效果等同于在<code>target_config.h</code>文件声明配置相关宏定义</li></ul><h2 id="注意项及疑惑解答"><a href="#注意项及疑惑解答" class="headerlink" title="注意项及疑惑解答"></a>注意项及疑惑解答</h2><ul><li>一定是生成.config文件吗，这个文件名是否可改</li><li>.config文件的配置是如何导入到C源文件的宏定义的</li><li>Kconfig.xx.xx文件类型</li><li>如何构建</li><li>.json文件的用法，其属性与Kconfig的联系？</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/517418914">menuconfig 和、Kconfig 介绍及例子解析！</a></li><li><a href="https://www.cnblogs.com/hellokitty2/p/7587251.html">Make menuconfig生成文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LiteOS </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【构建】常用编译/链接选项说明及其应用分析</title>
      <link href="/2024/01/02/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9%E6%84%8F%E4%B9%89%E8%A7%A3%E9%87%8A/"/>
      <url>/2024/01/02/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9%E6%84%8F%E4%B9%89%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="GCC编译选项CFLAGS参数及说明"><a href="#GCC编译选项CFLAGS参数及说明" class="headerlink" title="GCC编译选项CFLAGS参数及说明"></a>GCC编译选项CFLAGS参数及说明</h2><ul><li><p><strong><code>-ffunction-sections</code></strong> : 告知编译器将每个函数放置在单独的小节中，与<code>-Wl,--gc-sections</code>搭配使用。使得可以在链接过程中只保留实际使用到的函数，未用到的函数将不会被链接，大大缩减生成可执行文件的大小</p></li><li><p><strong><code>-fdata-sections</code></strong> : 标准的编译选项，与-ffunction-sections类似，告知编译器将全局和静态变量放置在单独的小节中。</p></li><li><p><strong><code>--data-sections</code></strong> : 扩展的编译选项，只能在特定的编译器中使用，如GCC。</p></li><li><p><strong><code>-std=gnu99 -mabi=aapcs</code></strong> : 指定使用C语言的GNU 99标准，-mabi&#x3D;aapcs指定使用ARM架构的AAPCS（ARM Architecture Procedure Call Standard）ABI。</p><blockquote><p>指定编译器的C语言标准是有必要的，同时开发者需要明确的程序代码是否与编程标准兼容<br>在Linux下输入<code>arm-none-eabi-gcc -E -dM - &lt;/dev/null | grep &quot;STDC_VERSION&quot;</code>查看编译器默认支持的C语言标准</p></blockquote></li><li><p><strong><code>-munaligned-access</code></strong> ：是汇编语言的编译选项，告诉汇编器为非字节对齐的变量生成相应的指令，使用此选项后，汇编器将为非字节对齐的变量生成 lwa 或 swa 指令，而不是 lw 或 sw 指令</p><blockquote><p>lwa 和 swa 是用于访问非字节对齐内存的专用指令，而使用ls 或 sw 指令访问非字节对齐内存可能会导致程序崩溃或数据丢失</p></blockquote></li><li><p><strong><code>-funaligned-access</code></strong> ：是 C 语言的编译选项，用于告诉 C 编译器为非字节对齐的变量生成相应的指令。使用此选项后，C 编译器将为非字节对齐的变量生成 lwa 或 swa 指令，而不是 lw 或 sw 指令</p><blockquote><p>访问非字节对齐变量（如一字节对齐的结构体等），通常需要引起高度注意，其可能带来内存访问错误</p></blockquote></li><li><p><strong><code>-mfpu=fpv4-sp-d16</code></strong> ：指定使用 FPU 的 fpv4-sp-d16 浮点单元，函数的参数直接传递到FPU的寄存器（s0、d0）中。fpv4-sp-d16 是 MIPS 架构的 32 位浮点单元，支持单精度和双精度浮点运算。</p></li><li><p><strong><code>-mfloat-abi=hard</code></strong> ：指定使用硬件浮点 ABI。硬件浮点 ABI 是 MIPS 架构的标准浮点 ABI，支持硬件浮点运算</p><blockquote><p>如果程序中使用了软件浮点库，则需要使用 -mfloat-abi&#x3D;soft 来编译，否则将导致编译失败<br>如果程序中使用了与硬件浮点 ABI 不兼容的代码，则需要修改代码，使其与硬件浮点 ABI 兼容，否则将导致编译失败<br>需要确保-march和-mfpu参数与硬件和编译器兼容。如果处理器是Cortex-A9（ARMv7架构），那么应该使用-march&#x3D;armv7-a -mfpu&#x3D;neon</p></blockquote></li><li><p><strong><code>-mfloat-abi=soft</code></strong> ：表示使用软件浮点 ABI，所有浮点运算都将在软件中进行，即使硬件中存在 FPU</p></li><li><p><strong><code>-mfloat-abi=softfp</code></strong> ：使用FPU硬件来做浮点运算，只是，函数的参数传递到整数寄存器（r0-r3）中，然后再传递到FPU中。</p></li></ul><br><h2 id="GCC链接选项LDFLAGS参数及说明"><a href="#GCC链接选项LDFLAGS参数及说明" class="headerlink" title="GCC链接选项LDFLAGS参数及说明"></a>GCC链接选项LDFLAGS参数及说明</h2><ul><li><p><strong><code>--specs=nosys.specs</code></strong> : 禁用标准库的系统调用，在嵌入式程序中应用。</p><blockquote><p>当编译时提示：<code>undefined reference to _sbrk&#39; 或 undefined reference to _write&#39;d</code> 等等时，可以加上此条选项</p></blockquote></li><li><p><strong><code>--specs=nano.specs</code></strong> : 不使用C语言标准库，改用微库，大大减小可执行文件大小。效果类似于应用newlib</p><blockquote><p>注意：使用微库后，不支持浮点数格式化标准输出</p></blockquote></li><li><p><strong><code>--specs=rdimon.specs</code></strong> : 不了解，在嵌入式MCU中加与不加都一样</p></li><li><p>**<code>-Wl</code>**：用于将其后的参数传递给链接器，其后可以跟随多个链接选项，每个选项用逗号分隔，具体含义取决于后面的链接选项</p></li><li><p><strong><code>-Wl,--gc-sections</code></strong> : 告知链接器删除未使用的代码和数据段，搭配<code>-fdata-sections</code>和<code>-ffunction-sections</code>使用</p></li><li><p><strong><code>-Wl,–whole-archive</code></strong> ：告诉链接器将指定的静态库中的所有对象文件都链接到生成的目标文件中，即使这些对象文件中定义的符号在目标文件中没有被使用</p></li><li><p><strong><code>-Wl,–no-whole-archive</code></strong> ：选项告诉链接器只链接到静态库中那些定义了目标文件中使用的符号的对象文件</p></li><li><p><strong><code>-Wl,--wrap=symbol</code></strong> ：用于为给定的符号创建一个包装函数 &#x3D;&#x3D; 用于将symbol函数的调用重定向到__wrap_symbol函数，同时提供一个__real_symbol函数来调用原始的symbol函数</p></li><li><p><strong><code>-L 和 -l</code></strong> ：用于链接库文件，<code>-L</code>用于指定库文件的路径（如果库文件不在默认的搜索路径），<code>-l</code>用于指定要链接的库的名称（只需要提供库的名称，不需要lib前缀或.a、.so）</p><blockquote><p>例如，-L&#x2F;path&#x2F;to&#x2F;library<br>例如，对于libxxx.a或libxxx.so，只需要写-lxxx<br>-lm，链接数学库，如果要用到&lt;math.h&gt;的数学库函数，则需要添加此链接选项</p></blockquote></li></ul><h2 id="非典型应用示例"><a href="#非典型应用示例" class="headerlink" title="非典型应用示例"></a>非典型应用示例</h2><h3 id="包装函数"><a href="#包装函数" class="headerlink" title="包装函数"></a>包装函数</h3><p>如： <strong>-Wl,–wrap&#x3D;_calloc_r和-Wl,–wrap&#x3D;_malloc_r</strong></p><ul><li>其会将所有的_calloc_r和_malloc_r函数调用重定向到__wrap__calloc_r和__wrap__malloc_r函数</li><li>如果想调用原始的_calloc_r和_malloc_r函数，可以通过__real__calloc_r和__real__malloc_r函数来调用</li><li>通常用于函数的包装：即在函数执行前后添加一些额外的操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void *__wrap__calloc_r(struct _reent *reent_ptr, size_t nmemb, size_t size) &#123;</span><br><span class="line">printf(&quot;calloc_r called with %zu, %zu\n&quot;, nmemb, size);</span><br><span class="line">return __real__calloc_r(reent_ptr, nmemb, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *__wrap__malloc_r(struct _reent *reent_ptr, size_t size) &#123;</span><br><span class="line">printf(&quot;malloc_r called with %zu\n&quot;, size);</span><br><span class="line">return __real__malloc_r(reent_ptr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="控制链接器链接静态库文件"><a href="#控制链接器链接静态库文件" class="headerlink" title="控制链接器链接静态库文件"></a>控制链接器链接静态库文件</h3><ul><li>以下为工程中链接选项的片段：<ul><li>其将以下指示的静态库中所有对象文件都链接到目标文件中</li><li>而后将链接器恢复为只链接到静态库中定义了目标文件中使用的符号的对象文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># xxx</span><br><span class="line">-Wl,--whole-archive \</span><br><span class="line">libs/libbootstrap.a libs/libbroadcast.a \</span><br><span class="line">libs/libsamgr.a libs/libtoken_static.a libs/libnative_file.a \</span><br><span class="line">libs/libhilog_lite.a libs/libhiview_lite.a libs/libhievent_lite.a \</span><br><span class="line">-Wl,--no-whole-archive</span><br><span class="line"># xxx</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>在链接其它工程静态库时，出现报错，需要考虑以下原因：</strong></p><ul><li>编译器版本是否一致</li><li>两者所处系统是否同一版本</li><li>文件损坏</li></ul><h2 id="编译纠错修改以及一些注意点"><a href="#编译纠错修改以及一些注意点" class="headerlink" title="编译纠错修改以及一些注意点"></a>编译纠错修改以及一些注意点</h2><ul><li><p>当编译提示:<code>- undefined reference to _init</code>，类似时，检查是否添加了编译选项<code>--nostdlib</code>，不链接标准库，却又没指定库，导致的编译错误</p></li><li><p>提示<code>- exit.c:(.text.exit+0x2c): undefined reference to _exit</code>，考虑在.ld链接文件的.text段的末尾加上<code>_exit = .;</code></p></li><li><p>开启两级优化时, 需要注意C程序中汇编函数的调用可能会被优化掉, 可以考虑加上<code>__attribute__ ((used))</code></p></li><li><p>需要注意编译等级的选择，可能会影响到程序的运行，代码编写时需要严谨</p></li><li><p>应用 <strong><code>-fdata-sections</code></strong> 可能会导致程序出错</p><ul><li>编程时尽量避免在不同的源文件中定义相同名称的全局变量或函数，避免链接错误</li><li>确保先正确初始化全局变量或函数，然后再引用</li></ul></li><li><p>编译选项和链接选项是分开处理的，编译选项只影响编译过程，链接选项只影响链接过程。而，在GCC中，可以在同一条命令中指定编译选项和链接选项，GCC会在编译和链接过程中分别应用这些选项。但不建议这样做</p></li></ul><h2 id="Makefile应用实例"><a href="#Makefile应用实例" class="headerlink" title="Makefile应用实例"></a>Makefile应用实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 指定交叉编译工具链的 编译器、连接器、库管理器、</span><br><span class="line">CROSS_COMPILE=arm-none-eabi-</span><br><span class="line">CC=$(CROSS_COMPILE)gcc</span><br><span class="line">LD=$(CROSS_COMPILE)ld</span><br><span class="line">AR=$(CROSS_COMPILE)ar</span><br><span class="line">AS=$(CROSS_COMPILE)as</span><br><span class="line">OC=$(CROSS_COMPILE)objcopy</span><br><span class="line">OD=$(CROSS_COMPILE)objdump</span><br><span class="line">SZ=$(CROSS_COMPILE)size</span><br><span class="line"></span><br><span class="line"># 指定目标硬件的架构和浮点运算单元   -mfpu=fpv4-sp-d16 -mfloat-abi=hard </span><br><span class="line"># O0:禁用优化，O1：基本优化，O2, O3, Os</span><br><span class="line"># g0:禁用调试信息, g1, g2, g3, g</span><br><span class="line">MCU = -mcpu=cortex-m4 -mthumb \</span><br><span class="line">-ffunction-sections \</span><br><span class="line">-fdata-sections \</span><br><span class="line">-Os -ggdb</span><br><span class="line"></span><br><span class="line"># 定义编译C源文件的编译选项：禁用共享变量、函数和数据分段、优化级别、调试信息级别、开启所有警告、目标架构、预定义宏</span><br><span class="line">CFLAGS= -c -fno-common \</span><br><span class="line">--specs=rdimon.specs \</span><br><span class="line">-std=gnu99 -mabi=aapcs \</span><br><span class="line">-Wall \</span><br><span class="line">$(MCU) \</span><br><span class="line">$(C_DEFS)</span><br><span class="line"></span><br><span class="line"># 定义链接器脚本、链接选项、目标文件格式转换选项、反汇编等等</span><br><span class="line">LDSCRIPT=n32l40x_flash.ld</span><br><span class="line">LDFLAGS = -Wl,--gc-sections --data-sections -mabi=aapcs $(MCU) -T$(LDSCRIPT) \</span><br><span class="line">--specs=nosys.specs \</span><br><span class="line">--specs=nano.specs \</span><br><span class="line">-x assembler-with-cpp -Wa,-mimplicit-it=thumb</span><br><span class="line">OCFLAGS= -Obinary</span><br><span class="line">ODFLAGS= -S</span><br></pre></td></tr></table></figure><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.cnblogs.com/justin-y-lin/p/10100370.html">ARM非对齐访问和Alignment Fault</a></li><li><a href="https://blog.51cto.com/u_15854579/5810066">浮点数</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 嵌入式 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> 链接 </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【硬件】PCB设计前置知识学习笔记</title>
      <link href="/2024/01/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91PCB%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91PCB%E8%AE%BE%E8%AE%A1%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="PCB结构概述"><a href="#PCB结构概述" class="headerlink" title="PCB结构概述"></a>PCB结构概述</h2><p>基本结构为三明治结构，两层板的中间是FR4（玻璃纤维），上层跟下层都是铜层。四层板是将两个两层板压制在一起，在两个两层板之间加一层半预制片，其是绝缘的。依此类推，4层，6层，8层等都是由多个两层板叠加压制而成。</p><p>铜板上需要覆上一层油漆，其叫阻焊层，也就是板子上绿色的区域，其作用：</p><ul><li>保护铜线，防止氧化</li><li>隔离焊盘，防止不需要的地方粘上焊锡</li></ul><p>丝印层：在阻焊层之上，用于印刷字体，称为位号，用来标记焊接的元件<br><br></p><p>PCB电路板的本质如一幅二维图画：黑色地方是镂空的，红色的地方是不透光的，其叫GERBER文件（光绘文件），每一层电路板都会有一个GERBER文件。生产厂会通过GERBER文件生产出胶片，从而制作电路板</p><h2 id="PCB的制作流程"><a href="#PCB的制作流程" class="headerlink" title="PCB的制作流程"></a>PCB的制作流程</h2><p>PCB的整体制作流程如下：</p><p>设计电路图-&gt;生成GERBER文件-&gt;制作印刷胶片-&gt;制作基板（完整的三明治PCB结构板）-&gt;光刻（在铜泊表面覆盖光刻胶，用紫外光曝光融化光刻胶，把不需要的铜泊暴露出来）-&gt;蚀刻（将未被光刻胶保护的铜箔部分蚀掉，形成电路导线）-&gt;去除光刻胶-&gt;层压-&gt;钻孔（根据GERBER文件，在需要连接的位置钻孔）-&gt;金属化处理（沉铜、镀锡、镀金、镀银、镀镍等）-&gt;喷涂防焊层（阻焊层）-&gt;字符标识（加丝印）-&gt;表面处理</p><p>设计者只需要将 GERBER 文件、BOM表以及位号表交到厂家即可。</p><h3 id="基础工艺指标"><a href="#基础工艺指标" class="headerlink" title="基础工艺指标"></a>基础工艺指标</h3><p>板厚: 指电路板的整体厚度，单位通常为毫米（mm）。板厚的选择应考虑机械强度、散热需求、成本、与外部接口的配合等因素。常见的板厚范围为0.4mm至3.2mm。 典型值如：1.0mm</p><p>走线宽度: 单根导线的宽度，典型值0.1mm，线宽度直接影响电路的电流承载能力、阻抗特性以及信号传输质量。在高速信号设计中，需控制走线的特性阻抗以保证信号完整性。</p><p>钻孔内径: 0.3mm，过孔（via）内部金属化的孔径，单位通常为毫米（mm）或微米（μm）。钻孔内径决定了电流通过过孔的面积，影响电流容量和阻抗</p><p>钻孔外径: 0.4mm，过孔在电路板两面露出的孔径，主要影响焊接时焊料的填充情况以及与元器件引脚的接触面积。一般钻孔外径略大于钻孔内径，以确保良好的焊接效果。</p><p>走线间距: 0.1mm，走线间距决定了电路板的绝缘性能，影响电压等级、耐压能力以及抗串扰能力。走线间距一般等于走线宽度</p><p>铜厚: 电路板上铜箔的厚度，常用单位为盎司（oz，表示每平方英尺铜箔的重量），铜厚决定了电路的载流能力和散热性能。常见的铜厚规格有1oz（约35μm）、2oz（约70μm）等</p><p>丝印字符: 0.15mm，丝印字符包括元件标识符、测试点标记、装配指示等信息，应确保清晰可读，但又不妨碍元器件的放置和焊接。</p><h2 id="PCB的设计依据–原理图设计"><a href="#PCB的设计依据–原理图设计" class="headerlink" title="PCB的设计依据–原理图设计"></a>PCB的设计依据–原理图设计</h2><p>原理图展示了电路中元器件之间的连接关系和信号流向，通过原理图，使得在PCB设计中可以确定元件的位置、引脚的连接方式、信号传输路径等，从而准确地布局元件、绘制连线。</p><p><strong>原理图封装：</strong>用于表示电路中元件的图形符号，包含元件的引脚标记、形状和其它信息。通常在原理图编辑器中绘制原理图封装，其与原理图库（SCHLIB）相关联，以便在电路原理图中使用</p><ul><li>在建立原理图封装的时候，可以将其与器件料号关联起来。如用 PartNum 标识料号，便于物料管理</li><li>当然，器件规格描述也要按照规范填写，使得导出BOM表时，板厂可以识别出器件类型，从而进行贴片</li><li>通过在原理图封装中设置<code>Footprint</code>属性，在建PCB封装时此字段保持一致，则使得原理图封装与PCB封装相关联<br></li></ul><p>原理图的每一个网络都能在PCB中找到映射的铜线，每一个元件都能在PCBA中找到映射的器件或者焊盘（PCB封装）</p><h3 id="网表"><a href="#网表" class="headerlink" title="网表"></a>网表</h3><p>网表：网表文件包含了电路中的元器件、引脚和连接信息，用于PCB布局和布线工作。其是通过电路仿真工具或者PCB设计工具根据原理图生成的元件连接网络的文字表达形式，是连接原理图与PCB Layout的桥梁。</p><p>网络表由元件表和连接网络表组成：</p><ul><li>元件表描述原理图中元件的三大属性：元件标号、元件封装形式以及元件型号</li><li>连接网络表包含原理图中所有电气连接网络，包含网络名称、网络中的节点信息、网络连接描述等<br></li></ul><p>原理图网表用于在PCB Layout时导入对应元器件的封装与所有的电气连接网络</p><h2 id="BOM管理"><a href="#BOM管理" class="headerlink" title="BOM管理"></a>BOM管理</h2><p>BOM表可以直接从原理图导出，跟PCB布局前后不直接相关</p><p>原理图设计时，确定所需的元器件和材料</p><p>PCB设计时，确定元器件的位置和引脚连接，同时还记录了元器件的规格、封装和数量</p><p>生产根据BOM配置进行贴片</p><p>有利于维护和售后</p><h2 id="PCB-Layout概述"><a href="#PCB-Layout概述" class="headerlink" title="PCB Layout概述"></a>PCB Layout概述</h2><p>在PCB Layout前可能需要结构图文件：用于指示PCB板外形、安装孔、元件布局设计等，保证与结构不会互相干涉</p><p>拥有了结构以及原理图网表，即可开展PCB Layout设计</p><p>PCB Layout设计，主要涉及以下步骤：</p><ul><li>导入网表：将原理图网表导入Layout软件中，软件会自动创建对应元器件的封装实例，并根据网表连接关系形成初步的电气网络。</li><li>布局规划</li><li>布线</li><li>验证与优化</li><li>输出文件：完成设计验证并通过后，生成生产所需的Gerber文件、钻孔文件、物料清单（BOM）、装配图等</li></ul><h3 id="PCB封装创建"><a href="#PCB封装创建" class="headerlink" title="PCB封装创建"></a>PCB封装创建</h3><p>PCB封装：详细定义电子元器件和PCB之间的物理接口关系，包含以下几个核心组成部分</p><ul><li>焊盘（Pad）</li><li>组件轮廓（Compponent Outline）：描绘元器件主体的外形，作为布局时的视觉参考</li><li>参考指示符（Reference Indicator）：如R1、C1、U1等参考指示符标号，当然，在设计软件中，元件的参考指示符（如R1、C2、U3等）通常是可以设置为自动递增的</li><li>引脚指示符：标识电子元器件各个引脚的编号、名称或功能标签</li><li>机械信息：</li><li>3D模型（封装）：通过3D模型可以验证元件之间的空间布局，避免干涉，对整体结构设计、装配验证、散热分析等有重要意义</li></ul><p>封装库：封装库是存储各类元器件封装信息的数据库，包括元器件的引脚布局、尺寸、形状等。</p><ul><li>作用：在PCB布局阶段，设计师人员封装库中选择合适的封装，将元器件放置在电路板上</li></ul><p>常见封装类型如下：</p><ul><li>SOP（Small Outline Package）：小外形封装，常见于集成电路，引脚沿两侧或四侧分布。</li><li>QFP（Quad Flat Package）：四方扁平封装，四面均有引脚，适合高引脚数IC。</li><li>BGA（Ball Grid Array）：球栅阵列封装，底部布满焊球，提供高密度、高性能的封装解决方案。</li><li>DIP、QFN等等</li></ul><p>封装标准 为确保封装设计的规范性和一致性，业界制定了多项封装标准，其中包括：</p><ul><li>IPC 7351：由国际电子工业联接协会（IPC）制定的元器件封装设计推荐标准，提供详细的尺寸、焊盘尺寸、引脚间距等指导。</li><li>ANSI Y32.2-1975：美国国家标准学会（ANSI）关于电子设备封装的旧版标准，已逐渐被更新的标准取代。</li><li>ISO 10303-21：国际标准化组织（ISO）制定的产品数据交换标准，适用于电子设备封装信息的数字化表示与交换。</li></ul><h3 id="元件放置（布局设计）"><a href="#元件放置（布局设计）" class="headerlink" title="元件放置（布局设计）"></a>元件放置（布局设计）</h3><p>PCB布局是整个设计流程中的首要步骤。在综合考虑信号质量、EMC、热设计、DFM、DFT、结构、安规等方面要求的基础上，将器件合理地放置到板面上。</p><p>布局应满足以下要求：</p><ul><li><strong>总的连线尽可能短</strong>：总体上，应力求减少所有导线的总长度，以减少信号传输延迟、降低功耗、提升电路速度，并减轻潜在的EMI（电磁干扰）问题。尤其强调关键信号线最短</li><li><strong>高电压、大电流信号与低电压、小电流信号分离</strong>：确保强信号（高电压、大电流）与弱信号（低电压、小电流）之间实现有效隔离，防止因压降、串扰等因素造成弱信号的失真或干扰。</li><li><strong>模拟信号与数字信号分开</strong>：模拟电路对噪声极为敏感，应与数字电路保持足够的距离，以减小由数字信号切换产生的瞬态电流和高频噪声对模拟电路的干扰。</li><li><strong>高频信号与低频信号分开</strong>：高频信号具有更强的辐射能力及更易受外部干扰的特性，应将其与其他低频信号妥善隔离，以提升EMC（电磁兼容性）性能，减少相互间的串扰。</li><li><strong>高频元器件的间距要充分</strong>：高频元器件（如射频模块、高速接口芯片等）不仅需与其他类型信号隔离，彼此间也应保持适当的间距，以减小互耦效应和串扰。</li><li><strong>满足仿真和时序分析要求</strong>：在布局阶段，确保设计能满足后续的信号完整性仿真、电源完整性仿真及时序分析等验证要求</li></ul><h3 id="布线设计"><a href="#布线设计" class="headerlink" title="布线设计"></a>布线设计</h3><p>PCB布线是整个PCB设计中工作量最大的环节，直接影响着PCB板的性能和可靠性。</p><p>布线处理的基本要求包括：</p><ul><li><strong>合适的过孔</strong>：根据元器件的尺寸和电路板的厚度选择合适的过孔类型和大小，以确保信号和电源的顺利传输。同时，需要考虑过孔的寄生效应，如可能的电感和电阻对信号完整性的影响。</li><li><strong>线宽</strong>：根据信号的电流大小、频率以及电路板的敷铜情况选择合适的线宽，以保证信号的稳定传输和<strong>避免因过热</strong>导致的问题。</li><li><strong>安全间距</strong>：根据信号的传输距离、信号的传输速度和电路板的敷铜情况选择合适的安全间距，以避免信号的失真和失稳。</li><li><strong>走线到板边距离</strong>：≥2mm，保证电路板的机械强度和减少信号在板边处的干扰。</li><li>高速信号线长尽量保持一致，避免影响信号的传输</li></ul><p>电源层和地层之间的EMC环境较差，应避免布置对干扰敏感的信号线。</p><p>在PCB设计中，走线（Routing）和铺铜（Pouring Copper &#x2F; Covering Copper）是两种不同的铜层分布形式，它们各自具有特定的功能和应用场景。</p><p>一般来说：GND需要铺设较大范围的铜皮，如果VCC在一个区域内分布零散，则也可在此铺设铜皮。</p><p>如果为四层板的布置，则在布置器件较多的表面层相近的一层用作地层，缩短电流回路。</p><h2 id="PCB设计相关基础术语或词语解析"><a href="#PCB设计相关基础术语或词语解析" class="headerlink" title="PCB设计相关基础术语或词语解析"></a>PCB设计相关基础术语或词语解析</h2><h3 id="PCB设计中的元素或元件的英文简写"><a href="#PCB设计中的元素或元件的英文简写" class="headerlink" title="PCB设计中的元素或元件的英文简写"></a>PCB设计中的元素或元件的英文简写</h3><p>晶振（XTAL）<br>跳线或插孔座（JP），如烧录孔<br>连接器（CN或CONN）<br>焊盘（Pad）<br>集成电路（IC 或 U?）<br>二极管（D）<br>晶体管（Q）<br>电容（C）<br>电阻（R）<br>电感（L）<br>端子座（CON?）</p><p>NC：此处不贴元件</p><h3 id="PCB-Layout基础词语"><a href="#PCB-Layout基础词语" class="headerlink" title="PCB Layout基础词语"></a>PCB Layout基础词语</h3><p>焊盘：PCB板上用于焊接元器件的金属圆盘状区域。</p><p>板框：是PCB设计文件的重要组成部分，指的是PCB板的外形和尺寸范围。定义了PCB板的物理边界，包括长度、宽度和形状等信息，设计者需要在板框内布局电路元件和走线，确保设计符合PCB板的实际尺寸和要求。</p><h3 id="EMC（电磁兼容性）"><a href="#EMC（电磁兼容性）" class="headerlink" title="EMC（电磁兼容性）"></a>EMC（电磁兼容性）</h3><p>EMC（Electromagnetic Compatibility），指设备能够在电磁环境中正常工作且不对该环境中任何其他设备造成不可接受的电磁干扰的能力</p><p>其包含电磁干扰（EMI, Electromagnetic Interference）和电磁抗扰度（EMS，Electromagnetic Suitability）两个概念。</p><h3 id="ESD"><a href="#ESD" class="headerlink" title="ESD"></a>ESD</h3><p>增加静电抑制器件，防静电</p><h2 id="PCB整体设计流程总结"><a href="#PCB整体设计流程总结" class="headerlink" title="PCB整体设计流程总结"></a>PCB整体设计流程总结</h2><ul><li><p>需求分析：与客户或项目组讨论需求，明确PCB设计的功能、性能、尺寸、接口等要求。</p></li><li><p>建库：SCHLIB、PCBLIB</p></li><li><p>原理图设计：根据需求，使用设计软件（如Altium Designer、Cadence等）绘制PCB的原理图，包括连接的元器件、信号传输路径等。</p></li><li><p>元器件选型：根据原理图，选择合适的元器件，考虑性能、尺寸、成本等因素。</p></li><li><p>PCB布局设计：将元器件在PCB板上进行布局设计，考虑信号传输路径、电源分布、散热等因素。</p></li><li><p>连线布线：根据原理图和布局设计，在PCB板上进行连线布线，保证信号传输的稳定性和可靠性。</p></li><li><p>PCB制作：生成PCB板的制作文件（Gerber文件），并提交给PCB厂家进行生产。</p></li><li><p>PCB组装：将元器件焊接到PCB板上，进行电气测试和功能验证。</p></li><li><p>调试和优化：对PCB进行调试，验证功能是否符合要求，优化设计以满足性能需求。</p></li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.bilibili.com/video/BV1GU4y1N7Z6/?spm_id_from=333.999.0.0&vd_source=82e85569f7427ac31cbd67ec7206aa00">学习PCB设计前的知识扫盲，新手向，越新手越好！</a></li><li><a href="https://blog.csdn.net/LEON1741/article/details/104783084">浅谈各种常见的芯片封装技术DIP&#x2F;SOP&#x2F;QFP&#x2F;PGA&#x2F;BGA</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【硬件】硬件基础器件知识记录</title>
      <link href="/2024/01/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%99%A8%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%AE%80%E8%BF%B0/"/>
      <url>/2024/01/01/%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E5%99%A8%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>未完待续…</strong></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文并非专于器件相关概念，仅于工作时接触到或者兴致到来时，随手记录而已</p><h2 id="电路基础元件概念"><a href="#电路基础元件概念" class="headerlink" title="电路基础元件概念"></a>电路基础元件概念</h2><p>电阻：R<br>电感：L<br>电容：C</p><h3 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h3><p>简写为：D</p><p>二极管的主要功能包括整流（将交流电转换为直流电）、稳压、钳位、开关和频率选择等。</p><p>在电路中，二极管通常用于保护电路免受反向电压的影响，使得电流在一个方向流动，即所谓的单向导电性。</p><p>其基本原理是基于P型半导体和N型半导体形成的P-N结：</p><ol><li>P-N结的形成：P型半导体含有较多的空穴（正电荷载流子），而N型半导体含有较多的电子（负电荷载流子）。当P型和N型半导体接触时，电子从N型材料向P型材料移动，空穴从P型材料向N型材料移动，形成一个叫做空间电荷区的区域，也称为耗尽层</li><li>电平衡：耗尽层两侧的电荷分布产生一个自建电场，阻止更多的电子和空穴继续穿越P-N结，使得扩散电流与漂移电流达到平衡，二极管处于截止状态</li><li>正向偏置：当在P端施加正电压（阳极），在N端施加负电压（阴极）时，P-N结正向偏置。当正向电压达到一定阈值（正向导通电压，通常为0.6V到0.7V左右对于硅二极管）克服自建电场，空间电荷区变窄，允许大量的电子和空穴再次流动，形成较大的正向电流</li><li>反向偏置：当在P端施加负电压，N端施加正电压时，P-N结反向偏置。反向电压增强自建电场，空间电荷区扩大，只有少量的反向漏电流（I0）通过，通常很小，二极管基本上截止</li><li>击穿：如果反向电压过高，P-N结可能会发生雪崩击穿或齐纳击穿，导致电流突然大幅度增加，击穿后，二极管可能失去单向导电性，变为导通状态。</li></ol><p>注意压降的影响，导致电压的降低或者功率损耗</p><h3 id="三极管（双极型晶体管）"><a href="#三极管（双极型晶体管）" class="headerlink" title="三极管（双极型晶体管）"></a>三极管（双极型晶体管）</h3><p>三极管由三层半导体材料组成，分别是发射极（Emitter, E）、基极（Base, B）和集电极（Collector, C）。发射极和集电极之间通过基极连接。</p><p>三极管分为两种类型，NPN型和PNP型，区别在于它们的掺杂类型和电流方向：</p><p>NPN型：发射极和集电极是N型半导体，基极是P型半导体。<strong>电流主要是电子流，电子从发射极向集电极流动（即电流为集电极流向发射极）</strong>。简写为 Q 或 QN，在开关电路、放大电路、数字逻辑电路以及各种电子设备的接口驱动等方面更为常见。</p><p>PNP型：发射极和集电极是P型半导体，基极是N型半导体。<strong>电流主要是空穴流，电流方向与NPN型相反</strong>。简写为 Q 或 QP，更多出现在需要与负电源配合、需要电流反向传输、需要与NPN型晶体管互补工作的场合，如某些电源控制电路、模拟电路的反相级、推挽放大器以及某些特殊的逻辑电路中。</p><p><strong>放大作用：</strong> 将三极管的基极连接到控制DAC引脚，可以实现所需的放大作用。也可以串联一个电容接到PWM-IO，通过方波占空比控制电容的电压，从而驱动基极。<br><strong>开关作用：</strong> 将三极管的基极连接到控制IO口，可以实现开关作用。通常需要串联电阻，当然硬件上一般采用<strong>数字三极管</strong>，里面已经集成了串联电阻。</p><p>截止状态：当基极-发射极之间的电压为零或反向偏置时，三极管处于截止状态，几乎没有电流流过<br>对于NPN型，Vb &lt; Ve，集电极电流Ic接近于零。<br>对于PNP型，Vb &gt; Ve，集电极电流Ic接近于零。</p><p>放大状态：当基极-发射极之间的电压足够大，使得发射极的多数载流子大量注入基极区，并被集电区收集时，三极管处于饱和状态，集电极电流达到最大<br>对于NPN型，Vc &gt; Vb &gt; Ve，基极电流Ib控制Ic，Ic与Ib之间的关系是放大关系。<br>对于PNP型，Vc &lt; Vb &lt; Ve，同样存在放大关系。</p><p>饱和状态：<br>对于NPN型，Vb &gt; Ve，Vc不再随着Vb的增加而增加，Ic达到最大值。<br>对于PNP型，Vb &lt; Ve，Vc不再随着Vb的减小而减小，Ic也达到最大值。</p><h3 id="MOS管（场效应晶体管）"><a href="#MOS管（场效应晶体管）" class="headerlink" title="MOS管（场效应晶体管）"></a>MOS管（场效应晶体管）</h3><p>MOSFET（金属-氧化物-半导体场效应晶体管）的工作原理基于电场对半导体表面通道的控制。MOSFET有三个电极：栅极（Gate）、源极（Source）和漏极（Drain），以及一个衬底</p><p>NMOS和PMOS的区别在于沟道类型和控制电流的载流子类型，<strong>对于NMOS，载流子是电子，对于PMOS，载流子是空穴对</strong></p><p>当栅极G与源级S之间的电压足够大时，衬底中的少子会聚集到衬底与栅极G绝缘层的边界，形成源级S和漏级D之间的导电沟道。载流子可以通过这个沟道从源级S流向漏级D。此时栅源GS之间的电压就是阈值电压，记作Vth。通常为0.8V以上。</p><p>VGS为栅极-源极电压，即VGS &#x3D; Vg - Vs</p><p><strong>N沟道MOSFET：（NMOS管）</strong> <em>VGS&gt;阈值电压（Vth）时，导通；VGS&lt;&#x3D;阈值电压（Vth）时，截止*。用于控制近地端的开关，如CJ3400，此时S极接负极<br>**P沟道MOSFET：（PMOS管）** *VGS&lt;阈值电压（Vth）时，导通；VGS&gt;&#x3D;阈值电压（Vth）时，截止</em>。用于控制近源端的开关，如CJ3401，此时S极接正极</p><p>VGS绝对值越大，MOSFET的导通程度越强，导通电阻越小，漏极电流越大。当MOSFET进入深度饱和区后，漏极电流的增加速率会放缓，最终达到一个饱和点。</p><p>另外，MOS管的电流方向是双向的。但通常情况下，NMOS的电流流向为 D-&gt;S。栅极-源极电压起到控制通断作用。</p><blockquote><p>由于衬底和D、S的掺杂导致的NMOS存在方向为S-&gt;D的体效应二极管<br>如果把S接高位电压，D接低位电压，此时NMOS相当于导通二极管，但此时栅极就失去了控制作用，没有意义了<br>PMOS管同理，电流流向通常为 S-&gt;D</p></blockquote><p>在实际应用中，一般在栅极和源极之间串个100K电阻，提供电压偏置、抑制振荡等。通过程序控制栅极的电压变化，与硬件电路确定的源极电压，从而控制MOS导通或截止。栅极的电压要能够控制实现大于或小于源极电压。</p><p><img src="/../pictures/%E4%B8%89%E6%9E%81%E7%AE%A1-MOS%E7%AE%A1%E5%AF%B9%E6%AF%94.png" alt="alt text"></p><h3 id="TVS管"><a href="#TVS管" class="headerlink" title="TVS管"></a>TVS管</h3><h3 id="晶振（XTAL）"><a href="#晶振（XTAL）" class="headerlink" title="晶振（XTAL）"></a>晶振（XTAL）</h3><p>不起振的原因</p><h3 id="集成电路（IC）"><a href="#集成电路（IC）" class="headerlink" title="集成电路（IC）"></a>集成电路（IC）</h3><p>数字IC：</p><p>模拟IC：</p><p>混合信号集成电路：音频解码器</p><h2 id="PCB设计中的基础器件-模块-电路"><a href="#PCB设计中的基础器件-模块-电路" class="headerlink" title="PCB设计中的基础器件&#x2F;模块&#x2F;电路"></a>PCB设计中的基础器件&#x2F;模块&#x2F;电路</h2><h3 id="充电、稳压器件"><a href="#充电、稳压器件" class="headerlink" title="充电、稳压器件"></a>充电、稳压器件</h3><p>稳压器（线性稳压器、开关稳压器）：将输入电压稳定到所需的输出电压。线性稳压器和开关稳压器都可以以独立元件的形式存在，也可以集成在IC之中</p><p>升压电路、降压电路或者升降压型电路等都是属于稳压器件的范畴。</p><p>Boost（升压）：将输入电压升高到所需的输出电压</p><p>Buck（降压）：将输入电压降低到所需的输出电压</p><p>DC-DC转换器：包括Boost、Buck和Buck-Boost（升降压）、反相等，具有高效率、高输出电流、较低静态电流等特点，但同时开关噪音大、成本高。现在通常都把开关型稳压器称作DC-DC，把低压差线性稳定器单独地称作LDO。</p><p>LDO（低压降线性稳压器）：不使用开关器件，成本低、噪音低，静态电流小，外接元件少。</p><blockquote><p>适用于输入电压和输出电压很接近的场景，如3.7V锂电池到3.3V负载，从原理可知LDO的输入电流基本上等于输出电流，所以压降越大，效率越低。</p></blockquote><br><p>SGM62112-ADJ、SGM61020</p><p>线性稳压器通常由分立元件（如晶体管、电阻、电容）组成，也有集成化的线性稳压器IC（如LM7805、LM317等），它们将所有必要的功能集成在一个封装内，简化了电路设计和组装</p><hr><p>充电模块：当施加到电池的外界电压大于电池电压时，则外界向电池充电</p><p>开关型充电器：通常高频开关操作（可以说是PWM调制），将输入电压稳定到一个给电池充电的输出电压，大幅度提升效率、减少热损耗，宽范围输入</p><p>线性充电器：基于使用一个或多个晶体管作为可变电阻来调节流向电池的充电电流。效率低、损耗大、低噪声、体积小</p><p>通常原理图布置在电源模块上可以预留并多几路 RC串联的NC电路，后续EMC时可以进行调节</p><p>SGM40661 过流保护<br>SGM41524YTDC8G</p><h3 id="功率放大器"><a href="#功率放大器" class="headerlink" title="功率放大器"></a>功率放大器</h3><p>功放可以是集成IC（集成电路），也可以是基于分立元件（如晶体管、电子管）构建的。<br>集成IC功放，是将放大电路中的多个元件，如晶体管、电阻、电容等，集成在同一块硅片上，形成一个完整的放大器电路。<br><br></p><p>A类功放（甲类功放）：</p><ul><li>A类功放的输出晶体管在整个信号周期内始终处于导电状态，即使在没有音频信号输入时，也会有恒定的电流流过输出级，这保证了极低的失真，但效率很低，因为大部分能量转化为热量。</li><li>优点：音质纯净，失真低。</li><li>缺点：效率低（一般小于50%），发热严重，需要大型散热器<br></li></ul><p>B类功放（乙类功放）：</p><ul><li>B类功放的输出晶体管仅在信号的半个周期内导通，分别处理正半周和负半周信号，从而提高了效率，但存在交越失真问题，即在信号过零点附近两个晶体管切换时产生的非线性失真。</li><li>优点：效率较高（约为78%）。</li><li>缺点：存在交越失真，音质不如A类。<br></li></ul><p>AB类功放（甲乙类功放）：</p><ul><li>AB类功放是A类和B类的折衷方案，通过轻微偏置输出晶体管，使其在没有信号时仍有一点导通，减少了B类功放的交越失真，同时保持了较高的效率。</li><li>优点：结合了A类的音质和B类的效率，失真低，效率比A类高。</li><li>缺点：相比B类功放，效率略低，发热仍较明显。<br></li></ul><p>D类功放（丁类功放）：</p><ul><li>D类功放是一种开关放大器，它将音频信号转换为高频脉冲序列，通过晶体管快速开关来控制输出，效率极高（可达90%以上）。</li><li>其<strong>信号在输出级被调制成PWM（脉冲宽度调制）或PFM（脉冲频率调制）信号。</strong></li><li>优点：极高效率，发热少，体积小，适合便携式应用。</li><li>缺点：需要额外的滤波器来恢复原始音频信号，对电源和地线噪声敏感，可能影响音质。<br></li></ul><h2 id="其它在PCB设计中的基础器件"><a href="#其它在PCB设计中的基础器件" class="headerlink" title="其它在PCB设计中的基础器件"></a>其它在PCB设计中的基础器件</h2><p>连接器（CN或CONN）：板对板、线对板、FPC&#x2F;FFC连接器</p><p>电位器</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><h4 id="增量型旋转编码器"><a href="#增量型旋转编码器" class="headerlink" title="增量型旋转编码器"></a>增量型旋转编码器</h4><p>通常有两个输出通道（A、B通道），连接到芯片引脚。</p><p>AB通道输出方波，相位差为90度，通过判断相位差正负，区分正反旋转方向。</p><p>通过脉冲计数来确定旋转的角度，通过脉冲频率来确定旋转速度<br><br></p><p><strong>软件设计：</strong> </p><ul><li>可以采用定时器轮询、外部GPIO中断、输入捕获等方式实现</li><li>如：轮询到一个引脚电平变化后，接着读取另一个引脚的电平，判断相位差正负，即可判断旋转方向<blockquote><p>轮询读取时间至少要为 编码器90度旋转时间&#x2F;2 ，否则会丢失</p></blockquote></li></ul><h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><h3 id="保护与控制元件"><a href="#保护与控制元件" class="headerlink" title="保护与控制元件"></a>保护与控制元件</h3><p>熔断器、保险丝</p><p>热敏开关、过温保护器</p><p>压敏电阻</p><h3 id="EMC相关设计"><a href="#EMC相关设计" class="headerlink" title="EMC相关设计"></a>EMC相关设计</h3><p>屏蔽罩</p><p>磁珠</p><p>共模电感</p><p>滤波电容</p><h2 id="注意点及扩展思考"><a href="#注意点及扩展思考" class="headerlink" title="注意点及扩展思考"></a>注意点及扩展思考</h2><p>在器件选型时，一定要详细查看规格书，当然也可以查看下IC模块内的组成</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://mp.weixin.qq.com/s/XhCeTT007Is_M5pU00NaeQ">一篇文章说清楚TVS管</a></li><li><a href="https://mp.weixin.qq.com/s/l7-WHBXccLOAm4gO4N8_Bw">实用角度解读MOS管：功能特点与实际应用</a></li><li><a href="https://mp.weixin.qq.com/s/R47HmGaQAvFPwFJ9f5dGCw">三极管的奥秘：如何用小电流控制大电流</a></li><li><a href="https://mp.weixin.qq.com/s/9Kf1bLaXQgGTXwK63m5jwg">“晶振”工作原理及匹配电容如何选你get到了吗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Harmony】OpenHarmony-LiteOS-M内核之编译构建及移植适配过程解析</title>
      <link href="/2023/12/29/%E3%80%90Harmony%E3%80%91Harmony-LiteOS-M%E5%86%85%E6%A0%B8%E4%B9%8BGN%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/12/29/%E3%80%90Harmony%E3%80%91Harmony-LiteOS-M%E5%86%85%E6%A0%B8%E4%B9%8BGN%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>阅读本文，须先参阅<a href="/2023/12/24/GN%E5%92%8Cninja%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB%E5%92%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91"><strong>GN与Ninja入门</strong></a></p><p>本文内容大部为参考OpenHarmony相关站点文章，基于个人在移植适配&#x2F;开发过程中的理解，作进一步的整理，其中必然有许多不足或前期理解错误之处，仅作参考用即可</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="记于2023-12-29"><a href="#记于2023-12-29" class="headerlink" title="记于2023-12-29"></a>记于2023-12-29</h3><ul><li>就目前而言，网上关于LiteOS-M的相关开发移植资料都是相当的少，官方文档也是写得不清不楚的，如果不是项目需求，估计没人愿意来做LiteOS-M的移植适配工作。。</li><li>鄙人初次接触，此前参考了社区的STM32工程移植示例，成功移植LiteOS-M并在gcc+make开发环境运行</li><li>但由于政策或者是项目需要，单纯的内核源码移植其实没什么用，跟别的RTOS内核没啥两样，由此，接触了一个新概念：<strong>XTS子系统</strong>，要获得开放原子基金会的认证，那么就需要通过这个XTS兼容性测评</li><li>要把这个XTS测试组件编译进工程里面，鄙人目前一头雾水，特别还是基于国民技术N32G452芯片移植并编译测试，目前还在熟悉状态，考虑两种方式：<ul><li>基于 <a href="https://gitee.com/openharmony/kernel_liteos_m">https://gitee.com/openharmony/kernel_liteos_m</a> 所拉取的源码工程，进行熟悉构建开发</li><li>基于 <a href="https://gitee.com/link?target=https://repo.huaweicloud.com/openharmony/os/4.0-Release/code-v4.0-Release.tar.gz">https://gitee.com/link?target=https%3A%2F%2Frepo.huaweicloud.com%2Fopenharmony%2Fos%2F4.0-Release%2Fcode-v4.0-Release.tar.gz</a> 整个OpenHarmony全量代码工程进行熟悉开发</li></ul></li><li>但其社区移植工程都已经过时，不适配Harmony4.0 Release，编译无法通过，要想移植，只能自己摸索、熟悉GN+Ninja的构建方式，从头理顺开发过程<ul><li>此前已经做了一部分的工作，包括命令行开发环境搭建、各种依赖搭建，但没有系统地进行整理，可以说是个遗憾</li><li>另外感觉<strong>移植编译XTS子系统、通过兼容性测评</strong>这个时间周期会较长，而且是没有任何指导文档下的独立开发，本人对此预研项目持悲观态度，目前也不能把过多时间精力投入此处，且做且看吧！</li></ul></li></ul><hr><h3 id="记于2024-01-04"><a href="#记于2024-01-04" class="headerlink" title="记于2024-01-04"></a>记于2024-01-04</h3><ul><li>进展远超预期</li><li>截止今天已经完成了soc、board、vendor的移植适配工作，主要归功于华为云-连志安的博客，参考其对于GD32的移植范例及教程，快速地完成了国民技术的适配，包括底层驱动以及最简工程测试验证</li><li>不禁感叹，<strong>前期的文献检索调研</strong>是相当重要的</li><li>目前只剩下XTS子系统的编译链接，即可开始OpenHarmony兼容性测评认证工作</li><li>参照零星示例，尝试在vendor&#x2F;xxx&#x2F;config.json添加了xts子系统，同时在BUILD.gn添加链接选项，可看到xts组件有编译，但没链接进bin文件，对整个XTS子系统添加、编译链接流程思路还是不清晰，需要时间</li><li>捋清XTS添加核心步骤：生成相应的测试静态库、添加链接项或者修改链接脚本使得静态库能加入可执行文件、确保应用程序中有函数调用执行相关的测试操作</li></ul><hr><h3 id="记于2024-01-11"><a href="#记于2024-01-11" class="headerlink" title="记于2024-01-11"></a>记于2024-01-11</h3><ul><li>如果从习惯于集成开发环境之开发者角度来看，那OpenHarmony的轻量系统编译构建体系简直是一个大坑，复杂麻烦，相互依赖、嵌套调用关系多，需要熟悉的使用工具也多</li><li>而且在OpenHarmony-V不断迭代发布情况下，其内相应的配置工程范例却没有更新适配，编译一堆报错。依赖关系还得开发者自己解决</li><li>目前已经基于国民技术N32G452完成了内核子系统、部分子系统的适配，当然离通过兼容性测试还有一段距离</li></ul><h3 id="记于2024-03-04"><a href="#记于2024-03-04" class="headerlink" title="记于2024-03-04"></a>记于2024-03-04</h3><p>最终完成了生态认证，拿到证书，没啥用，只能说增长了嵌入式调试开发验证</p><hr><h2 id="轻量系统编译构建-命令执行简述"><a href="#轻量系统编译构建-命令执行简述" class="headerlink" title="轻量系统编译构建-命令执行简述"></a>轻量系统编译构建-命令执行简述</h2><h3 id="hb命令"><a href="#hb命令" class="headerlink" title="hb命令"></a>hb命令</h3><p>&emsp;&emsp;hb工具是一个命令行工具，其使用Python语言编写，能够调用gn和ninja工具来生成OpenHarmony的二进制文件。<br></p><ul><li>hb的源代码在<code>build/lite/hb</code>路径下，其入口函数为<code>__main__.py中的main()</code>，支持命令有：<code>set、env、build、clean</code></li><li><strong>hb命令的具体实现位于<code>//build/lite/hb_internal</code>中</strong></li></ul><h3 id="hb-set"><a href="#hb-set" class="headerlink" title="hb set"></a>hb set</h3><ul><li><code>hb set</code>的作用为生成产品配置文件，其会在工程根目录下生成ohos_config.json文件</li><li>执行<code>hb set</code>时，脚本会遍历<code>//vendor/$&#123;product_company&#125;/$&#123;product_name&#125;</code>目录下的<code>config.json</code>文件，给出可选的产品选项<blockquote><p>config.json文件中，product_name表示产品名，device_company和board用于关联出&#x2F;&#x2F;device&#x2F;board&#x2F;<device_company>&#x2F;<board>目录，匹配该目录下的<any_dir_name>&#x2F;config.gni文件<br>其中<any_dir_name>目录名可以是任意名称，但建议将其命名为适配内核名称（如：liteos_m、liteos_a、linux）<br>hb命令如果匹配到了多个config.gni，会将其中的kernel_type和kernel_version字段与vendor&#x2F;<device_company>下config.json文件中的字段进行匹配，从而确定参与编译的config.gni文件</p></blockquote></li></ul><h4 id="调用解决方案包Kconfig的具体步骤"><a href="#调用解决方案包Kconfig的具体步骤" class="headerlink" title="调用解决方案包Kconfig的具体步骤"></a>调用解决方案包Kconfig的具体步骤</h4><ul><li><code>hb set</code>根据配置项的名称找到对应的 Kconfig 配置项。</li><li>将配置项的值写入到 Kconfig 配置项的变量中。</li><li>系统在<code>//kernel/liteos_m</code>使用 make menuconfig 命令配置，结果保存于 <code>//vendor/$&#123;product_company&#125;/$&#123;product_name&#125;/kernel_configs/debug.config</code> 文件，其包含配置项的值。</li><li>编译时使用 gn 命令将 debug.config 文件中的配置项读取到 gn 文件中</li></ul><br><p><code>//kernel/liteos_m/Kconfig</code>文件片段如下：移植开发板适配时，需要在board和soc目录下，添加补充相应的Kconfig文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">orsource &quot;../../device/board/*/Kconfig.liteos_m.shields&quot;</span><br><span class="line">orsource &quot;../../device/board/$(BOARD_COMPANY)/Kconfig.liteos_m.defconfig.boards&quot;</span><br><span class="line">orsource &quot;../../device/board/$(BOARD_COMPANY)/Kconfig.liteos_m.boards&quot;</span><br><span class="line">orsource &quot;../../device/soc/*/Kconfig.liteos_m.defconfig&quot;</span><br><span class="line">orsource &quot;../../device/soc/*/Kconfig.liteos_m.series&quot;</span><br><span class="line">orsource &quot;../../device/soc/*/Kconfig.liteos_m.soc&quot;</span><br></pre></td></tr></table></figure><h3 id="hb-build-copy"><a href="#hb-build-copy" class="headerlink" title="hb build (copy)"></a>hb build (copy)</h3><ul><li>配置好产品解决方案、芯片开发板解决方案后，即可执行<code>hb set -&gt; hb build</code>进行编译</li><li>hb build的作用是根据配置信息生成编译指导文件build.ninja。</li><li>代码路径为：build&#x2F;lite&#x2F;hb&#x2F;build&#x2F;build.py<ul><li>调用 gn_build 使用 gn gen生成 *.ninja 文件</li><li>调用 ninja_build 使用 ninja -w dupbuild&#x3D;warn -C 生成 *.o *.so *.bin 等最后的文件</li></ul></li></ul><h3 id="build-lite-配置目录梳理"><a href="#build-lite-配置目录梳理" class="headerlink" title="build lite 配置目录梳理"></a>build lite 配置目录梳理</h3><p>复述自：<a href="https://bbs.huaweicloud.com/blogs/336722">https://bbs.huaweicloud.com/blogs/336722</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">build/lite</span><br><span class="line">├── components                  # 组件描述文件</span><br><span class="line">├── hb                          # hb pip安装包源码</span><br><span class="line">├── make_rootfs                 # 文件系统镜像制作脚本</span><br><span class="line">├── config                      # 编译配置项</span><br><span class="line">│   ├── component               # 组件相关的模板定义</span><br><span class="line">│   ├── kernel                  # 内核相关的编译配置</span><br><span class="line">│   └── subsystem               # 子系统编译配置</span><br><span class="line">├── platform                    # ld脚本</span><br><span class="line">├── testfwk                     # 测试编译框架</span><br><span class="line">└── toolchain                   # 编译工具链配置，包括：编译器路径、编译选项、链接选项等</span><br></pre></td></tr></table></figure><ul><li><p>build&#x2F;lite&#x2F;ohos_var.gni</p><ul><li>定义了所有部件的全局变量</li><li>用于读取产品解决方案的配置文件config.json中的配置项，解析为gn变量</li><li>被build\lite\config\BUILDCONFIG.gn包含导入import</li></ul></li><li><p>build\lite\config\BUILDCONFIG.gn</p><ul><li>用于配置编译构建，其会import导入产品解决方案和芯片开发板解决方案的配置文件</li><li>解析开发板配置文件config.gni</li></ul></li></ul><h2 id="LiteOS-M内核之GN编译构建流程总览"><a href="#LiteOS-M内核之GN编译构建流程总览" class="headerlink" title="LiteOS-M内核之GN编译构建流程总览"></a>LiteOS-M内核之GN编译构建流程总览</h2><p>编译构建过程参考：<a href="https://bbs.huaweicloud.com/blogs/336721">https://bbs.huaweicloud.com/blogs/336721</a></p><ul><li><code>hb build</code>-&gt;<code>build/lite/hb_internal/build/build.py</code></li><li>读取板子配置，包括编译工具链、编译链接选项等</li><li>读取的配置文件有：<ul><li><code>build/lite/ohos_var.gni</code>：定义应用于所有组件的全局变量</li><li><code>device/&#123;board&#125;/&#123;company&#125;/liteos_m/config.gni</code>：编译LiteOS-M内核的配置 – 需要前提配置好的芯片开发板解决方案</li><li><code>vendor/&#123;company&#125;/&#123;board&#125;/config.json</code>：板子所应用的全量配置表，包括子系统、组件等 – 需要提前配置好的产品解决方案</li></ul></li><li>调用gn gen命令，读取产品配置（板级配置、内核、组件等），生成out目录和ninja文件</li><li>调用<code>ninja -C out/&#123;company&#125;/&#123;product&#125;/</code>开始编译</li><li>打包、制作可执行文件<br></li></ul><p><strong><code>device/&#123;company&#125;/&#123;board&#125;/liteos_m/config.gni</code>文件</strong>：</p><ul><li>工程构建的全局配置文件，主要配置CPU型号、交叉编译工具链及全局编译、链接参数等信息</li><li>其内部分参数如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">board_opt_flags : 编译器相关选项，一般为芯片架构、浮点类型、编译调试优化等级等选项。</span><br><span class="line">board_asmflags  ：汇编编译选项，与Makefile中的ASFLAGS变量对应。</span><br><span class="line">board_cflags    ：C代码编译选项，与Makefile中的CFLAGS变量对应。</span><br><span class="line">board_cxx_flags ：C++代码编译选项，与Makefile中的CXXFLAGS变量对应。</span><br><span class="line">board_ld_flags  ：链接选项，与Makefile中的LDFLAGS变量对应。</span><br></pre></td></tr></table></figure></li></ul><hr><p>分析<code>build/lite/BUILD.gn</code>文件中<code>ohos</code>元目标如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">group(&quot;ohos&quot;) &#123;</span><br><span class="line">  deps = []</span><br><span class="line">  if (ohos_build_target == &quot;&quot;) &#123;</span><br><span class="line">    # Step 1: Read product configuration profile.</span><br><span class="line">    # 读取/vendor/&#123;company&#125;/&#123;board&#125;/config.json</span><br><span class="line">    product_cfg = read_file(&quot;$&#123;product_config_path&#125;/config.json&quot;, &quot;json&quot;)   </span><br><span class="line"></span><br><span class="line">    parts_targets_info = read_file(</span><br><span class="line">            &quot;$&#123;root_build_dir&#125;/build_configs/parts_info/parts_modules_info.json&quot;,</span><br><span class="line">            &quot;json&quot;)</span><br><span class="line"></span><br><span class="line">    # Step 2: Loop subsystems configured by product.</span><br><span class="line">    # 遍历板子的子系统配置</span><br><span class="line">    foreach(product_configed_subsystem, product_cfg.subsystems) &#123;</span><br><span class="line">      subsystem_name = product_configed_subsystem.subsystem</span><br><span class="line"></span><br><span class="line">      # 判断XTS子系统相关，暂未搞懂</span><br><span class="line">      if (build_xts || (!build_xts &amp;&amp; subsystem_name != &quot;xts&quot;)) &#123;</span><br><span class="line">        # Step 3: Read OS subsystems profile.</span><br><span class="line">        subsystem_parts_info = &#123;</span><br><span class="line">......&#125;&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="编译构建调用-适配过程"><a href="#编译构建调用-适配过程" class="headerlink" title="编译构建调用&#x2F;适配过程"></a>编译构建调用&#x2F;适配过程</h2><p>主要分为以下几部分：</p><ul><li><code>vendor/&#123;company&#125;/&#123;board&#125;/</code>–产品配置方案</li><li><code>device/soc/</code>–芯片解决方案</li><li><code>device/board/</code>–开发板解决方案</li><li><code>kernel/liteos_m</code>–轻量系统内核</li></ul><h2 id="产品解决方案代码"><a href="#产品解决方案代码" class="headerlink" title="产品解决方案代码"></a>产品解决方案代码</h2><p><strong>内核子系统适配：</strong></p><ul><li>在<code>//vendor/&#123;company&#125;/&#123;product&#125;/config.json</code>文件添加内核子系统及配置如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;subsystems&quot;: [ </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;subsystem&quot;: &quot;kernel&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;component&quot;: &quot;liteos_m&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ul><h2 id="芯片解决方案代码"><a href="#芯片解决方案代码" class="headerlink" title="芯片解决方案代码"></a>芯片解决方案代码</h2><h2 id="硬件板解决方案代码"><a href="#硬件板解决方案代码" class="headerlink" title="硬件板解决方案代码"></a>硬件板解决方案代码</h2><p><strong><code>target_config.h</code>文件适配</strong>:</p><ul><li>在<code>//kernel/liteos_m/kernel/include/los_config.h</code>文件中，有包含一个名为target_config.h的头文件，如果没有这个头文件，则会编译出错</li><li>该头文件主要定义一些与soc芯片相关的宏定义，可参考其它解决方案的target_config.h配置即可，或者可以根据编译错误提示进行添加或者删减</li><li>在何处添加该头文件由用户决定，建议是存放于<code>//device/board/$&#123;company_product&#125;</code>目录下</li><li>而后在<code>device/&#123;board&#125;/&#123;company&#125;/&#123;company_board&#125;/liteos_m/config.gni</code>添加该头文件的路径包含即可</li><li>配置系统时钟、系统节拍<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define OS_SYS_CLOCK                                        SystemCoreClock   // SystemCoreClock为N32G452库的宏定义，具体可由用户设定，如72000000</span><br><span class="line">#define LOSCFG_BASE_CORE_TICK_PER_SECOND                    (1000UL)</span><br></pre></td></tr></table></figure></li></ul><p><strong>适配printf打印函数</strong>:<br>此处不过多赘述，用户自行实现重定向<code>int printf(char const  *fmt, ...)</code>函数即可<br><br></p><h2 id="子系统适配"><a href="#子系统适配" class="headerlink" title="子系统适配"></a>子系统适配</h2><h3 id="OpenHarmony全量仓工程目录解析"><a href="#OpenHarmony全量仓工程目录解析" class="headerlink" title="OpenHarmony全量仓工程目录解析"></a>OpenHarmony全量仓工程目录解析</h3><p>建议大致了解整个工程目录框架</p><h3 id="启动恢复子系统适配"><a href="#启动恢复子系统适配" class="headerlink" title="启动恢复子系统适配"></a>启动恢复子系统适配</h3><p>大致思路如下：<br></p><p>对于Cortex-M内核来说，要适配此启动恢复子系统，实际上是要有完成两个工程的适配，分别是bootloader、app</p><ul><li>bootloader是个相对独立的工程，其包含芯片启动.S文件、system_xxx.c文件、main()函数几部分，主要作用就是完成应用程序升级功能。当然，前期适配过程中，只需要在初始化系统时钟，配置必要外设，然后<strong>直接设置app应用程序的栈顶指针，跳转至app程序段开始即可</strong></li><li>app是独立的应用程序工程，此部分同样包含启动.S文件、等等相应部分</li><li>芯片上电先跑bootloader，然后跳转到app</li><li>当然，上述工程文件基本位于<code>//device/board/&#123;company&#125;/&#123;company_board&#125;</code>下，具体如何构建由开发者决定</li><li>最后需要通过 <strong><code>merge_bin</code></strong> 将两个bin文件合并成最终的烧录bin文件</li></ul><br>在`//vendor/{company}/{product}/config.json`新增对应配置选项<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;subsystem&quot;: &quot;startup&quot;,</span><br><span class="line">      &quot;components&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;component&quot;: &quot;bootstrap_lite&quot;,</span><br><span class="line">          &quot;features&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;component&quot;: &quot;syspara_lite&quot;,</span><br><span class="line">          &quot;features&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外，bootstrap_lite部件需要在`//device/board/{company}/{board}/xxx.ld`链接脚本添加相关的段 -- 关键词：**灌段**<h3 id="DFX子系统适配"><a href="#DFX子系统适配" class="headerlink" title="DFX子系统适配"></a>DFX子系统适配</h3><p>其是一个提升软件质量设计的工具集，主要包含两部分内容：</p><ul><li>DFR（可靠性）：提供流水日志、故障分析等功能</li><li>DFT（可测试性）：提供测试桩、桩机、测试工具等功能</li></ul><h2 id="移植思路总结"><a href="#移植思路总结" class="headerlink" title="移植思路总结"></a>移植思路总结</h2><p>此部分内容直接转述自参考文章：<a href="https://developer.huawei.com/consumer/cn/blog/topic/03889745165640019">https://developer.huawei.com/consumer/cn/blog/topic/03889745165640019</a></p><p>移植类型可以分为三部分：ARCH、SoC、Board</p><ul><li>ARCH为架构级别移植，代码位于kernel&#x2F;liteos_m&#x2F;arch</li><li>SoC为对已支持的架构做芯片厂商级的移植，代码位于device&#x2F;soc</li><li>Board为对芯片下不同板子的移植，代码位于device&#x2F;board</li><li>另，还有厂商配置相关代码，位于vendor，其主要用于编译系统、HDF配置(驱动框架的配置描述文件)：用于描述驱动程序的硬件资源、功能特性，使用Key-Value格式-由属性节点与子节点组成</li></ul><p>移植路线：**&#x2F;&#x2F;vendor -&gt; &#x2F;&#x2F;device&#x2F;board -&gt; &#x2F;&#x2F;device&#x2F;soc -&gt; ARCH**</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/336721">移植案例与原理 - build lite编译构建过程</a></li><li><a href="https://bbs.huaweicloud.com/blogs/336722">移植案例与原理 - build lite配置目录全梳理</a></li><li><a href="https://developer.huawei.com/consumer/cn/blog/topic/03893164050570049">从零开始移植OpenHarmony轻量系统</a></li><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/porting-stm32f407-on-minisystem-eth.md">轻量系统STM32F407芯片移植案例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenHarmony </category>
          
          <category> LiteOS </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【构建】GN和Ninja构建工具的基础入门、进阶和应用开发</title>
      <link href="/2023/12/24/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91GN%E5%92%8Cninja%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB%E5%92%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/12/24/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91GN%E5%92%8Cninja%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E8%81%94%E7%B3%BB%E5%92%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<ul><li>本文是个人对GN文件的理解，可能知识体系上有些凌乱分散，与官方表述上有些许出入</li><li>文章主要为谈及GN文件的常见重要概念，并基于此引申出代码示例及解释</li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>GN文件使用GN语言编写，其是一种基于脚本的语言，用于定义构建系统的规则和目标</p><ul><li>gn即Generate ninja，gn与ninja的关系 类似于 cmake与make</li><li>GN文件可以用于构建各种类型的项目，包括C++、Java、Python项目<br></li></ul><p>ninja用于执行GN文件定义的规则和目标，其是一个C++编写的构建工具，可以生成高效的构建命令，提高构建速度<br><br></p><h2 id="基本概念与语法"><a href="#基本概念与语法" class="headerlink" title="基本概念与语法"></a>基本概念与语法</h2><p>.gn是源文件，.gni是头文件，源文件可通过import引用头文件，也可使用import导入源文件</p><blockquote><p>如：<code>import(&quot;//build/config/c++/c++.gni&quot;)</code><br><br></p></blockquote><p>GN的基本概念包括：<strong>变量、函数、目标、规则、配置项、模块</strong></p><ul><li>变量：用于存储值</li><li>函数：用于执行操作</li><li>目标：用于表示构建过程中的某个对象，例如文件、库或可执行文件；<strong>目标是GN构建系统的基本单位</strong></li><li>规则：用于定义目标的构建方式</li><li>配置项：用于控制构建过程的行为</li><li>模块：一种组织和管理代码的方式，可以包含变量、函数、目标、规则等，便于模块化地管理和复用构建配置</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>GN中的变量可以使用set_default_variable()函数进行定义。变量的值可以是字符串、数字、布尔值或列表</p><ul><li>变量可以存储构建过程中使用的常量值，如 参数、目标类型、选项</li><li>如<code>set_default_variable(&quot;target_os&quot;, &quot;linux&quot;)</code>，设置操作系统为linux</li></ul><br><p><strong>内置变量：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target_os：当前目标的操作系统</span><br><span class="line">target_cpu：当前目标的处理器架构</span><br><span class="line">target_toolchain：当前目标的工具链</span><br><span class="line">target_out_dir：当前目标的输出目录，默认值是//out/target_name/</span><br><span class="line">target_gen_dir：当前目标的生成目录</span><br><span class="line">root_build_dir：构建系统的根目录</span><br><span class="line">buildconfig：构建系统的配置文件</span><br></pre></td></tr></table></figure><br><p><strong>变量类型：数字、字符串、布尔值、列表、映射</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = &quot;Hello, world!&quot;</span><br><span class="line">y = 10</span><br><span class="line">z = true</span><br><span class="line"></span><br><span class="line">// 定义一个名为 list 的列表变量</span><br><span class="line">list = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</span><br><span class="line"></span><br><span class="line">// 定义一个名为 map 的映射变量</span><br><span class="line">map = &#123;</span><br><span class="line">&quot;key1&quot; = &quot;value1&quot;,</span><br><span class="line">&quot;key2&quot; = &quot;value2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong><code>$&#123;&#125;</code>–字符串插值操作符用于在字符串中插入变量、表达式或函数调用的值，如：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line">println(&quot;The value of x is $&#123;x&#125;&quot;)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>GN的函数形式与C语言的类似，由函数名、参数列表和函数体组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function_name(parameter_list) &#123;</span><br><span class="line">// 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以使用内置函数或自定义函数</p><p>内置函数包括有如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assert()：断言函数，如果条件不成立，则抛出异常</span><br><span class="line">concat()：字符串拼接函数</span><br><span class="line">defined()：判断变量是否定义了的函数</span><br><span class="line">dirname()：获取目录名的函数</span><br><span class="line">file()：获取文件名的函数</span><br><span class="line">join()：字符串连接函数</span><br><span class="line">path()：获取路径名的函数</span><br><span class="line">read_file()：读取文件的函数</span><br><span class="line">write_file()：写入文件的函数</span><br></pre></td></tr></table></figure><br><p><strong>其中，read_file()示例如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># config.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;product_name&quot;: &quot;My Product&quot;,</span><br><span class="line">&quot;product_version&quot;: &quot;1.0.0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># 读取product_config_path目录下的config.json文件，并将其内容以JSON格式返回</span><br><span class="line">product_cfg = read_file(&quot;$&#123;product_config_path&#125;/config.json&quot;, &quot;json&quot;)</span><br><span class="line"></span><br><span class="line"># 将product_name属性的值赋值给变量product_name</span><br><span class="line">product_name = product_cfg[&quot;product_name&quot;]</span><br></pre></td></tr></table></figure><br><p>用户自定义函数以及调用，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a.gn</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">// b.gn</span><br><span class="line">import(&quot;a.gn&quot;)</span><br><span class="line"></span><br><span class="line">println(&quot;The sum of 1 and 2 is $&#123;add(1, 2)&#125;&quot;)</span><br></pre></td></tr></table></figure><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>目标是构建系统要生成的文件或目录，其可以是可执行文件、库、源代码文件、文档等</p><ul><li>BUILD.gn是GN构建系统默认使用的文件名</li><li>目标使用<code>target()</code>语句定义，语法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(target_name) &#123;</span><br><span class="line">// 目标配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><p>目标名称必须唯一，可以有以下属性配置项定义：deps-依赖关系、type-目标类型、output-目标输出、public-目标是否公开、configs-目标配置</p><ul><li>子目标可以使用deps属性指定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(&quot;my_executable&quot;) &#123;</span><br><span class="line">type = &quot;executable&quot;       // 指定目标类型为可执行文件</span><br><span class="line">sources = [&quot;main.cc&quot;]     // 指定目标所需要的源文件列表</span><br><span class="line">deps = [&quot;my_library&quot;]     // 依赖关系，系统先构建此子目标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><p>GN目标可以使用<code>build</code>命令构建</p><ul><li>如：在当前路径下有BUILD.gn文件，其定义了名为<code>my_executable</code>的目标</li><li>则在命令行输入<code>gn build my_executable</code>表示构建该目标</li><li><code>gn build</code>表示构建所有目标</li><li><code>gn build my_executable:my_sub</code>表示构建目标的子目标my_sub</li></ul><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>配置项用于配置GN构建系统的行为，其可以控制：构建目标的类型和输出、构建规则的行为、构建系统的环境</p><ul><li>其可以分为：<strong>目标配置项、规则配置项、环境配置项</strong></li><li>其与目标的联系为：配置项用于定义目标的行为，<strong>目标的配置项可以定义在目标的gn配置文件中</strong><br></li></ul><p>常用的配置项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target_type：定义目标的类型</span><br><span class="line">output：定义目标的输出</span><br><span class="line">deps：定义目标的依赖关系</span><br><span class="line">public：定义目标是否公开</span><br><span class="line">configs：定义目标的配置</span><br><span class="line">rule_type：定义规则的类型</span><br><span class="line">deps：定义规则的依赖关系</span><br><span class="line">inputs：定义规则的输入</span><br><span class="line">outputs：定义规则的输出</span><br><span class="line">action：定义规则的操作</span><br><span class="line">script：定义规则的脚本</span><br><span class="line">args：定义规则的参数</span><br><span class="line">vars：定义规则的变量</span><br></pre></td></tr></table></figure><p><code>config()</code>函数用于创建配置，其可以指定<strong>配置名称、编译选项、链接选项、依赖关系、宏定义、头文件目录、公开的配置、可见性</strong>等<br></p><p>代码应用示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config(name) &#123;</span><br><span class="line">  options = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config(&quot;my_config&quot;) &#123;</span><br><span class="line">  cflags = [&quot;-Wall&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 将 my_config 配置应用于 my_target 目标</span><br><span class="line">executable(&quot;my_target&quot;) &#123;</span><br><span class="line">  configs = [&quot;my_config&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>GN中的规则可以使用rule()函数进行定义。规则可以指定以下属性：</p><ul><li>inputs：规则需要的输入文件。</li><li>outputs：规则的输出文件。</li><li>action：规则执行的操作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rule(&quot;my_rule&quot;) &#123;</span><br><span class="line">inputs = [&quot;input.txt&quot;]</span><br><span class="line">outputs = [&quot;output.txt&quot;]</span><br><span class="line">action = &quot;echo &#x27;Hello, world!&#x27; &gt; $out&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块可以是任何类型的代码，其可以包含源文件、头文件、库文件等，GN使用模块来组织代码和构建文件。</p><ul><li>如：一个模块可以包含一个应用程序的所有源文件，另一个模块可以包含一个库的所有源文件<br></li></ul><p>GN可使用模块来表示构建过程中的依赖关系</p><ul><li>如：一个模块可以依赖另一个模块的源文件或者库文件<br></li></ul><p>GN中的模块可以分为几种类型：<strong>executable(可执行文件)、library(库文件)、test(测试文件)、group(组模块)、action(动作模块)</strong></p><ul><li>模块可以应用在GN构建系统的任何地方，包括但不限于组织代码、表示依赖关系、执行操作等</li><li>以下示例创建了一个名为my_module的模块，其包含源文件my_module.c，而后创建了一个名为my_executable的可执行文件，其依赖my_module模块<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module(&quot;my_module&quot;) &#123;</span><br><span class="line">  sources = [&quot;my_module.c&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;my_executable&quot;) &#123;</span><br><span class="line">  sources = [&quot;my_executable.c&quot;]</span><br><span class="line">  deps = [&quot;:my_module&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><p>kernel_module() 函数用于创建内核模块。内核模块是运行在操作系统内核中的模块。<br>module() 函数用于创建普通模块。普通模块可以运行在操作系统内核中，也可以运行在操作系统用户空间中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kernel_module(name) &#123;</span><br><span class="line">  sources = []</span><br><span class="line">  deps = []</span><br><span class="line">  ldflags = []</span><br><span class="line">  cflags = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module(name) &#123;</span><br><span class="line">  sources = []</span><br><span class="line">  deps = []</span><br><span class="line">  ldflags = []</span><br><span class="line">  cflags = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>注释：在注释句子的行首加上<code>#</code>即可</p></li><li><p>条件语句</p></li><li><p>循环语句</p></li></ul><h2 id="应用实践范例"><a href="#应用实践范例" class="headerlink" title="应用实践范例"></a>应用实践范例</h2><p>在构建项目时，GN会首先解析GN文件，并将工程的根目录作为起点，开始构建项目</p><ul><li>目录路径中<code>//xxx/xxx/xxx</code>中双斜杠表示工程源码的根</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rule my_rule &#123;</span><br><span class="line"># 定义规则的输入</span><br><span class="line">input: &quot;input.cpp&quot;</span><br><span class="line"># 定义规则的输出</span><br><span class="line">output: &quot;output.o&quot;</span><br><span class="line"></span><br><span class="line"># 定义规则的执行逻辑</span><br><span class="line">action &#123;</span><br><span class="line">    command: &quot;gcc -c input.cpp -o output.o&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GN进阶操作"><a href="#GN进阶操作" class="headerlink" title="GN进阶操作"></a>GN进阶操作</h2><h3 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h3><ul><li>模板是用于重复使用代码的工具。模板可以用于创建目标、配置、或其他 GN 对象</li><li>自定义模板使用<code>template()</code>语句<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template(name) &#123;</span><br><span class="line">  options = []</span><br><span class="line">  output = &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>template() 函数的输出是模板的配置<br></li></ul><p>代码应用示例如下：</p><ul><li>名为 my_executable 的可执行文件，其使用 my_template 模板，包含其模板的所有配置（源文件、依赖）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template(&quot;my_template&quot;) &#123;</span><br><span class="line">  sources = [&quot;my_template.c&quot;]</span><br><span class="line">  deps = [&quot;:my_module&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;my_executable&quot;) &#123;</span><br><span class="line">  sources = [&quot;my_executable.c&quot;]</span><br><span class="line">  template = &quot;:my_template&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="group元目标"><a href="#group元目标" class="headerlink" title="group元目标"></a>group元目标</h3><p>group不是目标，目标是指可以生成可执行文件、库文件或其它产物的构建单元。<br><br>group是gn工具提供的一种元目标，其可以用于组织其它目标，但它本身并不生成任何产物。<br></p><p><strong>其用途包括：</strong></p><ul><li>组织具有相同功能或目的的目标：例如，可以将所有驱动程序目标组织到一个group中，将所有库文件目标组织到另一个group中</li><li>定义依赖关系：例如，可以将一个group定义为另一个group的依赖，这样，如果第一个group中的任何一个目标被编译，则第二个group中的所有目标也会被编译</li><li>提供文档：group可以包含文档，这些文档将在gn工具生成的输出中显示。</li></ul><p><strong>一个应用示例如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">group(&quot;drivers&quot;) &#123;</span><br><span class="line">  deps = [</span><br><span class="line">    &quot;//drivers/usb/host&quot;,</span><br><span class="line">    &quot;//drivers/ethernet&quot;,</span><br><span class="line">    &quot;//drivers/storage&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group(&quot;libraries&quot;) &#123;</span><br><span class="line">  deps = [</span><br><span class="line">    &quot;//libraries/lib1&quot;,</span><br><span class="line">    &quot;//libraries/lib2&quot;,</span><br><span class="line">    &quot;//libraries/lib3&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码定义了两个group，drivers目标依赖于&#x2F;&#x2F;drivers&#x2F;usb&#x2F;host、&#x2F;&#x2F;drivers&#x2F;ethernet和&#x2F;&#x2F;drivers&#x2F;storage三个目标。libraries目标依赖于&#x2F;&#x2F;libraries&#x2F;lib1、&#x2F;&#x2F;libraries&#x2F;lib2和&#x2F;&#x2F;libraries&#x2F;lib3三个目标</li><li>在gn工具生成的输出中，drivers和libraries两个group将显示为一个单独的目标</li></ul><h2 id="补充说明以及疑惑解答"><a href="#补充说明以及疑惑解答" class="headerlink" title="补充说明以及疑惑解答"></a>补充说明以及疑惑解答</h2><h3 id="config-“public”-的应用"><a href="#config-“public”-的应用" class="headerlink" title="config(“public”)的应用"></a>config(“public”)的应用</h3><p>在gn文件中，如果多个文件都定义了config(“public”)的include_dirs属性，那么它们的这个属性值将会叠加，而不是互相覆盖<br><br></p><p>config(“public”)是一个用来定义公共配置的语法。公共配置可以被其他模块引用，以便共享相同的设置</p><ul><li>当然，config(“public”)并不表示其一定是整个工程公开的，其需要配置，可以通过configs属性来引用</li><li>如果一个模块的configs属性中包含了config(“public”)，则其会继承config(“public”)的所有设置，并且该模块的设置将会公开可见</li><li>通常做法为：在GN文件中包含统一的头文件，而后在此头文件中包含config(“public”)属性</li></ul><h3 id="GN文件中如何包含工程源码的头文件路径？"><a href="#GN文件中如何包含工程源码的头文件路径？" class="headerlink" title="GN文件中如何包含工程源码的头文件路径？"></a>GN文件中如何包含工程源码的头文件路径？</h3><p>可以使用<code>include_dirs</code>属性指定C头文件的路径，此属性是一个列表，代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(&quot;my_executable&quot;) &#123;</span><br><span class="line">type = &quot;executable&quot;</span><br><span class="line">sources = [&quot;main.c&quot;]</span><br><span class="line">include_dirs = [&quot;/usr/include/my_headers&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可使用<code>public_configs</code>属性，此属性列表包含了<code>include_dirs</code>属性的配置</p><ul><li>以下代码示例，指示构建系统在<code>//configs:my_config</code>配置中搜索<code>include_dirs</code>配置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(&quot;my_executable&quot;) &#123;</span><br><span class="line">type = &quot;executable&quot;</span><br><span class="line">sources = [&quot;main.c&quot;]</span><br><span class="line">public_configs = [&quot;//configs:my_config&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>include_dirs</code>属性应用示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 指定一个目录：</span><br><span class="line">include_dirs = [&quot;/usr/include/my_headers&quot;]</span><br><span class="line">// 指定多个目录：</span><br><span class="line">include_dirs = [&quot;/usr/include/my_headers&quot;, &quot;/usr/include/other_headers&quot;]</span><br><span class="line">// 指定相对路径：</span><br><span class="line">include_dirs = [&quot;../include&quot;]</span><br><span class="line">// 指定通配符：</span><br><span class="line">include_dirs = [&quot;**/*.h&quot;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://bbs.huaweicloud.com/blogs/382860">[gn+ninja学习 0x01]gn和ninja是什么</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenHarmony </category>
          
          <category> LiteOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】嵌入式自动初始化</title>
      <link href="/2023/12/22/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/12/22/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="普通驱动初始化方式"><a href="#普通驱动初始化方式" class="headerlink" title="普通驱动初始化方式"></a>普通驱动初始化方式</h3><p>常见的编写方式为 每个模块在其文件内部编写初始化函数实例，然后通过头文件导出初始化函数接口；主任务包含各模块的头文件，然后逐一调用其初始化函数<br></p><p>这种初始化操作有以下特点：</p><ul><li>显式的初始化调用较为直观，可以清楚地掌握程序的初始化流程顺序</li><li>头文件处理繁琐、不利于模块间的解耦合</li><li>编码难度较低</li></ul><h3 id="自动初始化方式"><a href="#自动初始化方式" class="headerlink" title="自动初始化方式"></a>自动初始化方式</h3><p>与常用初始化相对的即是隐式初始化，隐式初始化不用暴露模块的初始化接口，可以更好地解耦合。<br></p><p>但相对应的，其初始化函数的调用、以及执行顺序不好把握<br></p><p>另外，这种隐式的声明给审阅代码、移植工程也带来一定不便，开发者需要花费时间掌握工程的隐式初始化接口。<br></p><h4 id="Linux下的驱动初始化"><a href="#Linux下的驱动初始化" class="headerlink" title="Linux下的驱动初始化"></a>Linux下的驱动初始化</h4><p>Linux使用<strong>模块机制</strong>来实现驱动程序的自动初始化<br></p><ul><li>模块是Linux内核中的一个可加载组件，其可以包含驱动程序、函数库或其它代码</li><li>驱动程序模块加载到内核中时，内核会调用其初始化函数执行初始化工作，如：注册驱动程序的设备节点、初始化驱动程序的资源等<br></li></ul><p>Linux提供了两个宏：<code>module_init()</code>、<code>module_exit()</code>分别用于注册驱动程序的初始化和卸载函数</p><ul><li>如<code>module_init(init_function);</code></li><li>如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int __init my_driver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 完成驱动程序的初始化工作</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">module_init(my_driver_init);</span><br></pre></td></tr></table></figure></li><li><code>module_init()</code><strong>宏将驱动初始化函数的地址存储到一个全局变量中</strong></li><li>内核启动时会调用<code>kernel_init()-&gt;init_module()-&gt;遍历执行所有通过module_init()注册的初始化函数</code></li></ul><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><ul><li><code>__attribute__((used))</code>是一个函数属性，其告诉编译器保留函数在目标文件中，即使其没被调用</li><li><code>__attribute__((section(&quot;name&quot;)))</code>属性用于将变量或函数放置在指定的段</li></ul><h2 id="Keil环境下的自动初始化"><a href="#Keil环境下的自动初始化" class="headerlink" title="Keil环境下的自动初始化"></a>Keil环境下的自动初始化</h2><ul><li><p>Keil的 ARM链接器会生成用于标识段首末地址的变量，如<code>initcall0init$$Base</code>为段名<code>initcall0init</code>的首地址；<code>initcall0init$$Limit</code>表示末地址</p></li><li><p>段的声明会将函数指针存储在输出文件的Data段中，属性为RO只读</p></li></ul><p><strong>应用代码示例如下：</strong></p><ul><li>以下为实现自动初始化的头文件<ul><li><code>act_auto_initialize()</code>是用以实现自动初始化的调用</li><li>4个宏定义是对需要被调用的函数指针定义了4个显式执行次序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define  __used  __attribute__((__used__))</span><br><span class="line"></span><br><span class="line">typedef void (*initcall_t)(void);</span><br><span class="line"></span><br><span class="line">#define __define_initcall(fn, id) \</span><br><span class="line">    static const initcall_t __initcall_##fn##id __used \</span><br><span class="line">    __attribute__((__section__(&quot;initcall&quot; #id &quot;init&quot;))) = fn; </span><br><span class="line"></span><br><span class="line">#define INIT_SYSTEM_EXPORT(fn)      __define_initcall(fn, 0)</span><br><span class="line">#define INIT_BOARD_EXPORT(fn)       __define_initcall(fn, 1)</span><br><span class="line">#define INIT_DEVICE_EXPORT(fn)      __define_initcall(fn, 2)</span><br><span class="line">#define INIT_APP_EXPORT(fn)         __define_initcall(fn, 3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void act_auto_initialize(void);</span><br></pre></td></tr></table></figure></li></ul></li><li>以下为自动初始化的实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void act_auto_initialize(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern initcall_t initcall0init$$Base[];</span><br><span class="line">    extern initcall_t initcall0init$$Limit[];</span><br><span class="line">    extern initcall_t initcall1init$$Base[];</span><br><span class="line">    extern initcall_t initcall1init$$Limit[];</span><br><span class="line">    extern initcall_t initcall2init$$Base[];</span><br><span class="line">    extern initcall_t initcall2init$$Limit[];</span><br><span class="line">    extern initcall_t initcall3init$$Base[];</span><br><span class="line">    extern initcall_t initcall3init$$Limit[];</span><br><span class="line">    </span><br><span class="line">    initcall_t *fn;</span><br><span class="line">    </span><br><span class="line">    for (fn = initcall0init$$Base;</span><br><span class="line">            fn &lt; initcall0init$$Limit;</span><br><span class="line">            fn++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(fn)</span><br><span class="line">            (*fn)();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (fn = initcall1init$$Base;</span><br><span class="line">            fn &lt; initcall1init$$Limit;</span><br><span class="line">            fn++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(fn)</span><br><span class="line">            (*fn)();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (fn = initcall2init$$Base;</span><br><span class="line">            fn &lt; initcall2init$$Limit;</span><br><span class="line">            fn++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(fn)</span><br><span class="line">            (*fn)();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (fn = initcall3init$$Base;</span><br><span class="line">            fn &lt; initcall3init$$Limit;</span><br><span class="line">            fn++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(fn)</span><br><span class="line">            (*fn)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="适用于GCC环境下的自动初始化"><a href="#适用于GCC环境下的自动初始化" class="headerlink" title="适用于GCC环境下的自动初始化"></a>适用于GCC环境下的自动初始化</h2><p>GCC环境下，可以采用事先定义两个静态函数的段，将需要初始化的函数指针声明到这个段的中间，通过执行两个静态函数地址之间的所有函数指针即可。<br></p><p><strong>以下源码示例片段摘选自rt-thread：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#define SECTION(x)                  __attribute__((section(x)))</span><br><span class="line">typedef int (*init_fn_t)(void);</span><br><span class="line">#define INIT_EXPORT(fn, level)                                                       \</span><br><span class="line">    RT_USED const init_fn_t __rt_init_##fn SECTION(&quot;.rti_fn.&quot; level) = fn      // 定义一个函数指针常量，并声明到指定的段名中</span><br><span class="line"></span><br><span class="line">static int rti_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_start, &quot;0&quot;);</span><br><span class="line">static int rti_board_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_board_start, &quot;0.end&quot;);</span><br><span class="line">static int rti_board_end(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_board_end, &quot;1.end&quot;);</span><br><span class="line">static int rti_end(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">INIT_EXPORT(rti_end, &quot;6.end&quot;);</span><br><span class="line"></span><br><span class="line">// 系统在初始化时调用此函数</span><br><span class="line">void rt_components_init(void)  </span><br><span class="line">&#123;</span><br><span class="line">  volatile const init_fn_t *fn_ptr;</span><br><span class="line"></span><br><span class="line">  for (fn_ptr = &amp;__rt_init_rti_board_start; fn_ptr &lt; &amp;__rt_init_rti_board_end; fn_ptr++)</span><br><span class="line">  &#123;</span><br><span class="line">      (*fn_ptr)();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  volatile const init_fn_t *fn_ptr;</span><br><span class="line"></span><br><span class="line">  for (fn_ptr = &amp;__rt_init_rti_board_start; fn_ptr &lt; &amp;__rt_init_rti_board_end; fn_ptr++)</span><br><span class="line">  &#123;</span><br><span class="line">      (*fn_ptr)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以下为初始化函数应用接口，宏定义声明传入函数指针(函数名)即可：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, &quot;1&quot;)</span><br><span class="line">#define INIT_PREV_EXPORT(fn)            INIT_EXPORT(fn, &quot;2&quot;)</span><br><span class="line">#define INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, &quot;3&quot;)</span><br><span class="line">#define INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, &quot;4&quot;)</span><br><span class="line">#define INIT_ENV_EXPORT(fn)             INIT_EXPORT(fn, &quot;5&quot;)</span><br><span class="line">#define INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, &quot;6&quot;)</span><br><span class="line"></span><br><span class="line">//应用示例</span><br><span class="line">void function_need_to_init(void)</span><br><span class="line">&#123;</span><br><span class="line">  // xxx</span><br><span class="line">&#125;</span><br><span class="line">INIT_BOARD_EXPORT(function_need_to_init);</span><br></pre></td></tr></table></figure><br><h2 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h2><p><strong>不同的段名在内存映射中的排序：</strong></p><ul><li>通常，map文件中的段是按照首字母顺序排序的</li><li>另，依照rt-thread方式所编译生成<code>.map</code>文件的段排序如下，供参考：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.rti_fn.0                                0x08018e6c   Section        4  components.o(.rti_fn.0)</span><br><span class="line">__tagsym$$used                           0x08018e6c   Number         0  components.o(.rti_fn.0)</span><br><span class="line">.rti_fn.0.end                            0x08018e70   Section        4  components.o(.rti_fn.0.end)</span><br><span class="line">__tagsym$$used                           0x08018e70   Number         0  components.o(.rti_fn.0.end)</span><br><span class="line">.rti_fn.1                                0x08018e74   Section        4  user_board_interface.o(.rti_fn.1)</span><br><span class="line">__tagsym$$used                           0x08018e74   Number         0  user_board_interface.o(.rti_fn.1)</span><br><span class="line">.rti_fn.1.end                            0x08018e78   Section        4  components.o(.rti_fn.1.end)</span><br><span class="line">__tagsym$$used                           0x08018e78   Number         0  components.o(.rti_fn.1.end)</span><br><span class="line">.rti_fn.6                                0x08018e7c   Section        4  shell.o(.rti_fn.6)</span><br><span class="line">__tagsym$$used                           0x08018e7c   Number         0  shell.o(.rti_fn.6)</span><br><span class="line">.rti_fn.6.end                            0x08018e80   Section        4  components.o(.rti_fn.6.end)</span><br></pre></td></tr></table></figure><br></li></ul><p><strong>初始化函数指针声明在同一个段中的顺序：</strong></p><ul><li>实际上，此种自动初始化是函数指针的段声明，本质上是变量的声明</li><li>同一源文件中，其声明顺序按照它们在源代码中的布局顺序进行排列</li><li>不同源文件中，为按照源文件的顺序<ul><li>编译时可以使用<code>-M</code>选项，生成包含目标文件依赖关系的文件，通过该本文可以查看源文件顺序</li><li>另外，可以通过<code>.map</code>文件查看段的声明顺序，从而知道初始化顺序<br></li></ul></li></ul><p><strong>编译选项之 函数分段 对初始化顺序的影响：</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用小贴士</title>
      <link href="/2023/12/21/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
      <url>/2023/12/21/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令表"><a href="#常用命令表" class="headerlink" title="常用命令表"></a>常用命令表</h2><table><thead><tr><th>命令名称</th><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>克隆工程</td><td>git clone xxx</td><td>xxx为克隆链接</td></tr><tr><td>暂存文件修改、删除</td><td>git add -u</td><td>暂存文件修改、删除</td></tr><tr><td>暂存文件修改、新建</td><td>git add .</td><td>暂存文件修改、新建</td></tr><tr><td>暂存文件修改、删除、新建</td><td>git add -A</td><td>暂存文件修改、删除、新建</td></tr><tr><td>暂存文件</td><td>git add xxx</td><td>xxx可为目录、文件，为.时暂存所有</td></tr><tr><td>取消所有已暂存文件</td><td>git reset HEAD .</td><td>放弃所有暂存，不会取消修改</td></tr><tr><td>取消指定文件的暂存</td><td>git reset HEAD filepathname</td><td>放弃指定文件的暂存</td></tr><tr><td>放弃未暂存的指定文件的修改</td><td>git checkout – filepathname</td><td>放弃未暂存的文件修改</td></tr><tr><td>放弃未暂存的文件修改</td><td>git checkout .</td><td>不会删除新建的，未被git跟踪的文件</td></tr><tr><td>显示将要被删除的文件</td><td>git clean -n</td><td>显示将要被删除的文件</td></tr><tr><td>删除工作区新增的文件、文件夹</td><td>git clean -df</td><td>删除新增的文件和新增的文件夹</td></tr><tr><td>删除工作区新增的文件</td><td>git clean -f</td><td>删除当前目录下所有没被track过的文件，.gitignore指定的文件和文件夹不会被删除</td></tr><tr><td>提交</td><td>git commit -m “xxxxx”</td><td>xxx为备注信息</td></tr><tr><td>查看修改的地方</td><td>git diff xxx</td><td>查看修改的地方</td></tr><tr><td>查看工作区、暂存区</td><td>git status</td><td>查看工作区、暂存区</td></tr><tr><td>拉取</td><td>git pull</td><td>在主目录下操作</td></tr><tr><td>合并分支</td><td>git merge dev</td><td>把dev分支合并到当前分支</td></tr><tr><td>合并目标分支的指定文件</td><td>git merge dev –no-ff filepathname</td><td>合并目标分支的指定文件</td></tr><tr><td>推送</td><td>git push</td><td>推送</td></tr><tr><td>强制推送</td><td>git push -f origin master</td><td>适用于本地回退版本后修改推送，master为分支名</td></tr><tr><td>更新远程分支列表</td><td>git remote update origin –prune</td><td>与远程保持同步</td></tr><tr><td>更新子模块</td><td>git submodule update –init</td><td>首次后可不带–init</td></tr><tr><td>切换到某一本地分支</td><td>git checkout dev</td><td>dev为分支名</td></tr><tr><td>查看本地分支</td><td>git branch</td><td>查看本地分支</td></tr><tr><td>切换到本地某个分支</td><td>git checkout dev</td><td>切换到本地某个分支</td></tr><tr><td>查看本地分支与远程分支的关联情况</td><td>git branch -vv</td><td>查看本地分支与远程分支的关联情况</td></tr><tr><td>查看远程分支</td><td>git branch -a</td><td>查看远程分支</td></tr><tr><td>创建本地分支并切换</td><td>git checkout -b V1.1</td><td>V1.1为分支名</td></tr><tr><td>创建远程分支</td><td>git push –set-upstream origin V1.1</td><td>建立本地分支与新建远程分支的关联</td></tr><tr><td>新建本地分支并跟踪远程分支</td><td>git branch dev origin&#x2F;dev</td><td>dev为分支名称</td></tr><tr><td>新建本地分支并跟踪远程分支且切换</td><td>git checkout -b dev origin&#x2F;dev</td><td>本地新建分支 dev ，跟踪远程的同名分支 dev</td></tr><tr><td>本地新建分支 dev ，跟踪远程的同名分支 dev</td><td>git checkout –track origin&#x2F;dev</td><td>本地新建分支 dev ，跟踪远程的同名分支 dev</td></tr><tr><td>获取远程地址及通信方式</td><td>git remote -v</td><td>以git开头为ssh协议</td></tr><tr><td>更新本地仓库的remote地址</td><td>git remote set-url origin xxx</td><td>xxx为远程地址</td></tr><tr><td>回退到上一个版本</td><td>git reset –hard HEAD^</td><td>删除工作区的改动代码，撤销commit、add</td></tr><tr><td>回退到上X个版本</td><td>git reset –hard HEAD~3</td><td>~4，删除期间的所有改动，撤销commit、add</td></tr><tr><td>撤销提交（commit）</td><td>git reset –soft HEAD^</td><td>不删除工作区的改动代码，不撤销add</td></tr><tr><td>查看代码提交记录</td><td>git log</td><td>查看代码提交记录</td></tr><tr><td>删除本地分支</td><td>git branch -d Chapater6</td><td>Chapater6为分支名</td></tr><tr><td>删除远程分支</td><td>git push origin –delete Chapater6</td><td></td></tr><tr><td>删除本地标签</td><td>git tag -d rel1</td><td>rel1为标签名</td></tr><tr><td>查看所有本地标签</td><td>git tag -l</td><td></td></tr><tr><td>删除远程标签</td><td>git push –delete origin prod1.0</td><td></td></tr><tr><td>查看远程仓库信息</td><td>git remote show origin</td><td>查看远程仓库信息</td></tr></tbody></table><h2 id="注意项及扩展问题解答"><a href="#注意项及扩展问题解答" class="headerlink" title="注意项及扩展问题解答"></a>注意项及扩展问题解答</h2><h3 id="执行-git-pull-会覆盖本地的修改吗？"><a href="#执行-git-pull-会覆盖本地的修改吗？" class="headerlink" title="执行 git pull 会覆盖本地的修改吗？"></a>执行 git pull 会覆盖本地的修改吗？</h3><p>没有冲突的情况下，远端会直接更新至本地上，但不会改变本地未提交的变动；如果本地修改已提交，则会执行一个远端分支和本地分支的合并</p><h3 id="git-fetch-和-git-pull-的区别与联系"><a href="#git-fetch-和-git-pull-的区别与联系" class="headerlink" title="git fetch 和 git pull 的区别与联系"></a>git fetch 和 git pull 的区别与联系</h3><p><code>git fetch</code>用于从远程仓库获取最新的提交，保存到本地的远程跟踪分支中（<code>FETCH_HEAD</code>），可以通过查看此分支了解远程仓库的更新情况</p><ul><li><code>git diff FETCH_HEAD</code>比较查看该分支和当前工作分支的内容</li></ul><br><p><code>git pull</code>会自动获取远程仓库的更新，并且合并到当前分支上，相当于<code>git fetch</code> + <code>git merge FETCH_HEAD</code></p><ul><li>将远程仓库中指定分支的最新提交 ID 保存到本地的 FETCH_HEAD 分支中</li><li>将 FETCH_HEAD 分支合并到当前工作分支中</li></ul><h3 id="如何取消指定文件的修改-暂存-提交？"><a href="#如何取消指定文件的修改-暂存-提交？" class="headerlink" title="如何取消指定文件的修改&#x2F;暂存&#x2F;提交？"></a>如何取消指定文件的修改&#x2F;暂存&#x2F;提交？</h3><ul><li><p>当文件还没暂存，修改还停留着工作区时，执行<code>git checkout -- &lt;file&gt;</code>取消文件的修改（注意要带<code>--</code>），执行<code>git checkout .</code>取消所有工作区的更改</p></li><li><p>当文件已经暂存时，执行<code>git reset &lt;file&gt;</code>取消暂存使其回到工作区，执行<code>git reset .</code>取消所有暂存</p></li><li><p>当文件已经提交时，执行<code>git reset --soft HEAD^</code>，将最近的一次提交记录取消，并将所有内容返回至工作区，可以重新编辑、提交或者取消修改</p></li></ul><p>注意：最近的提交已经取消，而远端的提交还保持，此时如果需要同步提交，执行<code>git push -f</code>强制覆盖远端仓库，需要审慎决定。另外，可以采取<code>git revert HEAD</code>创建一个新的提交达到反向抵消最近提交的目的。</p><h3 id="如何解决分支合并冲突"><a href="#如何解决分支合并冲突" class="headerlink" title="如何解决分支合并冲突"></a>如何解决分支合并冲突</h3><p>当本地两个分支合并时，或者是远端分支与本地分支合并时，如果有冲突，解决流程如下：</p><ul><li><p>当执行<code>git pull</code>合并远端分支的更改到本地分支，或者执行<code>git merge dev</code>将本地的dev分支合并到当前分支，Git 会中止合并，并显示一个消息，列出存在冲突的文件</p></li><li><p>此时可以手动编辑冲突文件：打开冲突的文件，Git 会在有冲突的地方插入特殊的标记，如 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>，编辑文件进行合适的更改后，使用<code>git add &lt;file&gt;</code>暂存冲突的文件<br>冲突文件示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">本地更改的内容</span><br><span class="line">=======</span><br><span class="line">远端更改的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;commit&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git commit</code>提交解决冲突后的更改，此时会进入提交信息的编辑界面，Git 通常会在其中自动填充一个合并提交信息，也可以自行修改。</p><blockquote><p>当然也可以直接执行<code>git commit -m &quot;commit message&quot;</code>，commit message 则为此次分支合并的提交信息。</p></blockquote></li></ul><br><h3 id="本地分支与远端分支各有一个新的提交时的做法"><a href="#本地分支与远端分支各有一个新的提交时的做法" class="headerlink" title="本地分支与远端分支各有一个新的提交时的做法"></a>本地分支与远端分支各有一个新的提交时的做法</h3><p>当本地分支有一个提交，而远端分支也有一个新的提交时，如果使用<code>sourcetree</code>进行拉取，会提示错误，有以下解决方法：</p><ul><li><p><strong>创建一个合并提交：</strong> 将远端分支的更改合并到本地分支，这会创建一个新的“合并提交”（merge commit），将两个分支的更改历史合并在一起。可以用命令行直接执行<code>git pull</code></p><br></li><li><p><strong>变基：</strong> 执行<code>git pull --rebase</code>，相当于<code>git fetch</code>+<code>git rebase</code>，此过程不会创建合并提交，仅会把远端的提交和本地的提交重写成一个线性的提交历史。</p><blockquote><p>如果存在修改冲突的话，git会停止变基过程，提示用户打开文件手动解决冲突。此时用户修改完冲突后，执行<code>git add &lt;file&gt;</code>，再执行<code>git rebase --continue</code>，git则会继续执行变基过程。</p></blockquote></li></ul><h3 id="git-commmit相关扩展"><a href="#git-commmit相关扩展" class="headerlink" title="git commmit相关扩展"></a>git commmit相关扩展</h3><p>当使用<code>git commit</code>时，会进入nano编辑器，此时可以编辑文本，按<code>ctrl + x</code>退出，按<code>y</code>保存，选择保存时会再次提示确认文件名，直接按<code>Enter</code>即可保存提交。</p><p>当然，可以执行<code>git config --global core.editor vim</code>切换为vim编辑器。</p><h4 id="git-commit提交规范"><a href="#git-commit提交规范" class="headerlink" title="git commit提交规范"></a>git commit提交规范</h4><ul><li><a href="https://www.cnblogs.com/anly95/p/13163384.html">git commit 代码提交规范</a></li></ul><p>基于Angular团队的Git提交指南如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p><strong>type（类型）</strong>：描述提交的类别，如 feat（新特性）、fix（修复bug）、docs（文档更新）、style（代码格式改变）、refactor（代码重构）、perf（性能优化）、test（添加或修改测试）、chore（其他不修改src或test的更改）等。<br><strong>scope（范围）</strong>：描述提交影响的代码模块或功能，如 api、auth、ui 等。<br><strong>subject（主题）</strong>：简洁明了地描述所做的更改，通常不超过50个字符，并且使用现在时态，如“Fix bug”而不是“Fixed bug”。<br><strong>body（正文）</strong>：更详细地描述更改的内容、原因和影响，如果需要的话。可以分成多行，但每行不超过72个字符。<br><strong>footer（页脚）</strong>：提交信息的最后一部分，可以包含关闭的issue、关联的pull request或breaking changes等信息。<br><br></p><p>一个具体的提交信息示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fix(auth): 修复登录时的空指针异常</span><br><span class="line"></span><br><span class="line">在用户尝试使用null邮箱地址登录时，系统会抛出空指针异常。这次更改通过在调用登录方法之前检查邮箱地址是否为空来修复这个问题。</span><br><span class="line"></span><br><span class="line">此外，这次更改还增加了一个警告日志，以便于监控系统在用户尝试使用无效数据登录时的行为。</span><br><span class="line"></span><br><span class="line">Closes #123</span><br></pre></td></tr></table></figure><p>解释如下：</p><ul><li>type 是 fix，表示这是一个bug修复</li><li>scope 是 auth，表示更改影响的是认证模块</li><li>subject 是 “修复登录时的空指针异常”，简洁地描述了更改的内容</li><li>body 提供了更详细的更改描述和上下文，包括为什么进行这个更改以及它的影响</li><li>footer 包含了一个关联的issue编号 #123，表示这个提交解决了该issue</li></ul><h2 id="基础非典型操作"><a href="#基础非典型操作" class="headerlink" title="基础非典型操作"></a>基础非典型操作</h2><h3 id="本地git配置"><a href="#本地git配置" class="headerlink" title="本地git配置"></a>本地git配置</h3><br><p><strong>配置本地与远端的SSH密钥连接流程：</strong></p><ul><li>本地生成SSH公钥和私钥(如果没有的话，另，linux下公钥通常存放于<code>~/.ssh/*.pub</code>)<ul><li><code>ssh-keygen -t rsa -b 4096 -C xxx@xxx.com</code></li></ul></li><li>复制公钥，添加至远端平台的SSH设置上<br></li></ul><p><strong>查看本地配置：</strong></p><ul><li><code>git config --list</code>查看当前项目的所有配置</li><li><code>git config --global --list</code>查看全局配置<br></li></ul><p><strong>修改用户名(全局&#x2F;当前项目)</strong></p><p>此用户名即提交日志上所展示的用户名称</p><ul><li>修改全局用户名：<code>git config --global user.name &quot;xxx&quot;</code>，影响用户的所有仓库</li><li>修改当前路径项目的用户名：<code>git config user.name &quot;xxx&quot;</code></li><li>查看全局用户名：<code>git config user.name</code><br></li></ul><p><strong>初始化本地工程并与远端已有仓库的main分支关联：</strong></p><ul><li>进入工程根目录，<code>git init</code>初始化本地仓库</li><li>添加远程仓库：<code>git remote add origin &lt;远程仓库地址&gt;</code></li><li><code>git branch -M main</code>将当前分支重命名为<code>main</code>，M即<code>--move --force</code>的缩写。（可以分别输入<code>git add --all</code>，<code>git commit -m &quot;first commit&quot;</code>完成对本地分支的首次提交）</li><li>使用<code>git pull origin main</code>，将远程仓库的main分支拉取到本地，或者<code>git push -u origin main -f</code>将本地的xxx分支强制推送到远端main分支，其中-u是<code>--set-upstream</code>的缩写，后续会保持这个跟踪关系</li></ul><h3 id="标签相关操作"><a href="#标签相关操作" class="headerlink" title="标签相关操作"></a>标签相关操作</h3><p><strong>克隆远程仓库上指定标签对应的工程：</strong></p><ul><li>模板：<code>git clone -b v1.0.0 https://github.com/example/my_repo</code>–克隆仓库 <a href="https://github.com/example/my_repo">https://github.com/example/my_repo</a> 中标签 v1.0.0 对应的源码到当前目录</li><li>如：<code>git clone -b OpenHarmony-v4.0-Release https://gitee.com/openharmony/kernel_liteos_m.git</code></li></ul><h3 id="本地仓库同时推送远端的多个平台（推送gitee、github）"><a href="#本地仓库同时推送远端的多个平台（推送gitee、github）" class="headerlink" title="本地仓库同时推送远端的多个平台（推送gitee、github）"></a>本地仓库同时推送远端的多个平台（推送gitee、github）</h3><p><strong>方法一：为远程仓库指定多个地址</strong></p><ul><li>在本地仓库的根目录有<code>.git</code>隐藏目录，找到<code>.git/config</code>文件，打开编辑，如下所示</li><li>其中代码行<code>url = git@gitee.com:Jindu-Chen/jindu-chen.git</code>为新增（首先需要在远程创建&#x2F;拥有此仓库，并且本地用户已经配置好与gitee、github的连接）</li><li>保存退出，此时修改本地代码并提交，会同时推送到两个远端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = git@gitee.com:Jindu-Chen/jindu-chen.git       # 新添加行</span><br><span class="line">        url = git@github.com:Jindu-Chen/Jindu-Chen.github.io.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/main</span><br><span class="line">[user]</span><br><span class="line">        name = Jindu Chen</span><br></pre></td></tr></table></figure></li></ul><h3 id="gitignore忽略规则"><a href="#gitignore忽略规则" class="headerlink" title=".gitignore忽略规则"></a>.gitignore忽略规则</h3><ul><li><p>在git项目根目录下创建.gitignore文件，然后添加需要忽略跟踪的文件选项</p><ul><li>.gitignore文件仅对当前目录及其子目录起作用</li></ul></li><li><p>此前已经被跟踪的文件，添加.gitignore无效</p><blockquote><p>执行<code>git rm --cached /path/to/remove</code>取消跟踪，然后提交推送</p></blockquote></li><li><p>强行跟踪被.gitignore忽略的某个指定文件<br><code>git add -f /path/to/add</code>或者 在.gitignore文件后添加<code>!path/to/track</code>(<code>!</code>表示覆盖前面的忽略规则)<br>如：<code>git add -f hello.bin</code> or 添加<code>!hello.bin</code></p></li></ul><p><strong>附上一个自用的.gitignore文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.vscode</span><br><span class="line">.history</span><br><span class="line">build</span><br><span class="line">Listings</span><br><span class="line">Objects</span><br><span class="line"></span><br><span class="line"># Listing Files</span><br><span class="line">*.i</span><br><span class="line">*.lst</span><br><span class="line">*.map</span><br><span class="line"></span><br><span class="line"># Object Files</span><br><span class="line">*.axf</span><br><span class="line">*.b[0-2][0-9]</span><br><span class="line">*.b3[0-1]</span><br><span class="line">*.bak</span><br><span class="line">*.build_log.htm</span><br><span class="line">*.crf</span><br><span class="line">*.d</span><br><span class="line">*.dep</span><br><span class="line">*.elf</span><br><span class="line">*.htm</span><br><span class="line">*.iex</span><br><span class="line">*.lnp</span><br><span class="line">*.o</span><br><span class="line">*.obj</span><br><span class="line">*.sbr</span><br><span class="line"></span><br><span class="line"># Firmware Files</span><br><span class="line">*.bin</span><br><span class="line">*.h86</span><br><span class="line">*.hex</span><br><span class="line"></span><br><span class="line"># Debugger Files</span><br><span class="line">.ini</span><br></pre></td></tr></table></figure><h3 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a>版本发布</h3><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="钩子配置-Git-Hooks"><a href="#钩子配置-Git-Hooks" class="headerlink" title="钩子配置(Git Hooks)"></a>钩子配置(Git Hooks)</h3><ul><li>Hook 即在执行某个事件之前或之后进行一些其他额外的操作，如下<ul><li>自动部署代码</li><li>自动进行代码审查</li><li>安全审查</li><li>日志记录</li><li>通知用户</li></ul></li><li>Git有许多的事件（commit、push 等等），每个事件也应了有不同的钩子（如 commit 前，commit 后）</li><li>使用：暂略</li></ul><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><ul><li><p>对于需要流水线自动化作业编译的项目，可以将其工具链单独存放，作为子模块被调用</p></li><li><p>删除项目内已有的子模块配置，将其转化为本项目内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ./path/to/submodule</span><br><span class="line">rm -rf .git</span><br><span class="line"></span><br><span class="line"># at project root directory</span><br><span class="line">git rm --cached ./path/to/submodule</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>克隆包含子模块的仓库后，子模块的拉取<br>  <code>git submodule update --init --recursive</code></p></li></ul><h2 id="非典型问题解决方案"><a href="#非典型问题解决方案" class="headerlink" title="非典型问题解决方案"></a>非典型问题解决方案</h2><h3 id="同一Linux主机-多github账户的权限报错问题"><a href="#同一Linux主机-多github账户的权限报错问题" class="headerlink" title="同一Linux主机-多github账户的权限报错问题"></a>同一Linux主机-多github账户的权限报错问题</h3><p>明明已经配置好本地与 Github 云端的 SSH 密钥，但依旧报错，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to xxx.git denied to xxx.</span><br><span class="line">fatal: 无法读取远程仓库。</span><br><span class="line">请确认您有正确的访问权限并且仓库存在。</span><br></pre></td></tr></table></figure><br><p>解决步骤如下：</p><ul><li>如果需要使用两个不同的 Github 账户，则需要在本地主机上生成两个相应的 SSH Key，将公钥分别添加到不同 Github 账户上</li><li>由于主机有两个 SSH Key，导致 Github 无法识别对应关系，所以会报错权限问题</li><li>这时，需要用户手动配置对应映射关系，给另一个 Github 账户的站点<strong>起一个别名</strong>，起到区分作用即可</li><li>进入 .ssh 文件夹 – <code>cd ~/.ssh</code>，创建配置文件 – <code>vim config</code>，添加内容如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Default GitHub</span><br><span class="line">Host github.com             # 选定一个默认账户，别名不用更改</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa    # 对应其生成的密钥</span><br><span class="line"></span><br><span class="line">#new github</span><br><span class="line">Host github-alias           # 另一个账户的别名</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa1   # 另一个账户所对应的密钥</span><br></pre></td></tr></table></figure>假设现在有一个仓库，是属于另一个 Github 账户的，那么需要更改其远程仓库链接为别名即可：</li></ul><p>比如，将<code>git@github.com:Jindu-Chen/Jindu-Chen.github.io.git</code>改为<code>github-alias:Jindu-Chen/Jindu-Chen.github.io.git</code></p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://stackoverflow.com/questions/68277661/what-does-the-m-mean-in-git-branch-m-main">What does the -M mean in git branch -M main?</a></li><li><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">Github remote permission denied</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Harmony】OpenHarmony-V4.0-LiteOS-M鸿蒙轻内核开发调试</title>
      <link href="/2023/12/20/%E3%80%90Harmony%E3%80%91OpenHarmony-V4-0%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/12/20/%E3%80%90Harmony%E3%80%91OpenHarmony-V4-0%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基于命令行开发环境搭建"><a href="#基于命令行开发环境搭建" class="headerlink" title="基于命令行开发环境搭建"></a>基于命令行开发环境搭建</h2><p>复述官方文档，仅作参考，当在源码根目录下键入<code>hb help</code>，命令执行成功，基本完成前期环境的搭建</p><ul><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/quickstart-pkg-install-package.md">安装库和工具集</a></li><li>下载OpenHarmony-V4.0-Release全量代码，可通过git拉取或者下载压缩包解压<ul><li>在 Linux 输入命令<code>wget https://gitee.com/link?target=https%3A%2F%2Frepo.huaweicloud.com%2Fopenharmony%2Fos%2F3.2.4%2Fcode-v3.2.4-Release_20231113.tar.gz</code>下载OpenHarmony V3.2.4源码，其它可参考</li><li>在源码根目录下执行prebuilts脚本，安装编译器及二进制工具–<code>bash build/prebuilts_download.sh</code></li><li>执行<code>pip3 install --user build/lite</code>安装hb工具，添加<code>export PATH=~/.local/bin:$PATH</code>到<code>~/.bashrc</code>中，并生效环境变量</li></ul></li><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/quickstart-pkg-install-tool.md">安装编译工具</a></li><li>开发基于Cortex-M内核工程，需要安装<code>arm-none-eabi-</code>工具链，并声明工具链路径至<code>~/.bahsrc</code>。此处不过多赘述</li><li>键入<code>hb set</code>选择目标开发设备，键入<code>hb build</code>执行编译，编译成功则表示环境构建无误</li></ul><h2 id="轻量系统开发的前期流程"><a href="#轻量系统开发的前期流程" class="headerlink" title="轻量系统开发的前期流程"></a>轻量系统开发的前期流程</h2><ul><li>参考Gitee的OpenHarmony项目搭建命令行开发环境，熟悉基本的操作流程</li><li>熟悉GN、ninja的文件编写、和源码构建过程，了解子系统、组件等基本概念<ul><li>子系统是逻辑概念，其具体由对应的组件构成</li><li>组件是可复用的软件单元，其包含源码、配置文件、资源文件和编译脚本</li><li>通过配置文件、编译链接脚本，使得同一组件可以在不同的目标架构上运行</li></ul></li><li>参考社区的移植流程，根据其工程范例进一步了解轻量系统的构建开发原理</li></ul><h2 id="目标工程的编译构建流程"><a href="#目标工程的编译构建流程" class="headerlink" title="目标工程的编译构建流程"></a>目标工程的编译构建流程</h2><ul><li>hb set</li><li>hb build如何调用构建</li></ul><h3 id="debug-config配置"><a href="#debug-config配置" class="headerlink" title="debug.config配置"></a>debug.config配置</h3><p>debug.config文件位于<code>//vendor/$&#123;company&#125;/$&#123;company_product&#125;/kernel_configs</code>目录下，该文件配置由用户在<code>//kernel/liteos_m/</code>目录下<code>make menuconfig</code>生成，当然用户也可以直接修改debug.config进行工程的宏定义配置<br><br></p><h2 id="子系统添加和构建"><a href="#子系统添加和构建" class="headerlink" title="子系统添加和构建"></a>子系统添加和构建</h2><p>参考OpenHarmony-v4.0源码工程下的<code>//vendor/talkweb/niobe407</code>、<code>//device/board/talkweb</code>、<code>//device/soc/st/stm32f4xx</code>，此部分是基于stm32的厂商工程范例<br><br></p><p>此处重复讲述几个与子系统相关的概念：以便在添加子系统时清楚所需要添加和编译链接的子系统<br>OpenHarmony轻量系统下的子系统主要分为三部分：基础子系统、功能子系统、应用子系统</p><ul><li>基础子系统<br>即<code>//foundation</code>，包括bootstrap（系统启动和关闭）、hal_sysparam（负责管理系统参数）、systemabilitymgr（负责管理系统服务）、commonlibrary（提供通用库）等，当然内核子系统是必须的</li></ul><br><ul><li>功能子系统<br>HiViewDFX ：为图形框架应用子系统<br>HiViewDFX ：为图形框架应用子系统<br>hdf：驱动层框架</li></ul><br><ul><li>应用子系统<br>shell：命令行接口</li></ul><h3 id="添加-LittleFS-文件子系统"><a href="#添加-LittleFS-文件子系统" class="headerlink" title="添加 LittleFS 文件子系统"></a>添加 LittleFS 文件子系统</h3><ul><li><a href="https://ost.51cto.com/posts/7171">LiteOS-M小型系统内核——LittleFS</a></li></ul><h2 id="轻量系统编程开发"><a href="#轻量系统编程开发" class="headerlink" title="轻量系统编程开发"></a>轻量系统编程开发</h2><h3 id="系统初始化函数"><a href="#系统初始化函数" class="headerlink" title="系统初始化函数"></a>系统初始化函数</h3><p><strong>LOS_KernelInit()函数</strong><br><br></p><p><strong>OHOS_SystemInit()函数</strong></p><ul><li>主要为隐式执行各种初始化函数，包含用户声明的自定义初始化函数</li><li>如执行通过<code>SYS_RUN(OHOS_Main);</code>声明的OHOS_Main函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void OHOS_SystemInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    MODULE_INIT(bsp);</span><br><span class="line">    MODULE_INIT(device);</span><br><span class="line">    MODULE_INIT(core);</span><br><span class="line">    SYS_INIT(service);</span><br><span class="line">    SYS_INIT(feature);</span><br><span class="line">    MODULE_INIT(run);</span><br><span class="line">    SAMGR_Bootstrap();</span><br><span class="line">    LiteParamService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><p><strong>LOS_Start()函数</strong><br><br></p><h2 id="编译纠错"><a href="#编译纠错" class="headerlink" title="编译纠错"></a>编译纠错</h2><ul><li><p>编译成功，但生成的可执行bin文件明显偏小，查看Kconfig配置文件是否有选项没写对，导致的没编译链接</p></li><li><p>提示以下报错，考虑为 g++编译时 extern C {}的嵌套引用的编译错误，根据编译报错提示，一步步查找，其嵌套包含的头文件其里的<code>#ifdef __cplusplus &#125; #endif</code>是否一一匹配</p></li><li><p>此处最终发现为国民技术n32g45x.h包含的n32g45x_conf.h包含的n32g45x_dvp.h缺少了ifdef cplusplus 的右大括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] [13/365] gcc CXX obj/base/hiviewdfx/hilog_lite/frameworks/featured/libhilog_static.hilog.o</span><br><span class="line">[OHOS ERROR] FAILED: obj/base/hiviewdfx/hilog_lite/frameworks/featured/libhilog_static.hilog.o </span><br><span class="line">[OHOS ERROR] ccache arm-none-eabi-g++ -D_XOPEN_SOURCE=700 -DOHOS_DEBUG -D__LITEOS__ -D__LITEOS_M__ -DSECUREC_IN_KERNEL=0 -I../../../device/soc/n32/n32g452/liteos_m -I../../../device/soc/n32/CMSIS/core -I../../../device/soc/n32/CMSIS/device -I../../../device/soc/n32/n32g452/N32G45x_Driver/inc -I../../../device/soc/n32/n32g452 -I../../../utils/native/lite/include -I../../../commonlibrary/utils_lite/include -I../../../kernel/liteos_m/components/cpup -I../../../kernel/liteos_m/components/exchook -I../../../foundation/systemabilitymgr/samgr_lite/interfaces/kits/samgr -I../../../drivers/hdf_core/framework/core/common/include/manager -I../../../base/hiviewdfx/hilog_lite/interfaces/native/innerkits/hilog -I../../../base/hiviewdfx/hilog_lite/interfaces/native/innerkits -I../../../third_party/bounds_checking_function/include -I../../../kernel/liteos_m/arch/arm/common -I../../../kernel/liteos_m/arch/arm/cortex-m4/gcc -I../../../kernel/liteos_m/arch/arm/include -I../../../kernel/liteos_m/arch/include -I../../../kernel/liteos_m/kernel/include -I../../../third_party/cmsis/CMSIS/Core/Include -I../../../third_party/cmsis/CMSIS/RTOS2/Include -I../../../third_party/cmsis/CMSIS/DSP/Include -I../../../third_party/cmsis/CMSIS/DSP/PrivateInclude -I../../../kernel/liteos_m/kal/cmsis -I../../../kernel/liteos_m/kal/libc/newlib/porting/include -I../../../kernel/liteos_m/kal/posix/include -I../../../kernel/liteos_m/components/shell/include -I../../../kernel/liteos_m/components/signal -I../../../kernel/liteos_m/utils -I../../../device/board/breo/n32g452_breo/liteos_m -I../../../base/hiviewdfx/hiview_lite -I../../../base/hiviewdfx/hilog_lite/frameworks/mini -I../../../base/hiviewdfx/hilog_lite/interfaces/native/kits/hilog_lite -I../../../device/board/breo/n32g452_breo/Application -I../../../device/soc/n32/n32g452/N32G45x_Driver/include -Os -Og -Wall -fdata-sections -ffunction-sections -DUSE_STDPERIPH_DRIVER -DN32G452 -D__LITEOS_M__ -mcpu=cortex-m4 -mthumb -Og -Wall -fdata-sections -ffunction-sections -DUSE_STDPERIPH_DRIVER -DN32G452 -D__LITEOS_M__ -mcpu=cortex-m4 -mthumb -mcpu=cortex-m4 -fno-common -fno-builtin -fno-strict-aliasing -Wall -fstack-protector-all -std=c++11 -c ../../../base/hiviewdfx/hilog_lite/frameworks/featured/hilog.cpp -o obj/base/hiviewdfx/hilog_lite/frameworks/featured/libhilog_static.hilog.o</span><br><span class="line">[OHOS ERROR] ../../../base/hiviewdfx/hilog_lite/frameworks/featured/hilog.cpp:66:1: error: expected &#x27;&#125;&#x27; at end of input</span><br><span class="line">[OHOS ERROR]    66 | &#125; // namespace OHOS</span><br><span class="line">[OHOS ERROR]       | ^</span><br></pre></td></tr></table></figure></li><li><p>提示以下信息：进入<code>kernel/liteos_m</code>，然后make menuconfig，选中兼容项，失能musl库，改为new lib。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] arm-none-eabi-gcc: fatal error: /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/lib/nano.specs: attempt to rename spec &#x27;link&#x27; to already defined spec &#x27;nano_link&#x27;</span><br><span class="line">[OHOS ERROR] compilation terminated.</span><br></pre></td></tr></table></figure></li><li><p>提示以下编译报错，其中fsync函数用于将文件的所有修改同步到磁盘，而此处提示缺少相关定义，首先检查轻量系统有没有配置fs文件系统，另外本人另辟蹊径，自己定义了一个空实现，使得编译成功，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fsync(int fd)</span><br><span class="line">&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] [34/56] LINK obj/kernel/liteos_m/bin/liteos</span><br><span class="line">[OHOS ERROR] FAILED: obj/kernel/liteos_m/bin/liteos obj/kernel/liteos_m/unstripped/bin/liteos </span><br><span class="line">[OHOS ERROR] ccache arm-none-eabi-gcc -static -Wl,--gc-sections -Wl,-Map=OHOS_Image.map --specs=nano.specs -Wl,-u_printf_float -Wl,--wrap=_calloc_r -Wl,--wrap=_malloc_r -Wl,--wrap=_realloc_r -Wl,</span><br><span class="line">......</span><br><span class="line">libs/libhal_sysparam.a libs/libhal_sys_param.a libs/libhilog_static.a libs/libparam_client_lite.a libs/libinit_utils.a libs/libinit_log.a libs/libsamgr.a libs/libsamgr_adapter.a libs/libsamgr_source.a libs/libbroadcast.a libs/libnative_file.a libs/libstatic_hal_file.a libs/libhilog_lite_static.a libs/libhiview_lite_static.a libs/libhievent_lite_static.a libs/libhuks_3.0_sdk.a -lc -lm -lnosys -Wl,--end-group -o obj/kernel/liteos_m/unstripped/bin/liteos  &amp;&amp; ccache arm-none-eabi-strip --strip-unneeded &quot;obj/kernel/liteos_m/unstripped/bin/liteos&quot; -o &quot;obj/kernel/liteos_m/bin/liteos&quot;</span><br><span class="line">[OHOS ERROR] /home/jd_chen/Downloads/gcc-arm-none-eabi-10-2020-q4-major/bin/../lib/gcc/arm-none-eabi/10.2.1/../../../../arm-none-eabi/bin/ld: libs/libhiview_lite_static.a(libhiview_lite_static.hiview_util.o):(.data.hiview_fsync+0x0): undefined reference to `fsync&#x27;</span><br><span class="line">[OHOS ERROR] collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure></li><li><p>提示找不到相应的函数实现或者相应的宏定义，可全局搜索其对应的实现，考虑在合适位置添加源文件路径或者头文件路径，从而使得编译成功</p></li><li><p>出现如下编译错误，在vfs_fs.c添加头文件&lt;stdbool.h&gt;包含即可</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[OHOS ERROR] [56/340] gcc cross compiler obj/kernel/liteos_m/components/fs/vfs/vfs.vfs_fs.o</span><br><span class="line">[OHOS ERROR] FAILED: obj/kernel/liteos_m/components/fs/vfs/vfs.vfs_fs.o </span><br><span class="line">...</span><br><span class="line">[OHOS ERROR] ../../../kernel/liteos_m/components/fs/vfs/vfs_fs.c:214:43: error: unknown type name &#x27;bool&#x27;</span><br><span class="line">[OHOS ERROR]   214 | static int VfsPathCheck(const char *path, bool isFile)</span><br><span class="line">[OHOS ERROR]       |                                           ^~~~</span><br><span class="line">[OHOS ERROR] ../../../kernel/liteos_m/components/fs/vfs/vfs_fs.c: In function &#x27;VfsOpen&#x27;:</span><br><span class="line">[OHOS ERROR] ../../../kernel/liteos_m/components/fs/vfs/vfs_fs.c:244:9: error: implicit declaration of function &#x27;VfsPathCheck&#x27; [-Werror=implicit-function-declaration]</span><br><span class="line">[OHOS ERROR]   244 |     if (VfsPathCheck(path, TRUE) != LOS_OK) </span><br><span class="line">[OHOS ERROR]       |         ^~~~~~~~~~~~</span><br><span class="line">[OHOS ERROR] cc1: all warnings being treated as errors</span><br></pre></td></tr></table></figure></li></ul><h2 id="程序运行错误排查"><a href="#程序运行错误排查" class="headerlink" title="程序运行错误排查"></a>程序运行错误排查</h2><h3 id="报错-ERR-null-HalHwiDefaultHandler-irqnum"><a href="#报错-ERR-null-HalHwiDefaultHandler-irqnum" class="headerlink" title="报错[ERR][(null)]HalHwiDefaultHandler irqnum:"></a>报错<code>[ERR][(null)]HalHwiDefaultHandler irqnum:</code></h3><p>运行报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entering kernel init...</span><br><span class="line">[ERR][(null)]HalHwiDefaultHandler irqnum:53</span><br></pre></td></tr></table></figure><p>查看源码得出为函数<code>__get_IPSR();</code>输出 irqnum:53，</p><p>分析原因为：在未注册创建中断的时候，就使能了中断以及持续触发，导致的错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ConfigInt(uart-&gt;uart_device, USART_INT_IDLEF, ENABLE); <span class="comment">//使能串口空闲中断</span></span><br></pre></td></tr></table></figure><p>在使能空闲中断后，须立马清除中断，代码改动增添如下，程序可正常运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USART_ConfigInt(uart-&gt;uart_device, USART_INT_IDLEF, ENABLE); <span class="comment">//使能串口空闲中断</span></span><br><span class="line">USART_ReceiveData(uart-&gt;uart_device);</span><br></pre></td></tr></table></figure><p>另外，LiteOS-M 通过<code>ArchHwiCreate()</code>将中断函数注册至私有的中断向量数组中，用户端不要重复设置中断分组和使能中断函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NVIC_InitStructure.NVIC_IRQChannel = uart-&gt;dma.rx_irq_ch;</span></span><br><span class="line"><span class="comment">// NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;</span></span><br><span class="line"><span class="comment">// NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;</span></span><br><span class="line"><span class="comment">// NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能dma中断服务函数</span></span><br><span class="line"><span class="comment">// NVIC_Init(&amp;NVIC_InitStructure);</span></span><br></pre></td></tr></table></figure><p>在跨系统移植业务代码时，需要将以上原有相关的中断库函数应用注释掉</p><h3 id="程序运行至hilog-will-init"><a href="#程序运行至hilog-will-init" class="headerlink" title="程序运行至hilog will init."></a>程序运行至<code>hilog will init.</code></h3><p><strong>串口日志打印信息如下：</strong>指示为内存访问错误，最终确认为结构体变量都设置为一字节对齐，导致的结构体访问指针变量 触发 非法内存访问错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">entering kernel init...</span><br><span class="line">hilog will init.</span><br><span class="line"></span><br><span class="line">*************Exception Information**************</span><br><span class="line">Type      = 11</span><br><span class="line">ThrdPid   = 25</span><br><span class="line">Phase     = exc in task</span><br><span class="line">FaultAddr = 0xabababab</span><br><span class="line">Current task info:</span><br><span class="line">Task name = (null)</span><br><span class="line">Task ID   = 25</span><br><span class="line">Task SP   = (nil)</span><br><span class="line">Task ST   = 0x0</span><br><span class="line">Task SS   = 0x0</span><br><span class="line">Exception reg dump:</span><br><span class="line">PC        = 0x80111e2</span><br><span class="line">LR        = 0x8010b81</span><br><span class="line">SP        = 0x20023fb0</span><br><span class="line">R0        = 0x0</span><br><span class="line">R1        = 0x1</span><br><span class="line">R2        = 0x20011b14</span><br><span class="line">R3        = 0x400</span><br><span class="line">R4        = 0x8018a64</span><br></pre></td></tr></table></figure><p><strong>原因分析：</strong></p><p>确认程序出错于函数<code>OHOS_SystemInit()</code>中，而后<strong>在hiview_log.c找到如下代码：</strong></p><ul><li>增加节点信息打印，发现函数未能执行到如下的<strong>print1处</strong>，说明<code>InitCoreLogOutput()</code>函数执行跑飞<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void HiLogInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    HIVIEW_UartPrint(&quot;hilog will init.\n&quot;);</span><br><span class="line">//print0</span><br><span class="line">    InitCoreLogOutput();</span><br><span class="line"></span><br><span class="line">//print1</span><br><span class="line">    /* The module that is not registered cannot print the log. */</span><br><span class="line">    if (HiLogRegisterModule(HILOG_MODULE_HIVIEW, &quot;HIVIEW&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_SAMGR, &quot;SAMGR&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_UPDATE, &quot;UPDATE&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_ACE, &quot;ACE&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_AAFWK, &quot;AAFWK&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_APP, &quot;APP&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_GRAPHIC, &quot;GRAPHIC&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_MEDIA, &quot;MEDIA&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_DMS, &quot;DMS&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_SEN, &quot;SEN&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_SCY, &quot;SCY&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_SOFTBUS, &quot;SOFTBUS&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_POWERMGR, &quot;POWERMGR&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_UIKIT, &quot;UIKIT&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_GLOBAL, &quot;GLOBAL&quot;) == FALSE ||</span><br><span class="line">        HiLogRegisterModule(HILOG_MODULE_DATAMGR, &quot;DATAMGR&quot;) == FALSE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">//print2</span><br><span class="line">    HiviewRegisterInitFunc(HIVIEW_CMP_TYPE_LOG, InitLogOutput);</span><br><span class="line">    HiviewRegisterInitFunc(HIVIEW_CMP_TYPE_LOG_LIMIT, InitLogLimit);</span><br><span class="line">    HILOG_DEBUG(HILOG_MODULE_HIVIEW, &quot;hilog init success.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">CORE_INIT_PRI(HiLogInit, 0);</span><br></pre></td></tr></table></figure></li></ul><p><strong>问题解决：</strong><br>在<code>target_config.h</code>添加失能<code>LOSCFG_PLATFORM_EXC</code>宏定义，或者在 debug.config 配置不使用内存访问错误，当然还可在源码中注释掉 此部分的使能，代码节选如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// kernel/liteos_m/arch/arm/cortex-m4/gcc/los_interrupt.c</span><br><span class="line"></span><br><span class="line">    /* Enable USGFAULT, BUSFAULT, MEMFAULT */</span><br><span class="line">    *(volatile UINT32 *)OS_NVIC_SHCSR |= (USGFAULT | BUSFAULT | MEMFAULT);</span><br><span class="line"></span><br><span class="line">    /* Enable DIV 0 and unaligned exception */</span><br><span class="line">#ifdef LOSCFG_ARCH_UNALIGNED_EXC</span><br><span class="line">    *(volatile UINT32 *)OS_NVIC_CCR |= (DIV0FAULT | UNALIGNFAULT);</span><br><span class="line">#else</span><br><span class="line">    *(volatile UINT32 *)OS_NVIC_CCR |= (DIV0FAULT);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>将上述代码中的<code>MEMFAULT</code>或者<code>UNALIGNFAULT</code>去掉 即可失能 内存非对齐访问错误</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/Readme-CN.md#/openharmony/docs/blob/master/zh-cn/device-dev/quick-start/quickstart-pkg-sourcecode.md">Gitee-OpenHarmony基于命令行入门</a></li><li><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/porting/porting-stm32f407-on-minisystem-eth.md">轻量系统STM32F407芯片移植案例</a></li><li><a href="https://ost.51cto.com/posts/7171">LiteOS-M小型系统内核——LittleFS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenHarmony </category>
          
          <category> LiteOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】Linux内核移植概述--基于I.MX6ULL</title>
      <link href="/2023/12/20/%E3%80%90Linux%E3%80%91Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-%E5%9F%BA%E4%BA%8EI-MX6ULL/"/>
      <url>/2023/12/20/%E3%80%90Linux%E3%80%91Linux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-%E5%9F%BA%E4%BA%8EI-MX6ULL/</url>
      
        <content type="html"><![CDATA[<h2 id="基本知识概要"><a href="#基本知识概要" class="headerlink" title="基本知识概要"></a>基本知识概要</h2><h2 id="Linux内核移植步骤简述"><a href="#Linux内核移植步骤简述" class="headerlink" title="Linux内核移植步骤简述"></a>Linux内核移植步骤简述</h2><ul><li>在Linux内核文件中，找到参考的板子配置文件——一般是半导体厂商基于其开发板的配置文件</li><li>以此份配置文件为模板，编译生成对应的zImage和.dtb文件</li><li>应用厂商开发板的zImage和.dtb文件，在自己的板子上启动Linux内核，查看能否正常启动</li><li>一般情况下，参考官方开发板设计的硬件，都能够正常启动</li><li>根据硬件与开发板的不同，修改相应的驱动；官方Linux内核一般会提供好各种相应的驱动，我们只需要修改设备树的一些配置信息即可</li></ul><h2 id="Linux内核移植详解步骤——I-MX6ULL"><a href="#Linux内核移植详解步骤——I-MX6ULL" class="headerlink" title="Linux内核移植详解步骤——I.MX6ULL"></a>Linux内核移植详解步骤——I.MX6ULL</h2><h3 id="在Linux内核中添加私有板子配置"><a href="#在Linux内核中添加私有板子配置" class="headerlink" title="在Linux内核中添加私有板子配置"></a>在Linux内核中添加私有板子配置</h3><ul><li>复制一份xxx_defconfig配置文件，并重命名，将其作为私有的默认配置文件<ul><li>通过在工程根目录下执行<code>make xxx_defconfig</code>配置Linux内核选项</li></ul></li><li>添加私有板子对应设备树文件<ul><li>创建私有.dts文件：<code>cd arch/arm/boot/dts</code> -&gt; <code>cp imx6ull-14x14-evk.dts imx6ull-xxx-emmc.dts</code></li><li>添加至编译：<code>vim arch/arm/boot/dts/Makefile</code>，在<code>dtb-$(CONFIG_SOC_IMX6ULL)</code>配置项中加入<code>imx6ull-xxx-emmc.dts</code>，使得编译设备树时，会从imx6ull-xxx-emmc.dts编译出对应的imx6ull-xxx-emmc.dtb文件</li></ul></li><li>编译得到zImage镜像文件和imx6ull-xxx-emmc.dtb设备树文件<ul><li>清理工程：<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</code></li><li>配置Linux内核：<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- xxx_defconfig</code></li><li>可选，打开图形化配置界面：<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code></li><li>执行编译：<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j16</code><ul><li>可选的，将上述指令添加到脚本中，进行自动化执行，避免重复的输入</li></ul></li><li><strong>编译完成后，在<code>arch/arm/boot</code>下生成zImage，在<code>arch/arm/boot/dts</code>下生成imx6ull-xxx-emmc.dtb文件</strong></li></ul></li></ul><h3 id="内核测试"><a href="#内核测试" class="headerlink" title="内核测试"></a>内核测试</h3><ul><li><p>启动板子，在u-boot命令模式中，加载所编译的zImage和.dtb文件</p><ul><li><code>tftp 80800000 zImage</code></li><li><code>tftp 83000000 imx6ull_xxx_emmc.dtb</code></li><li><code>bootz 80800000 - 83000000</code></li></ul></li><li><p>出现以下相似内容，表示Linux内核启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Booting Linux on physical CPU 0x0</span><br><span class="line">Linux version 4.1.15 ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="一些疑惑解答"><a href="#一些疑惑解答" class="headerlink" title="一些疑惑解答"></a>一些疑惑解答</h4><ul><li>在boot加载Linux内核时，所使用到的地址80800000和83000000是怎么来的？是固定地址？<ul><li>地址80800000是内核映像的起始地址，boot使用memcpy()将内核映像从存储设备加载到内存地址80800000中</li><li>地址83000000是内核栈的起始地址，其是内核存储临时数据的区域，boot将内核栈初始化为地址83000000<ul><li>设备树是ARM平台上的重要配置文件，其描述了系统资源的布局和属性；内核启动时需要访问设备树，以根据其参数初始化硬件设备</li><li>83000000是ARM平台上u-boot内核栈的常用起始地址，位于内存的低端，将设备树加载在此地址 -&gt; 确保内核在访问设备树时不会发生内存访问冲突</li></ul></li><li>在u-boot中，此二地址可以通过配置文件修改<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># configs/&lt;board&gt;defconfig</span><br><span class="line">CONFIG_SYS_LOAD_ADDR = 0x80800000</span><br><span class="line">CONFIG_SYS_INIT_SP_ADDR = 0x83000000</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Linux内核顶层Makefile详解"><a href="#Linux内核顶层Makefile详解" class="headerlink" title="Linux内核顶层Makefile详解"></a>Linux内核顶层Makefile详解</h2><h3 id="顶层Makefile布局"><a href="#顶层Makefile布局" class="headerlink" title="顶层Makefile布局"></a>顶层Makefile布局</h3><p>版本号</p><p>MAKEFLAGS 变量</p><p>命令输出</p><p>静默输出</p><p>设置编译结果输出目录</p><p>代码检查</p><p>模块编译</p><p>设置目标架构和交叉编译器</p><p>调用 scripts&#x2F;Kbuild.include 文件</p><p>交叉编译工具变量设置</p><p>头文件路径变量</p><p>导出变量</p><h3 id="make-xxx-defconfig-过程"><a href="#make-xxx-defconfig-过程" class="headerlink" title="make xxx_defconfig 过程"></a>make xxx_defconfig 过程</h3><h2 id="Linux内核启动流程"><a href="#Linux内核启动流程" class="headerlink" title="Linux内核启动流程"></a>Linux内核启动流程</h2><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【构建】嵌入式ld链接脚本详解</title>
      <link href="/2023/12/20/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91ld%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/20/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91ld%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链接脚本的主要作用：描述如何将输入文件(.o目标文件)中的段 映射到 输出文件(.bin&#x2F;.hex&#x2F;…)中的段，并控制输出文件的内存布局(地址分配)。</p><p>注意：输入文件的段和输出文件的段是独立的，主要分为<code>.text</code>, <code>.data</code>, <code>.bss</code>, <code>heap</code>, <code>stack</code>段</p><p>输入文件的段是链接器从输入文件中读取的内容，输出文件的段是链接器将输入文件的段链接到一起后生成的内容。</p><p>链接脚本用于指导链接器如何将输入文件的段链接到一起，其主要由<strong>MEMORY</strong>和<strong>SECTIONS</strong>块组成</p><ul><li><code>SECTIONS</code>是必须的</li><li><code>MEMORY</code>可选的，如果没有，链接器则认为所有输入文件都位于同一个内存区域，并且从0x0开始<br></li></ul><h2 id="基本知识点补充"><a href="#基本知识点补充" class="headerlink" title="基本知识点补充"></a>基本知识点补充</h2><p>.ld文件是GNU链接器(ld)使用的标准链接脚本文件，可使用GNU链接器的所有功能，包括符号解析、重定位、符号表生成等<br><br></p><p>.lds文件是旧式的链接脚本文件，其仅支持GNU链接器的部分功能，不推荐使用</p><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>为链接器提供系统内存的布局信息，并确定内存区域的访问权限。链接器根据MEMORY的信息，将编译生成的.o目标文件中的代码、数据、符号等分配到不同的内存区域。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 128K</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 32K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码描述了两个内存区域：</p><ul><li>标号为<code>FLASH</code>的内存区域权限为：可读只执行，起始地址为0x8000000，长度为128K；</li><li>标号为<code>RAM</code>的内存区域权限为：可读可写可执行，起始地址为0x20000000，长度为32K。<br></li></ul><p><strong>而后，链接脚本可声明将指定的代码放到对应的memory区域——以下链接脚本代码将<code>.text</code>段存放到标号为<code>RAM</code>的内存区域，将<code>.data</code>段存放到标号为<code>FLASH</code>的内存区域</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text &gt;RAM</span><br><span class="line">  .data &gt;FLASH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SECTIONS"><a href="#SECTIONS" class="headerlink" title="SECTIONS"></a>SECTIONS</h3><p>用于定义目标文件中各个段，包括名称、存储位置、对齐方式、内容，并且可以确定其访问权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  // 将可执行代码段（.text 段）存放到 RAM 区域，对齐到 4 字节边界</span><br><span class="line">  .text &gt;RAM : ALIGN(4)</span><br><span class="line"></span><br><span class="line">  // 将全局变量段（.data 段）存放到 FLASH 区域，对齐到 4 字节边界</span><br><span class="line">  .data &gt;FLASH : ALIGN(4)</span><br><span class="line"></span><br><span class="line">  // 将堆（heap）段存放到 RAM 区域，对齐到 8 字节边界</span><br><span class="line">  .heap &gt;RAM : ALIGN(8)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另，<strong>链接脚本中的内存存放顺序是从上到下</strong></p><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong>ENTRY</strong></p><p>将某个入口点函数指定为起始地址，如果没有指定<code>ENTRY</code>，链接器会默认使用第一个可执行section作为程序入口点</p><p><code>ENTRY(Reset_Handler)</code>将Reset_Handler函数设为程序的入口点，链接器需要知道程序的入口点，才能正确地组织可执行文件的时序，才能正确地执行编译、链接、优化代码</p><p><strong>注意：在cortex-m4中，ENTRY(Reset_Handler)并没有将Reset_Handler实体链接到0x8000004地址，其地址由链接器根据实际链接</strong><br></p><p><strong>链接脚本规定了起始段放置的是isr_vector，而启动文件 规定了向量中第一个字是指定存放 栈顶地址，第二个字即0x8000004存放的则是Reset_Handler的地址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector))</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">  _stext = .;</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  *(.text)           /* .text sections (code) */</span><br><span class="line">  xxx&#125;&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>&#x2F;DISCARD&#x2F;</strong></p><p>用于指定链接器应丢弃的section</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/DISCARD/ :</span><br><span class="line">&#123;</span><br><span class="line">  libc.a ( * )</span><br><span class="line">  libm.a ( * )</span><br><span class="line">  libgcc.a ( * )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，指示链接器将C标准库、数学库、GCC库中的section丢弃，在生成的可执行文件中不需要保留这些段。</p><p><strong>如果有调用到以下函数，则需要保留：</strong></p><ul><li>libm.a 包含了用于实现数学函数的符号和数据，例如 sin()、cos()、sqrt() 等</li><li>libgcc.a 包含了用于实现 GCC 扩展的符号和数据，例如 __builtin_add()、__builtin_div() 等</li><li>libc.a 是 C 标准库的库文件，包含了许多实现 C 标准库函数的符号和数据，诸如 printf()、scanf()、malloc()、free() 等常用函数。如果使用了微库，也可以去掉该section</li></ul><hr><p><strong>KEEP</strong></p><p>用于防止链接器丢弃未被引用的段和符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 强制连接器保留 .text 和 .data 两个 section 中的所有符号</span><br><span class="line">SECTIONS &#123;</span><br><span class="line">.text : &#123; KEEP(*(.text.*)) &#125;</span><br><span class="line">.data : &#123; KEEP(*(.data.*)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>*</code>表示任意多个字符，<code>.text.*</code>表示所有以 .text 开头的 section</li><li><code>*(.text.*)</code> 表示所有以 .text 开头的 section 中的所有符号</li></ul><hr><p><strong>LOADADDR</strong><br>  用于指定段的加载地址<br><br></p><p><strong>PROVIDE</strong><br>用于在链接时提供一个符号，如果符号未被定义，则使用其提供的值<br>如：<code>PROVIDE ( end = . );</code><br><br></p><p><strong>PROVIDE_HIDDEN</strong><br>作用类似于PROVIDE，但提供的符号不会被其它模块看到<br>如：<code>PROVIDE_HIDDEN (__fini_array_start = .);</code><br><br></p><h2 id="语句、片段示例解释"><a href="#语句、片段示例解释" class="headerlink" title="语句、片段示例解释"></a>语句、片段示例解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. = 0x10000;  // 将地址指针设为0x10000，表示.text段从地址0x10000开始</span><br><span class="line">.text : &#123; *(.text) &#125;  // 表示将输入文件的.text段复制到输出文件的.text段中</span><br><span class="line">. = 0x8000000;        //将地址指针设为0x8000000，表示.data段从地址0x8000000开始</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">._user_heap_stack :</span><br><span class="line">&#123;</span><br><span class="line">    . = ALIGN(4);       // 将当前地址调整为4字节对齐，确保堆和栈数据的正确访问</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    _estack = .;      // 设置 _estack 符号的值为当前地址</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">&#125; &gt;RAM</span><br></pre></td></tr></table></figure><h2 id="链接脚本完整示例解释"><a href="#链接脚本完整示例解释" class="headerlink" title="链接脚本完整示例解释"></a>链接脚本完整示例解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(Reset_Handler)</span><br><span class="line"></span><br><span class="line">_Min_Heap_Size = 0x200;      /* required amount of heap  */</span><br><span class="line">_Min_Stack_Size = 0x1500; /* required amount of stack */</span><br><span class="line"></span><br><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 128K</span><br><span class="line">RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 32K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .isr_vector :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    KEEP(*(.isr_vector)) /* Startup code */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.text)           /* .text sections (code) */</span><br><span class="line">    *(.text*)          /* .text* sections (code) */</span><br><span class="line">    *(.glue_7)         /* glue arm to thumb code */</span><br><span class="line">    *(.glue_7t)        /* glue thumb to arm code */</span><br><span class="line">    *(.eh_frame)</span><br><span class="line"></span><br><span class="line">    KEEP (*(.init))</span><br><span class="line">    KEEP (*(.fini))</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">__fsymtab_start = .;</span><br><span class="line">KEEP(*(FSymTab))</span><br><span class="line">__fsymtab_end = .;</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">__vsymtab_start = .;</span><br><span class="line">KEEP(*(VSymTab))</span><br><span class="line">__vsymtab_end = .;</span><br><span class="line"></span><br><span class="line">. = ALIGN(4);</span><br><span class="line">__rt_init_start = .;</span><br><span class="line">KEEP(*(SORT(.rti_fn*)))</span><br><span class="line">__rt_init_end = .;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">    _exit = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    *(.rodata)         /* .rodata sections (constants, strings, etc.) */</span><br><span class="line">    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line"></span><br><span class="line">  _shell_command_start = .;</span><br><span class="line">  KEEP (*(shellCommand))</span><br><span class="line">  _shell_command_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .ARM.extab   : &#123; *(.ARM.extab* .gnu.linkonce.armextab.*) &#125; &gt;FLASH</span><br><span class="line">  .ARM : &#123;</span><br><span class="line">    __exidx_start = .;</span><br><span class="line">    *(.ARM.exidx*)</span><br><span class="line">    __exidx_end = .;</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  .preinit_array     :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .init_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.init_array.*)))</span><br><span class="line">    KEEP (*(.init_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line">  .fini_array :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT(.fini_array.*)))</span><br><span class="line">    KEEP (*(.fini_array*))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125; &gt;FLASH</span><br><span class="line"></span><br><span class="line">  _sidata = LOADADDR(.data);</span><br><span class="line"></span><br><span class="line">  .data : </span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _sdata = .;        /* create a global symbol at data start */</span><br><span class="line">    *(.data)           /* .data sections */</span><br><span class="line">    *(.data*)          /* .data* sections */</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _edata = .;        /* define a global symbol at data end */</span><br><span class="line">  &#125; &gt;RAM AT&gt; FLASH</span><br><span class="line">  </span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">    /* This is used by the startup in order to initialize the .bss secion */</span><br><span class="line">    _sbss = .;         /* define a global symbol at bss start */</span><br><span class="line">    __bss_start__ = _sbss;</span><br><span class="line">    *(.bss)</span><br><span class="line">    *(.bss*)</span><br><span class="line">    *(COMMON)</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    _ebss = .;         /* define a global symbol at bss end */</span><br><span class="line">    __bss_end__ = _ebss;</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* User_heap_stack section, used to check that there is enough RAM left */</span><br><span class="line">  ._user_heap_stack :</span><br><span class="line">  &#123;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    PROVIDE ( end = . );</span><br><span class="line">    PROVIDE ( _end = . );</span><br><span class="line">    . = . + _Min_Heap_Size;</span><br><span class="line">    . = . + _Min_Stack_Size;</span><br><span class="line">    _estack = .;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">  &#125; &gt;RAM</span><br><span class="line"></span><br><span class="line">  /* Remove information from the standard libraries */</span><br><span class="line">  /DISCARD/ :</span><br><span class="line">  &#123;</span><br><span class="line">    libc.a ( * )</span><br><span class="line">    libm.a ( * )</span><br><span class="line">    libgcc.a ( * )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .ARM.attributes 0 : &#123; *(.ARM.attributes) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑惑解答及注意项"><a href="#疑惑解答及注意项" class="headerlink" title="疑惑解答及注意项"></a>疑惑解答及注意项</h2><h3 id="如何将指定的函数-数据-变量链接到指定的内存地址上？"><a href="#如何将指定的函数-数据-变量链接到指定的内存地址上？" class="headerlink" title="如何将指定的函数&#x2F;数据&#x2F;变量链接到指定的内存地址上？"></a>如何将指定的函数&#x2F;数据&#x2F;变量链接到指定的内存地址上？</h3><p>讲道理来说，原则上是可实现的，一般用在特殊情况需求上，比如两个互相独立的工程分别下载到同一个Flash的不同区域，但它们又需要共享用到一个非常大的常量数组，这时候或许需要这个技巧。</p><p>在编译时就指定变量的存放地址，程序直接指向强制访问该地址即可。</p><p>由于时间关系，或者本人意愿关系，暂且不想写下这个详细步骤，但先铺垫点草稿如下：</p><ul><li>使用<code>__attribute__</code>关键字，如<code>int value __attribute__ ((section (&quot;.ARM.__at_0x20000000&quot;))) = 0x33;</code></li><li>给变量声明一个段，而后在链接脚本中指定这个段的链接或加载地址</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.51cto.com/u_15060508/3869831">简单的ld链接脚本学习</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】嵌入式MCU开发问题记录</title>
      <link href="/2023/12/19/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/12/19/%E3%80%90MCU%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FMCU%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="自定义打印函数，通过命令行调用能打印，但在中断函数执行却没有打印"><a href="#自定义打印函数，通过命令行调用能打印，但在中断函数执行却没有打印" class="headerlink" title="自定义打印函数，通过命令行调用能打印，但在中断函数执行却没有打印"></a>自定义打印函数，通过命令行调用能打印，但在中断函数执行却没有打印</h3><p>如下函数源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> logPrintln(format, ...) \</span></span><br><span class="line"><span class="meta">        logWrite(LOG_ALL_OBJ, LOG_NONE, format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> logPrinttext(format, ...) \</span></span><br><span class="line"><span class="meta">        logWrite(LOG_ALL_OBJ, LOG_NONE, format, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drv_adc_read_total</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    logPrintln(<span class="string">&quot;aaa %d&quot;</span>, drv_adc_read(<span class="number">1</span>));</span><br><span class="line">    logPrinttext(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    logPrintln(<span class="string">&quot;aaa %d&quot;</span>, drv_adc_read(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)|SHELL_CMD_DISABLE_RETURN, drv_adc_read_total, drv_adc_read_total, drv_adc_read_total);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Channel6_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_ClearFlag(DMA_FLAG_GL6, DMA);</span><br><span class="line">    logDebug(<span class="string">&quot;read start&quot;</span>);</span><br><span class="line">    drv_adc_read_total();</span><br><span class="line">    logDebug(<span class="string">&quot;read end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DMA_Channel6_IRQHandler中执行，仅没有 logPrinttext(“bbb”); 这个输出<br>通过命令行调用drv_adc_read_total函数则有 logPrinttext(“bbb”); 打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">中断函数执行结果如下：</span><br><span class="line">D [0:11:49,025] DMA_Channel6_IRQHandler [208]: read start</span><br><span class="line">aaa 65533</span><br><span class="line">aaa 65533</span><br><span class="line">D [0:11:49,025] DMA_Channel6_IRQHandler [210]: read end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令行执行结果如下：</span><br><span class="line">root:/$ drv_adc_read_total</span><br><span class="line">aaa 65533</span><br><span class="line">bbbaaa 65533</span><br></pre></td></tr></table></figure><p><strong>问题调试分析：</strong></p><ul><li>如果将<code>&quot;\r\n&quot;</code>同样加到 <code>logPrinttext</code>函数的宏定义中，那么在中断中也能打印此函数内容</li><li>在命令行中调用，无论怎样更改宏定义，都能完整打印。区别在于一个在正常环境，一个在中断环境中；一个带了<code>\r\n</code>拼接字符串，一个没带</li><li>同时把中断服务函数引出命令行调用，执行结果对比如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root:/$ DMA_Channel6_IRQHandler // 手动执行命令行调用，能够完整打印</span><br><span class="line">D [0:00:17,989] DMA_Channel6_IRQHandler [210]: read start</span><br><span class="line">aaa 65533</span><br><span class="line">bbb 65533bbb</span><br><span class="line">aaa 65533</span><br><span class="line">D [0:00:17,989] DMA_Channel6_IRQHandler [212]: read end</span><br><span class="line"></span><br><span class="line">// 中断执行</span><br><span class="line">D [0:00:18,040] DMA_Channel6_IRQHandler [210]: read start</span><br><span class="line">aaa 65533</span><br><span class="line">bbb</span><br><span class="line">aaa 65533</span><br><span class="line">D [0:00:18,040] DMA_Channel6_IRQHandler [212]: read end</span><br></pre></td></tr></table></figure></li></ul><p><strong>问题解决：</strong><br>为尾行模式问题</p><p>由于使能了尾行模式，所以每次在调用<code>logWrite</code>函数输出时，都会紧接着将光标移到行首，而后输出终端用户等字符，覆盖当前行。<strong>如果当前内容后面没有接上换行符，则会被覆盖。</strong></p><p>而当用户通过命令行调用函数时，由于是当前shell状态为执行命令行函数，所以不会启用尾行输出，因而不会覆盖当前行的内容。</p><hr><h3 id="Switch-Case语句里面定义的静态变量会自己变化"><a href="#Switch-Case语句里面定义的静态变量会自己变化" class="headerlink" title="Switch Case语句里面定义的静态变量会自己变化"></a>Switch Case语句里面定义的静态变量会自己变化</h3><p>在一个case里面定义了一个<code>&#123;&#125;</code>作用域，而后定义一个静态变量，但有时发现其中某个for循环函数，明明没有对此变量进行修改，但是此变量的值却一直在变化。</p><p><strong>排查：</strong><br>考虑编译器优化等级、数据类型 u8 u16转换不当、等原因</p><p><strong>原因：</strong><br>最后发现为在 for 循环函数中有 循环给一个 数组进行赋值，然后<strong>该数组下标越界</strong>了，正好内存越界到 此静态变量的地址中。在对数组进行赋值操作或者对数组指针进行操作时，一定要注意可能的内存越界问题。</p><hr><h3 id="32MCU库函数应用问题"><a href="#32MCU库函数应用问题" class="headerlink" title="32MCU库函数应用问题"></a>32MCU库函数应用问题</h3><p>在本例中使用到 PB4引脚 复用为 USART2 的 TX 引脚，但是配置却不生效。最后发现，查看芯片数据手册得知：该引脚默认使能功能为 SW-JTAG 的烧录调试引脚之一，需要关闭此功能，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_AFIO, ENABLE);</span><br><span class="line">GPIO_ConfigPinRemap(GPIO_RMP3_USART2, ENABLE);              </span><br><span class="line">GPIO_ConfigPinRemap(GPIO_RMP_SW_JTAG_SW_ENABLE, ENABLE);    <span class="comment">// 需要配置引脚重映射，增加此项配置</span></span><br><span class="line">RCC_EnableAPB2PeriphClk(RCC_APB2_PERIPH_GPIOB, ENABLE);</span><br><span class="line">GPIO_InitCtlStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitCtlStruct.Pin = GPIO_PIN_4;</span><br><span class="line">GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitCtlStruct);</span><br><span class="line">GPIO_InitCtlStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_InitCtlStruct.Pin = GPIO_PIN_5;</span><br><span class="line">GPIO_InitPeripheral(GPIOB, &amp;GPIO_InitCtlStruct);</span><br></pre></td></tr></table></figure><p>另外，在进行库函数开发时，特别要注意查看函数功能注释，比如<code>GPIO_ConfigPinRemap</code>该库函数，并不支持一次同时输入多个值如<code>GPIO_RMP3_USART2 | GPIO_RMP_SW_JTAG_SW_ENABLE</code>。</p><hr><h3 id="配置ADC-DMA的发送完成中断触发无效"><a href="#配置ADC-DMA的发送完成中断触发无效" class="headerlink" title="配置ADC-DMA的发送完成中断触发无效"></a>配置ADC-DMA的发送完成中断触发无效</h3><p><strong>现象：</strong></p><ul><li>DMA、ADC皆已配置完成，adc能够正常采集，dma也能够正常地将adc的数据采集存放到指定的缓冲区中。此时添加使能相应的DMA-ADC通道发送完成中断，发现无效。</li></ul><p><strong>原因：</strong><br>为初始化顺序不符合，正常的配置顺序应为： 初始化ADC外设及相应的复用IO-&gt;初始化DMA外设通道-&gt;配置DMA-ADC通道映射-&gt;清除DMA标志位-&gt;配置使能DMA通道标志触发中断-&gt;使能ADC-DMA访问请求-&gt;使能相应的DMA通道-&gt;配置NVIC使能DMA通道中断</p><p>以上，特别注意：ADC-DMA使能、DMA通断使能、DMA通道使能中断要放到最后.</p><p>另外，编写中断服务函数时，须要在其内清除相应的中断标志位，否则可能会无限重入中断，程序运行出现问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DMA_ConfigInt(DMA1_CH1, DMA_INT_TXC, ENABLE);   <span class="comment">// 配置使能中断要放在使能通道之前，不然无法生效，配置流程要严谨参考芯片手册，不可凭感觉配置</span></span><br><span class="line">DMA_EnableChannel(DMA1_CH1,ENABLE);</span><br></pre></td></tr></table></figure><h3 id="添加了bootloader的LiteOS应用程序没能跑起来"><a href="#添加了bootloader的LiteOS应用程序没能跑起来" class="headerlink" title="添加了bootloader的LiteOS应用程序没能跑起来"></a>添加了bootloader的LiteOS应用程序没能跑起来</h3><p><strong>原因分析：</strong></p><ul><li>首先检查bootloader和app的链接脚本是否有误，确认bootloader跳转地址为0x8004000，而app链接脚本的FLASH起始地址为0x8004000无误</li><li>确认app中断向量SCB-&gt;VTOR配置正确</li><li>使用此前的bootloader + LiteOS APP、 gcc环境下的bootloader + 重构前的rt-thread App分别观察现象；发现gcc bootloader + rt-thread App能够正常运行，说明问题出现在LiteOS的应用程序上</li><li><strong>可能是中断向量仍然未配置好、可能是程序实际并未以0x8004000为起始地址链接、可能是App程序中关于IAP部分程序没配置好地址、可能是LiteOS自定义的中断向量没有8字节对齐、可能是App部分大小超过FLASH限制</strong></li><li>另外，不排除bootloader中有读取擦除指定地址数据的操作，当App程序过大越界可能会被擦除部分数据</li><li>不排除bootloader与app的系统时钟初始化可能存在不一致问题，如两者工程的启动文件都会调用到<code>system_stm32xxxx.c</code>里的系统时钟初始化函数，进入到main函数，通常用户会再次初始化系统时钟。需要保持其时钟源配置一致，避免出现初始化错误</li><li>另外发现，<code>Reset_handler</code>函数的hex文件地址解析 比 在map文件中的地址加1.</li><li>在检查链接脚本时，发现如下代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_estack = 0x20024000;    /* end of RAM */</span><br><span class="line">_sstack = 0x20000000;    /* start of RAM */</span><br></pre></td></tr></table></figure></li><li>突发奇想，将栈顶指针<code>_estack = 0x20024000;</code>删减掉，加到如下链接脚本处，发现bootloader可以正常跳转运行了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">._user_heap_stack :</span><br><span class="line">&#123;</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  PROVIDE ( end = . );</span><br><span class="line">  PROVIDE ( _end = . );</span><br><span class="line">  . = . + _Min_Heap_Size;</span><br><span class="line">  . = . + _Min_Stack_Size;</span><br><span class="line">  _estack = .;</span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">&#125; &gt;RAM</span><br></pre></td></tr></table></figure></li></ul><p><strong>问题最终分析：</strong></p><ul><li>app的栈顶指针指向芯片的最大RAM地址，在无bootloader时，程序能够正常运行；加上了bootloader后，存在问题</li><li>此两者区别是：一个是由链接器自动计算堆栈的大小，一个是自己指定栈顶地址</li><li>进一步分析二者对程序可能的影响：</li></ul><hr><h3 id="J-Link仿真器正常，但点击烧录就工作异常"><a href="#J-Link仿真器正常，但点击烧录就工作异常" class="headerlink" title="J-Link仿真器正常，但点击烧录就工作异常"></a>J-Link仿真器正常，但点击烧录就工作异常</h3><ul><li>MCU及元件上电工作，J-Link供电不足 – 插上电源</li><li>芯片在读写保护状态，需要用特定软件解除读保护后，才可烧录</li></ul><hr><h3 id="移植TIMER-PWM驱动时-发现电机出现高频异响"><a href="#移植TIMER-PWM驱动时-发现电机出现高频异响" class="headerlink" title="移植TIMER-PWM驱动时, 发现电机出现高频异响"></a>移植TIMER-PWM驱动时, 发现电机出现高频异响</h3><p><strong>原因分析:</strong></p><ul><li>经检查,高频异响是电机驱动输入pwm频率过高引起的</li><li>而该PWM驱动默认了MCU主频是72MHz, PWM时钟分频为72分频, 以1MHz的定时器时钟来作为基准</li><li>所以当该驱动移植到芯片主频为144MHz时, 使得PWM的频率为之前的两倍</li></ul><p><strong>解决:</strong></p><ul><li>修改该PWM驱动, 以使其更具通用性, 将时钟分频修改为变量形式 &#x3D; 系统时钟频率 &#x2F;1MHz,即可实现在不同主频芯片中的定时器基准频率为1MHz</li></ul><hr><h3 id="应用LiteOS的定时器，出现bug：在软件定时器回调函数中给一个句柄写入消息，其中涉及到阻塞1s申请互斥量操作，但却一直无法写入"><a href="#应用LiteOS的定时器，出现bug：在软件定时器回调函数中给一个句柄写入消息，其中涉及到阻塞1s申请互斥量操作，但却一直无法写入" class="headerlink" title="应用LiteOS的定时器，出现bug：在软件定时器回调函数中给一个句柄写入消息，其中涉及到阻塞1s申请互斥量操作，但却一直无法写入"></a>应用LiteOS的定时器，出现bug：在软件定时器回调函数中给一个句柄写入消息，其中涉及到阻塞1s申请互斥量操作，但却一直无法写入</h3><p><strong>原因分析：</strong></p><ul><li>首先检查日志，发现每次回调函数能被正常执行，但写入操作一直失败。其中为延时获取互斥量失败，但实际上没有延时</li><li>怀疑可能是软件定时器本身就设计不支持阻塞接口操作，所以直接返回；可能是软件设计不当导致的互斥量一直被其它任务所占用</li><li>排查缩小范围</li></ul><p><strong>解决：</strong></p><ul><li>最终确认为在软件定时器线程中，不支持事件、信号量、互斥量相关的操作，相关内核组件运行时，会检查当前线程是否为定时器线程，是——则直接返回错误。</li></ul><hr><h3 id="应用LiteOS信号量，阻塞100tick-等待，程序却卡死在阻塞等待处，另，串口UART4中断函数异常跑飞"><a href="#应用LiteOS信号量，阻塞100tick-等待，程序却卡死在阻塞等待处，另，串口UART4中断函数异常跑飞" class="headerlink" title="应用LiteOS信号量，阻塞100tick 等待，程序却卡死在阻塞等待处，另，串口UART4中断函数异常跑飞"></a>应用LiteOS信号量，阻塞100tick 等待，程序却卡死在阻塞等待处，另，串口UART4中断函数异常跑飞</h3><p>部分源代码节选如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> comm_board_sem;</span><br><span class="line"></span><br><span class="line">LOS_SemCreate(<span class="number">0</span>, &amp;comm_board_sem);</span><br><span class="line"></span><br><span class="line">LOS_SemPost(comm_board_sem);        <span class="comment">// 在串口接收空闲中断处调用</span></span><br><span class="line"></span><br><span class="line">logVerbose(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    result = LOS_SemPend(comm_board_sem, LOS_MS2Tick(<span class="number">100</span>));</span><br><span class="line">logVerbose(<span class="string">&quot;init&quot;</span>); <span class="comment">// 未能执行到此处</span></span><br></pre></td></tr></table></figure><p>通过断点调试，程序卡死在如下处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ****************************************************************************</span></span><br><span class="line"><span class="comment">Function    : ArchSysExit</span></span><br><span class="line"><span class="comment">Description : Task exit function</span></span><br><span class="line"><span class="comment">**************************************************************************** */</span></span><br><span class="line">LITE_OS_SEC_TEXT_MINOR VOID <span class="title function_">ArchSysExit</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    (VOID)LOS_IntLock();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因分析与解决步骤：</strong></p><ol><li>将该线程注释掉，系统能够正常运作，说明是此线程的设计问题</li><li>考虑可能是此处的设计导致了系统线程调度出现问题，在该线程入口函数的for循环内加上断点打印，注射掉<code>LOS_SemPend(comm_board_sem, LOS_MS2Tick(100));</code>，再行调试</li><li>发现程序又卡死在<code>LOS_TaskDelay()</code>中，此时精简后的线程入口函数源码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">comm_board_rx_task</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line"> &#123;</span><br><span class="line">     logVerbose(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">     <span class="type">uint8_t</span> recv_from_rb[<span class="number">256</span>];</span><br><span class="line">     <span class="type">int16_t</span> recv_ret;</span><br><span class="line">     <span class="type">uint8_t</span> interpret_buf[<span class="number">256</span>];</span><br><span class="line">     err_enum unpack_ret = err_ok;</span><br><span class="line">     <span class="keyword">for</span> (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         logVerbose(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">         LOS_TaskDelay(<span class="number">100</span>);</span><br><span class="line">         logVerbose(<span class="string">&quot;xxx&quot;</span>);      <span class="comment">// 无法执行到此处，程序卡死</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>此前该段入口函数在rt-thread中运行无误，在LiteOS中却无法运行，推测可能是在for循环之前定义了几个大数组，其存储位置在线程上下文即 线程栈中</li><li>而系统崩掉的原因应该是线程调度时没有考虑到如此大的数据入栈出栈，从而导致出错</li><li>经过排查和不断的代码注释运行，最终发现是串口的DMA收发初始化，导致程序无法运行 – 判断是uart的驱动问题</li><li>再次排查此前已经验证通过的uart驱动，代码对比无误，进行常规分析：可能是LiteOS的中断注册存在问题、可能是代码的驱动存在冲突、可能中断服务函数并没正确对应注册、可能是初始化步骤存在问题</li><li>经过验证，发现是UART4可能存在问题，另外发现一个奇葩现象，如果开启了UART1驱动的宏定义，UART4能够正常运行；直接现象是USART1的中断服务函数影响到了UART4的中断，但USART1中断函数从没被调用</li><li>毫不相关的USART1函数，却直接导致了UART4的使用问题；</li><li>突发奇想，把编译优化等级从O1改为O0，程序就能正常运行了，有可能是<strong>这部分驱动程序编写不够健壮，也可能是编译选项存在应用不当问题</strong></li><li>继续缩小代码范围，发现了注释与调用某一个变量，会导致程序能运行与否，另外查看其map文件对比，只一个变量的区别 – <strong>怀疑可能是字节对齐的问题</strong></li><li>此外，发现编译选项 <strong>-fdata-sections</strong> 的删减，可使程序正确运行，通过对比删减前后的map文件，发现在函数<code>drv_uart_init()</code>的text段大小差了4个字节；同时在当前文件bss段变量大小也差了4个字节</li><li>考虑代码可能存在以下几个问题：<br>全局变量与外部变量重名，导致的链接错误；<br>变量可能未被正确初始化，或存在一些漏洞</li></ol><hr><h3 id="从N32L406芯片的验证通过的-DMA-USART-TX-RX驱动到N32WB452上-串口DMA发送没能跑起来"><a href="#从N32L406芯片的验证通过的-DMA-USART-TX-RX驱动到N32WB452上-串口DMA发送没能跑起来" class="headerlink" title="从N32L406芯片的验证通过的 DMA-USART TX RX驱动到N32WB452上, 串口DMA发送没能跑起来"></a>从N32L406芯片的验证通过的 DMA-USART TX RX驱动到N32WB452上, 串口DMA发送没能跑起来</h3><p><strong>原因分析:</strong></p><ul><li>通过GDB调试发现DMA_GetCurrDataCounter()的数值一直没变,说明是DMA通道的数据没能发送出去</li><li>查看芯片手册确认DMA通道映射无误,对比确认DMA初始化流程一致</li><li>不同点在于N32WB452加上了LiteOS,在DMA RX驱动处加上了 添加DMA接收完成和UART空闲中断服务函数</li></ul><p><strong>问题解决步骤:</strong></p><ul><li>重复比对初始化步骤,以及断点调试,查看DMA的寄存器配置信息,发现DMA寄存器没有被正确初始化</li><li>确定为驱动初始化的原因, 再次重复确认DMA-UART的结构体初始化信息,发现为信息结构体的位置错位了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drv_uart_dev</span> <span class="title">uart2</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    USART2,</span><br><span class="line">    USART2_IRQn,</span><br><span class="line">    &#123;</span><br><span class="line">        DMA1_CH6,</span><br><span class="line">        DMA1,</span><br><span class="line">        DMA1_FLAG_GL6,</span><br><span class="line">        DMA1_Channel6_IRQn,</span><br><span class="line">        <span class="number">0</span>,                      <span class="comment">// 此处缺少一个 0 变量,导致下面的变量错位</span></span><br><span class="line">        DMA1_CH7,</span><br><span class="line">        DMA1,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drv_uart_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USART_Module *uart_device;</span><br><span class="line">    IRQn_Type irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">drv_uart_dma</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DMA_ChannelType *rx_ch;</span><br><span class="line">        DMA_Module *rx_dma_type;</span><br><span class="line">        <span class="type">uint32_t</span> rx_gl_flag;</span><br><span class="line">        <span class="type">uint8_t</span> rx_irq_ch;</span><br><span class="line">        <span class="type">uint32_t</span> setting_dma_flag;</span><br><span class="line">        <span class="type">uint16_t</span> last_recv_index;</span><br><span class="line"></span><br><span class="line">        DMA_ChannelType *tx_ch;</span><br><span class="line">        DMA_Module *tx_dma_type;</span><br><span class="line">    &#125; dma;</span><br><span class="line">    <span class="type">void</span> (*user_cb)(<span class="keyword">enum</span> uart_dev_name uart_num, <span class="type">uint16_t</span> length);</span><br><span class="line">    structUsertData rx_buf_dev;</span><br><span class="line">    structUserTxData tx_buf_dev;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">uart_dev_name</span> <span class="title">uart_num</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>另外，需要注意串口空闲中断接收时不一定接收的是整包数据，也可能是半包数据即触发了空闲中断，设计中需要考虑规避此现象可能导致的问题</p><hr><h3 id="移植letter-shell组件和LiteOS-开机上电立即打印了letter-shell版本信息-但其后的打印信息阻塞延时了几秒钟-在这期间内-shell完全没任何反应"><a href="#移植letter-shell组件和LiteOS-开机上电立即打印了letter-shell版本信息-但其后的打印信息阻塞延时了几秒钟-在这期间内-shell完全没任何反应" class="headerlink" title="移植letter_shell组件和LiteOS, 开机上电立即打印了letter_shell版本信息, 但其后的打印信息阻塞延时了几秒钟, 在这期间内, shell完全没任何反应"></a>移植letter_shell组件和LiteOS, 开机上电立即打印了letter_shell版本信息, 但其后的打印信息阻塞延时了几秒钟, 在这期间内, shell完全没任何反应</h3><p><strong>现象分析:</strong></p><ul><li>系统时基是从延时后才开始累计, 说明在此前Systick没有跑起来</li><li>一上电就能输出信息</li></ul><p><strong>问题解决步骤:</strong></p><ul><li>在上电正常输出日志处, 和延时处添加日志打印,不断往中间逼近,查找是哪个函数导致的阻塞延时</li><li>通过日志逼近打印,发现是上电初始化时与充电ic的iic通信导致的阻塞延时,并且iic没有通信成功</li><li>iic与SGM41528初始化时序时败,阻塞占用了接近2s的时间,接下来需要排查为何移植LiteOS的 iic通信初始化 超时失败</li><li>通过比较排查,已知: iic通信在刚上电时通信失败,但上电一段时间后,通信正常; 但与移植LiteOS前相比,iic的初始化调用逻辑并没有改变, 接下来需要排查为什么刚上电时的iic初始化失败</li><li>通过调试发现iic初始化时是有ACK回复的,但耗时高</li><li>最后发现是iic驱动中的微秒级延时代码存在问题, 而LiteOS在初始化Systick会配置Systick-&gt;load &#x3D; 0xFFFFFF, 之后启动系统时再次配置为 SystemCoreClock&#x2F;1000, 从而使得问题暴露 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">n32_udelay</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ticks;</span><br><span class="line">    <span class="type">uint32_t</span> told, tnow, tcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> reload = SysTick-&gt;LOAD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ticks = us * reload / (1000000 / DRV_TICK_PER_SECOND);</span></span><br><span class="line">    ticks = us * (SystemCoreClock / <span class="number">1000000</span>); <span class="comment">//需要的节拍数</span></span><br><span class="line">    told = SysTick-&gt;VAL;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow = SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span> (tnow != told)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tnow &lt; told)</span><br><span class="line">            &#123;</span><br><span class="line">                tcnt += told - tnow;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcnt += reload - tnow + told;</span><br><span class="line">            &#125;</span><br><span class="line">            told = tnow;</span><br><span class="line">            <span class="keyword">if</span> (tcnt &gt;= ticks)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中<code>ticks = us * reload / (1000000 / DRV_TICK_PER_SECOND);</code>更新为:<code>ticks = us * (SystemCoreClock / 1000000);</code></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【构建】Makefile学习笔记</title>
      <link href="/2023/12/15/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91Makefile%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/15/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91Makefile%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Makefile 问世并流行多年，互联网上早已拥有海量的相关学习文章、视频及书籍资料。因此这篇文章主要以个人的理解角度，来阐述 Makefile 的学习之路。</p><h2 id="基础知识-概念"><a href="#基础知识-概念" class="headerlink" title="基础知识&#x2F;概念"></a>基础知识&#x2F;概念</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li>符号<code>$</code><br>表示引用定义变量的值 </li><li>符号<code>$@</code><br>目标的集合</li><li>符号<code>$&lt;</code><br>依赖文件集合中的第一个文件；通常依赖文件是以(“%”)定义的，所以其表示为符合模式的一系列文件</li></ul><h3 id="Makefile格式"><a href="#Makefile格式" class="headerlink" title="Makefile格式"></a>Makefile格式</h3><ol><li>直接输入命令make，系统会默认以第一条规则的目标为最终目标; 也可以指定生成目标，比如make main、make clean</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标....： 依赖文件集合...</span><br><span class="line">    命令1</span><br><span class="line">    命令2</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="规则模式与语法"><a href="#规则模式与语法" class="headerlink" title="规则模式与语法"></a>规则模式与语法</h3><ul><li><p>模式规则</p></li><li><p>常用函数</p></li></ul><h2 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a>进阶应用</h2><h3 id="Makefile父子文件配置"><a href="#Makefile父子文件配置" class="headerlink" title="Makefile父子文件配置"></a>Makefile父子文件配置</h3><p>多目录管理</p><p>文件间变量如何共享？</p><p>如何组织工程</p><h3 id="make-menuconfig-原理"><a href="#make-menuconfig-原理" class="headerlink" title="make menuconfig 原理"></a>make menuconfig 原理</h3><h3 id="Automake-原理"><a href="#Automake-原理" class="headerlink" title="Automake 原理"></a>Automake 原理</h3><p>Automake是GNU构建系统的一部分，它旨在简化软件项目的构建过程。Automake通过简化Makefile的编写，提供了一种更加高级和可移植的方式来描述软件项目的构建规则。</p><p>Automake使用一种称为”Makefile.am”的文件来描述构建规则，然后通过”aclocal”、”autoconf”和”automake”等工具生成最终的Makefile。</p><p>使用Automake可以使得构建规则更加清晰、简洁，并且具有更好的可移植性。</p><p>Automake还提供了一些高级功能，如支持多目录构建、自动化依赖关系管理、自动生成文件等。</p><p>这些功能使得Automake成为一个强大的构建工具，特别适用于大型和复杂的软件项目。</p><h2 id="实际工程之应用开发"><a href="#实际工程之应用开发" class="headerlink" title="实际工程之应用开发"></a>实际工程之应用开发</h2><h3 id="在单片机中的应用点"><a href="#在单片机中的应用点" class="headerlink" title="在单片机中的应用点"></a>在单片机中的应用点</h3><p>make 构建编译工程的时候，调用其它可执行程序将 bootloader、app两个bin文件合并为一个镜像文件</p><p>make 相应指令，调用 J-Flash 将编译生成镜像下载到单片机中</p><h3 id="在Linux中的应用点"><a href="#在Linux中的应用点" class="headerlink" title="在Linux中的应用点"></a>在Linux中的应用点</h3><h2 id="注意项及疑惑解答"><a href="#注意项及疑惑解答" class="headerlink" title="注意项及疑惑解答"></a>注意项及疑惑解答</h2><h3 id="Makefile-文件与-mk-文件的区别与联系？"><a href="#Makefile-文件与-mk-文件的区别与联系？" class="headerlink" title="Makefile 文件与 .mk 文件的区别与联系？"></a>Makefile 文件与 .mk 文件的区别与联系？</h3><p>在实际使用中，通常将makefile文件的扩展名命名为.mk或者Makefile。在GNU Make工具中，.mk文件通常用于包含一组相关的规则，而Makefile文件通常用于包含整个项目的构建规则。</p><p>实际上，.mk文件和Makefile文件之间没有本质区别，它们都是Make工具所使用的构建规则文件。</p><p>通常情况下，.mk文件用于包含一组相关的规则，而Makefile文件用于包含整个项目的构建规则，但这只是一种惯例，实际上可以根据项目的需要来命名文件。</p><p>无论是.mk文件还是Makefile文件，它们都是Make工具所使用的构建规则文件，可以包含变量定义、目标规则、依赖关系等内容。</p><p>因此，在实际使用中，可以根据项目的需要来选择使用.mk文件或者Makefile文件，并没有严格的规定。</p><h3 id="在Makefile中，是如何将每个需要编译生成-o目标文件与-c源文件关联起来的"><a href="#在Makefile中，是如何将每个需要编译生成-o目标文件与-c源文件关联起来的" class="headerlink" title="在Makefile中，是如何将每个需要编译生成.o目标文件与.c源文件关联起来的"></a>在Makefile中，是如何将每个需要编译生成.o目标文件与.c源文件关联起来的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># addprefix用于在每个元素前面添加一个前缀：(OUTPUT_DIR)/</span><br><span class="line"># (C_SOURCES:.c=.o)将C源文件的后缀.c替换为.o，使得C_SOURCES中的每个.c都对应相应的.o文件</span><br><span class="line">C_OBJECTS = $(addprefix $(OUTPUT_DIR)/, $(C_SOURCES:.c=.o))</span><br><span class="line"></span><br><span class="line">$(OUTPUT_DIR)/%.o: %.c              # 模式规则，要生成.o文件，则要找到对应的.c</span><br><span class="line">    mkdir -p $(dir $@)              # 如果目录不存在，则创建；(dir@)表示目标文件$@的目录部分</span><br><span class="line">    $(CC) $(INCLUDE) $(CFLAGS) -MMD -c $&lt; -o $@</span><br></pre></td></tr></table></figure><br><h3 id="configure命令"><a href="#configure命令" class="headerlink" title=".&#x2F;configure命令"></a>.&#x2F;configure命令</h3><p>configure脚本由autoconf工具生成，在make命令之前先执行配置；执行此命令，配置编译器、库、工具等参数，并根据此参数生成一个Makefile</p><br>    <h3 id="编译、包含依赖文件，避免重复编译、提高效率"><a href="#编译、包含依赖文件，避免重复编译、提高效率" class="headerlink" title="编译、包含依赖文件，避免重复编译、提高效率"></a>编译、包含依赖文件，避免重复编译、提高效率</h3><p>在编译命令中加入<code>-MMD</code>选项，告诉编译器生成依赖关系文件<br>在Makefile里的目标文件编译规则命令之后，加入<code>-include $(wildcard $(OUTPUT_DIR)/*/*.d)</code></p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无刷电机调试方法简述</title>
      <link href="/2023/12/08/%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/"/>
      <url>/2023/12/08/%E6%97%A0%E5%88%B7%E7%94%B5%E6%9C%BA%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前提知识基础"><a href="#前提知识基础" class="headerlink" title="前提知识基础"></a>前提知识基础</h2><ol><li>需要对PID控制算法有一定了解</li><li>了解FOC算法原理即可，产品开发者无需深入了解FOC算法</li><li>需要熟悉高级定时器的应用</li><li>熟悉电机控制基本概念，对电机极对数、反电动势、电阻采样、DQ轴等等基本知识链需要有一定的认知</li><li>了解三相无刷电机驱动原理</li></ol><h2 id="电机调试流程简述"><a href="#电机调试流程简述" class="headerlink" title="电机调试流程简述"></a>电机调试流程简述</h2><p>本文主要基于峰岹科技的两种产品进行开发简述，分别是三相ASIC和MCU。</p><h3 id="基于FT8215三相ASIC-–-图形化配置开发"><a href="#基于FT8215三相ASIC-–-图形化配置开发" class="headerlink" title="基于FT8215三相ASIC – 图形化配置开发"></a>基于FT8215三相ASIC – 图形化配置开发</h3><p>在此种情况下，图形化配置其实是通过 IIC 通信将配置参数写入 IC 中，然后再通过 PWM、FR、FG 等进行调速、控速、反馈调节等</p><p>当然也可以把上位机集成在 MCU 端，由 MCU 端通过 IIC 进行寄存器配置 ASIC，这样的话，可调节范围以及适应性更广。在每次调节速度、模式、档位的时候，都可先设置配置参数，再进行速度、方向等配置。</p><h3 id="基于FU6815的MCU-–-Keil开发"><a href="#基于FU6815的MCU-–-Keil开发" class="headerlink" title="基于FU6815的MCU – Keil开发"></a>基于FU6815的MCU – Keil开发</h3><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2>]]></content>
      
      
      <categories>
          
          <category> 无刷电机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】Linux U-Boot移植概述-基于I-MX6ULL</title>
      <link href="/2023/12/05/%E3%80%90Linux%E3%80%91Linux-U-Boot%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-%E5%9F%BA%E4%BA%8EI-MX6ULL/"/>
      <url>/2023/12/05/%E3%80%90Linux%E3%80%91Linux-U-Boot%E7%A7%BB%E6%A4%8D%E6%A6%82%E8%BF%B0-%E5%9F%BA%E4%BA%8EI-MX6ULL/</url>
      
        <content type="html"><![CDATA[<h2 id="U-Boot简介"><a href="#U-Boot简介" class="headerlink" title="U-Boot简介"></a>U-Boot简介</h2><p>是一段用于启动Linux内核的bootloader裸机程序，其主要作用是：初始化必要的外设，将Linux内核从源存储拷贝到内存中，最终启动内核</p><h3 id="基于I-MX6ULL的U-Boot的一些开发概念"><a href="#基于I-MX6ULL的U-Boot的一些开发概念" class="headerlink" title="基于I.MX6ULL的U-Boot的一些开发概念"></a>基于I.MX6ULL的U-Boot的一些开发概念</h3><ol><li><p>I.MX通过置位BOOT引脚进行配置选择从SD卡、EMMC、NAND FLASH等等的启动方式</p><br></li><li><p>生成的U-Boot.bin文件需要加上头部（IVT、DCD等数据），然后再烧录到启动存储中</p><br></li><li><p>I.MX上电后先跑芯片内置BootROM程序，把U-Boot加载到内存后，再跳转执行U-Boot</p><br></li><li><p>U-Boot提供命令行交互界面，其可以选择系统从网络启动、从EMMC启动等等</p><br></li><li><p>通常情况下，是参考原厂开发板做硬件，而后在原厂提供的BSP包上做修改</p><br></li></ol><h3 id="基于-I-MX6ULL-的-U-Boot-移植流程简述"><a href="#基于-I-MX6ULL-的-U-Boot-移植流程简述" class="headerlink" title="基于 I.MX6ULL 的 U-Boot 移植流程简述"></a>基于 I.MX6ULL 的 U-Boot 移植流程简述</h3><p>在 U-Boot 官网中找到参考的开发平台，通常是原厂开发板，以其为模板工程，修改移植到私有板子上。</p><ul><li>添加私有板子配置，复制最接近的一份原厂开发板配置文件，重命名为私有板子工程配置文件（包括defconfig、头文件、板级文件夹等）</li><li>添加适配图形化界面配置文件</li><li>驱动适配修改，如LCD驱动、网络驱动等</li></ul><h3 id="U-Boot在I-MX6ULL中的启动流程简述"><a href="#U-Boot在I-MX6ULL中的启动流程简述" class="headerlink" title="U-Boot在I.MX6ULL中的启动流程简述"></a>U-Boot在I.MX6ULL中的启动流程简述</h3><h2 id="U-Boot顶层Makefile详解"><a href="#U-Boot顶层Makefile详解" class="headerlink" title="U-Boot顶层Makefile详解"></a>U-Boot顶层Makefile详解</h2><p>暂略</p><h2 id="U-Boot启动流程详解"><a href="#U-Boot启动流程详解" class="headerlink" title="U-Boot启动流程详解"></a>U-Boot启动流程详解</h2><p>暂略</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="u-boot对内核的参数传递示例"><a href="#u-boot对内核的参数传递示例" class="headerlink" title="u-boot对内核的参数传递示例"></a>u-boot对内核的参数传递示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* boot从网络启动 */</span><br><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.14.18:/home/chenjd/linux/nfs/rootfs,proto=tcp rw ip=192.168.14.99:192.168.14.18:192.168.14.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* boot从emmc启动 */</span><br><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><h4 id="bootargs"><a href="#bootargs" class="headerlink" title="bootargs"></a>bootargs</h4><p>其为 U-Boot 传递给内核的参数，用于控制内核的行为，如设置控制台、指定根文件系统位置、根文件系统类型、启动哪些服务等等</p><h4 id="bootcmd"><a href="#bootcmd" class="headerlink" title="bootcmd"></a>bootcmd</h4><p>其为在 U-Boot 在启动内核之前执行的命令，可以用来初始化硬件、加载内核镜像等等</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://mp.weixin.qq.com/s/B02akrfXbU85OjAn2mBpcA">完全理解ARM启动流程：Uboot-Kernel</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【编程】C语言知识点记录</title>
      <link href="/2023/12/04/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/12/04/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="段的详解"><a href="#段的详解" class="headerlink" title="段的详解"></a>段的详解</h3><ul><li>常规的段：代码段、数据段、BSS段、堆、栈</li><li>init段、符号表段、重定位段、调试信息段、通过attribute指定的段<br>可通过编程将指定的函数链接到指定的段，如init段，实现在main前的初始化，等一系列自定义操作</li><li>链接器在链接过程中会自动生成特殊的符号，用于代表各段的首尾地址<br>如：段名init_array，那么相应的会有<code>__init_array_start</code>或者<code>__start_init_array</code>表示该段的首地址，<code>__init_array_end</code>或<code>__stop_init_array</code>表示该段的末尾地址，不同编译器的表示方式有区别</li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>重复宏定义？</p><ul><li>宏定义的本质是替换，如果同一个宏名定义了两个不同的量，则在编译时可能会替换两次，最终输出的为最后一次宏定义处理的值</li></ul><p>像<code>#if</code>、<code>#include</code>属于预处理指令</p><h3 id="C库集成的宏定义"><a href="#C库集成的宏定义" class="headerlink" title="C库集成的宏定义"></a>C库集成的宏定义</h3><p><code>__VA_ARGS__</code> 是 C 和 C++ 语言中用于处理可变参数宏的一种特殊占位符，用来表示传递给该宏的所有可变参数。</p><ul><li>这个占位符允许宏接收任意数量和类型的参数，并在宏展开时将这些参数原封不动地传递到宏体中的相应位置。</li><li>可变参数宏通常用于定义需要处理不定数量参数的宏函数，如常见的日志打印、调试输出等场合。</li></ul><p><code>__DATE__</code>：字符串，为编译时的当前系统日期、时间<br><code>__FILE__</code>：打印处的.c文件名<br><code>__LINE__</code>：整型变量，为打印处的行号<br><code>__TIME__</code>：字符串，编译时的系统时间<br><code>__func__</code>：打印处的函数名</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[%s %s] %s: %s: %d\n&quot;</span>, __DATE__, __TIME__, __FILE__, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，将会输出：<code>[2024-01-29 14:54:25] main.c:main: 12</code></p><br><h3 id="pragma-pack-n-指令"><a href="#pragma-pack-n-指令" class="headerlink" title="#pragma pack(n)指令"></a><code>#pragma pack(n)</code>指令</h3><p><code>#pragma pack(n)</code>是C语言中的预处理指令，用于设置结构体或者联合体的成员变量对齐的宽度都为<code>n</code></p><ul><li><code>__attribute__((packed))</code> 修饰符可以指定结构体成员按照最小的对齐方式，而 <code>#pragma pack()</code> 指令只能指定结构体成员按照指定的对齐方式</li><li>常规的变量，如<code>int</code>、<code>char</code>等由编译器默认设置，不受该指令影响</li><li><code>__attribute__((packed)) </code>修饰符的作用域仅限于其所在的语句块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用域位于#pragma pack(1) 与 #pragma pack()之间</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下结构体占用5个字节，而非8个字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="attribute-关键字"><a href="#attribute-关键字" class="headerlink" title="__attribute__ 关键字"></a><code>__attribute__</code> 关键字</h3><p><code>__attribute__((weak))</code><br><code>__attribute__((constructor))</code><br><br></p><p><code>__attribute__((packed))</code>属性用于指定结构体或联合体的成员变量按照实际占用字节数进行对齐（按照最小的对齐方式）</p><ul><li>使用此属性可能会导致效率降低，因为 CPU 可能需要进行额外的操作来访问非对齐的数据</li><li>其可以减少结构体和联合体的大小，节省内存空间</li><li>如下代码所示，不加<code>__attribute__((packed))</code>属性的地址为 a:0 b:2 c:4，占用8个字节；加属性修饰后的地址为 a:0 b:1 c:3，占用7个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>   a;</span><br><span class="line">    <span class="type">uint16_t</span>  b;</span><br><span class="line">    <span class="type">uint32_t</span>  c;</span><br><span class="line">&#125;</span><br><span class="line">time_desc;</span><br></pre></td></tr></table></figure><br></li></ul><p><code>__attribute__((__used__))</code> 告知编译器：即使修饰的对象在编译过程中没有被引用，也要保留</p><ul><li>建议在C源文件中的汇编函数前加上,以避免高优化等级时其被优化掉<br></li></ul><p><code>__attribute__((__section__(&quot;my_section&quot;)))</code> 表示将修饰的对象放在名为<code>my_section</code>的段中</p><ul><li>在C文件中编程，一般可以通过特殊的符号来获取attribute声明的段的首末地址，其由链接器在链接过程中自动定义<br></li></ul><p><strong>示例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  __used  __attribute__((__used__))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">initcall_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __define_initcall(fn) \</span></span><br><span class="line"><span class="meta">    static const initcall_t __initcall_##fn##id __used \</span></span><br><span class="line"><span class="meta">    __attribute__((__section__(<span class="string">&quot;initcall_system_init&quot;</span>))) = fn; </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_SYSTEM_EXPORT(fn)      __define_initcall(fn)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>应用示例2：</strong> 定义系列 赋值为函数指针的静态常量，将其声明到指定的段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> __start_my_section[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> __stop_my_section[];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *start = __start_my_section;</span><br><span class="line"><span class="type">char</span> *end = __stop_my_section;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*func_ptr)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (func_ptr *f = (func_ptr *)__start_my_section; f &lt; (func_ptr *)__stop_my_section; ++f) &#123;</span><br><span class="line">    (*f)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><p>当在case语句内定义变量时，需要在case语句内 加花括号限定变量的作用域，否则编译会报错，因为局部变量的生存周期在其最近的代码块范围内</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="静态局部变量，能被外界所访问吗？"><a href="#静态局部变量，能被外界所访问吗？" class="headerlink" title="静态局部变量，能被外界所访问吗？"></a>静态局部变量，能被外界所访问吗？</h3><p>将其地址传递出去即可，因为静态变量的地址在编译时已经确定，其生存在整个程序运行期间</p><h3 id="在函数内部声明结构体或者联合体类型"><a href="#在函数内部声明结构体或者联合体类型" class="headerlink" title="在函数内部声明结构体或者联合体类型"></a>在函数内部声明结构体或者联合体类型</h3><p>如果某个结构体或者联合体变量类型仅为一个函数所私有，则可以将该结构体&#x2F;联合体定义在 函数内部 或者 特定的代码块内，使得其不可见于其它模块，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> xxx:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MODE_MCU_GET_OTA_DATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以下变量定义仅在当前case语句内的代码块范围可见</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">uint16_t</span> ota_packet_index;</span><br><span class="line">            <span class="type">uint8_t</span> file_data[];</span><br><span class="line">        &#125; recv_ota_packet;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">break</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数入参为int变量指针时，可以传递u8变量指针吗？"><a href="#函数入参为int变量指针时，可以传递u8变量指针吗？" class="headerlink" title="函数入参为int变量指针时，可以传递u8变量指针吗？"></a>函数入参为int变量指针时，可以传递u8变量指针吗？</h3><p>此种情况下可以通过编译，但强烈不建议这么做</p><p>因为函数内部访问操作int变量，是以4字节为单位的。如果实际传入的是u8变量指针，那么函数在操作变量时，会超出u8变量的内存范围</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h3><p>可变参数函数的原理是基于函数调用时，参数从右往左压栈的原理。</p><p><code>va_list</code>、<code>va_start</code>和<code>va_end</code>是C语言中用于处理可变参数的宏，在C语言中编写可变参数函数，首先要<code>#include &lt;stdarg.h&gt;</code></p><p><code>va_list</code>：<code>va_list</code>是一种类型，用于声明一个可变参数列表指针。它本质上是一个指向堆栈中某个位置的指针。该位置存储了可变参数列表中第一个参数的地址</p><p><code>va_start</code>：用于初始化一个可变参数列表。它接受两个参数：ap,指向可变参数列表的指针；arg，最后一个固定参数。</p><p><code>va_arg</code>：用于获取可变参数列表中的参数。它接受两个参数：ap，指向可变参数列表的指针；type，要获取的参数的类型。其会将ap指针指向下一个参数的位置，并返回该位置的值</p><p><code>va_end</code>：用于结束一个可变参数列表。它接受一个参数：ap，指向可变参数列表的指针。va_end宏会清理ap指针，使其不再指向可变参数列表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n, ...)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  va_start(ap, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> arg = va_arg(ap, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>在C语言中，可变参数函数如果调用时n的大小与实际参数个数不符合，可能会出现以下情况：</p><ul><li>如果n的值小于实际参数个数，则会导致函数无法获取所有参数</li><li>如果n的值大于实际参数个数，则会导致函数获取到多余的无效参数</li></ul><h3 id="main-类型函数"><a href="#main-类型函数" class="headerlink" title="main()类型函数"></a>main()类型函数</h3><p>在单片机开发中，通常为<code>int main(void)</code>的定义形式，因为其启动源码文件已有汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bl  main</span><br><span class="line">bx  lr    </span><br></pre></td></tr></table></figure><p>而常见的<code>main</code>函数定义方式为<code>int main(int argc, char *argv[])</code>，其用于处理命令行参数。在嵌入式中开发中，也可以引出<code>int function(argc, char *argv) &#123; &#125;</code>类型的命令行调试函数</p><p>其中，<code>argc</code>是一个整数，表示命令行参数的数量，并且该值至少为 1。（函数的名称算作一个参数）</p><p><code>argv[0]</code>是函数名字符串，<code>argv[1]</code>到<code>argv[argc-1]</code>是命令行参数，当然了这些参数都是字符串</p><h3 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h3><p>对于<code>printf</code>、<code>sprintf</code>等格式化输出函数</p><ul><li>对于<code>%.2d %2d %02d</code>以及其它的数字指定宽度输出，其会在宽度不足时补足，但<strong>若宽度超出，则会按照实际宽度输出</strong></li><li>对于<code>%s %2s %.2s</code>相关的字符串输出，当超出时，其中<code>%.2s</code>会截取前两位字符输出，其它按照实际宽度输出</li><li>部分测试代码及输出结果如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">300</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%.2d\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%02d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%.2d\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a=%02d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> b[] = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=%s\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=%2s\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b=%.2s\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c[] = <span class="string">&quot;he&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c=%s\n&quot;</span>, c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c=%4s\n&quot;</span>, c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c=%.4s\n&quot;</span>, c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=300</span><br><span class="line">a=300</span><br><span class="line">a=300</span><br><span class="line">a=3</span><br><span class="line">a=03</span><br><span class="line">a=03</span><br><span class="line">b=hello, world</span><br><span class="line">b=hello, world</span><br><span class="line">b=he</span><br><span class="line">c=he</span><br><span class="line">c=  he</span><br><span class="line">c=he</span><br></pre></td></tr></table></figure></li></ul><h2 id="疑惑解答"><a href="#疑惑解答" class="headerlink" title="疑惑解答"></a>疑惑解答</h2><h3 id="如果强制转换调用函数指针的入参与实际函数入参的-数量或者类型-不一致，会如何？"><a href="#如果强制转换调用函数指针的入参与实际函数入参的-数量或者类型-不一致，会如何？" class="headerlink" title="如果强制转换调用函数指针的入参与实际函数入参的 数量或者类型 不一致，会如何？"></a>如果强制转换调用函数指针的入参与实际函数入参的 数量或者类型 不一致，会如何？</h3><p>函数参数的类型检查是在编译阶段进行的，如果传入的参数类型不正确，可能会导致未定义的行为错误。</p><p>函数指针的声明 int (*func)() 表示 func 是一个指向函数的指针，这个函数接受任意数量和类型的参数，并返回一个整数。这种声明方式在C89和C99标准中都是有效的。</p><p>在 C89&#x2F;C99&#x2F;GNU89&#x2F;GNU99 编译标准中，可以通过声明<code>int (*func)()</code>函数指针，调用时传入可变的参数即可，但不建议这样做。建议使用可变参数列表来声明。</p><h3 id="结构体应用指针和柔性数组将缓冲区解释为包结构的试验"><a href="#结构体应用指针和柔性数组将缓冲区解释为包结构的试验" class="headerlink" title="结构体应用指针和柔性数组将缓冲区解释为包结构的试验"></a>结构体应用指针和柔性数组将缓冲区解释为包结构的试验</h3><p>在对特定数据缓冲区解释的设计中，可以通过搭配柔性数组的方式进行数据类型转换，当然在此情况中，指针不可直接等同于数组（数组会直接等同于转换的缓冲数据，而指针需要先指向有效空间地址，否则会报错），以下为测试代码及结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; force_packet_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">&#125; force_packet_2;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">force_pointer_convert1</span><span class="params">(<span class="type">uint8_t</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    force_packet_1 *data = (force_packet_1 *)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;convert1: cmd=[%d], data= %d %d %d %d %d\n&quot;</span>, data-&gt;cmd, data-&gt;data[<span class="number">0</span>],data-&gt;data[<span class="number">1</span>],data-&gt;data[<span class="number">2</span>],data-&gt;data[<span class="number">3</span>],data-&gt;data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;convert1: %p %p\n&quot;</span>, data, data-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">force_pointer_convert2</span><span class="params">(<span class="type">uint8_t</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    force_packet_2 data;</span><br><span class="line">    data.cmd = buf[<span class="number">0</span>];</span><br><span class="line">    data.data = &amp;buf[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;convert2: cmd=[%d], data= %d %d %d %d %d\n&quot;</span>, data.cmd, data.data[<span class="number">0</span>],data.data[<span class="number">1</span>],data.data[<span class="number">2</span>],data.data[<span class="number">3</span>],data.data[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;convert2: %p %p\n&quot;</span>, data, data.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> data_buf[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;convert1 size=[%ld], convert2 size=[%ld]\n&quot;</span>, <span class="keyword">sizeof</span>(force_packet_1), <span class="keyword">sizeof</span>(force_packet_2));</span><br><span class="line">    force_pointer_convert1(data_buf);</span><br><span class="line">    force_pointer_convert2(data_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">convert1 size=[1], convert2 size=[9]</span><br><span class="line">convert1: cmd=[1], data= 2 3 4 5 6</span><br><span class="line">convert1: 0x7f80fa331010 0x7f80fa331011</span><br><span class="line">convert2: cmd=[1], data= 2 3 4 5 6</span><br><span class="line">convert2: 0x7f80fa331011 0x7f80fa331011</span><br></pre></td></tr></table></figure><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.zhihu.com/question/385731065">c语言怎样设置一个函数，可以接受任何类型的参数并返回int型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】ARM架构及相关概念</title>
      <link href="/2023/12/04/%E3%80%90MCU%E3%80%91ARM%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/12/04/%E3%80%90MCU%E3%80%91ARM%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><h3 id="Thumb指令集"><a href="#Thumb指令集" class="headerlink" title="Thumb指令集"></a>Thumb指令集</h3><p>其是ARM指令集的一个子集，16位的代码宽度</p><h2 id="哈佛架构与冯诺依曼架构"><a href="#哈佛架构与冯诺依曼架构" class="headerlink" title="哈佛架构与冯诺依曼架构"></a>哈佛架构与冯诺依曼架构</h2><h2 id="CPU寄存器"><a href="#CPU寄存器" class="headerlink" title="CPU寄存器"></a>CPU寄存器</h2><p><strong>通用寄存器：</strong>R0-R15</p><ul><li>R0-R3：在函数调用时，用于传递前四个参数；函数调用结束后，R0通常用于存储函数返回值</li><li>R4-R11：通用寄存器，主要用于存储局部变量。触发OS PendSV&#x2F;SVC 异常时，Cortex-M内核并不会自动压栈弹栈此部分寄存器值，须由用户RTOS程序手动压栈弹栈</li><li>R12：通用寄存器，</li><li>R13（SP）：用作堆栈指针，Cortex-M3&#x2F;4 内核在物理上存在两个堆栈指针</li><li>R14（LR）：存储函数返回地址，当函数被调用时，LR保存调用函数的返回地址。函数返回时，R14会将返回地址写入程序计数器，使程序返回到调用函数</li><li>R15（PC）：指向下一条要执行指令的地址</li></ul><p><strong>特殊寄存器：</strong></p><ul><li>程序状态字寄存器组（PSRs）：</li><li>中断屏蔽寄存器组（PRIMASK、FAULTMASK、BASEPRI）</li><li>控制寄存器（CONTROL）：</li><li>浮点寄存器</li></ul><p>帧指针（FP）：取决于编译器和编译选择，选择一个通用寄存器，在函数调用栈中跟踪堆栈帧的位置</p><h3 id="ARM不同内核架构的CPU寄存器组异同"><a href="#ARM不同内核架构的CPU寄存器组异同" class="headerlink" title="ARM不同内核架构的CPU寄存器组异同"></a>ARM不同内核架构的CPU寄存器组异同</h3><p>如：Cortex-M系列只有两种运行模式：特权模式和非特权模式，其中通用寄存器组是共用的，但堆栈指针 R13（PSP、MSP）是各模式独有的</p><p>如：Cortex-A7 有 9 种运行模式，每一种运行模式都有一组与之对应的寄存器组。</p><ul><li>每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个程序计数器 PC</li><li>在这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的</li><li>Cortex-A系列内核的各模式下的所有CPU寄存器总计：34个通用寄存器、8个状态寄存器、Hyp 模式下独有一个 ELR_Hyp 寄存器</li></ul><h2 id="Cortex-M内核"><a href="#Cortex-M内核" class="headerlink" title="Cortex-M内核"></a>Cortex-M内核</h2><p>在 Cortex-M 内核中，中断和异常都由 NVIC（Nested Vectored Interrupt Controller）来管理。NVIC 是一个硬件模块，负责处理来自外部或内部的所有中断和异常<br><br></p><p>中断是指来自外部或内部事件的请求，如定时器超时、外部引脚中断<br><br></p><p>异常是CPU执行程序发生的错误处理（如：内存访问非法、除零）或者主动软件触发异常，包括PendSV、HardFault等异常<br><br></p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h4 id="glue-7、glue-7t-和-eh-frame"><a href="#glue-7、glue-7t-和-eh-frame" class="headerlink" title="glue_7、glue_7t 和 eh_frame"></a>glue_7、glue_7t 和 eh_frame</h4><ul><li><p>glue_7 和 glue_7t 是 ARM 架构中用于将 ARM 代码和 Thumb 代码粘合在一起的代码。</p></li><li><p>ARM 架构支持两种指令集：ARM 指令集和 Thumb 指令集。ARM 指令集是 32 位指令集，而 Thumb 指令集是 16 位指令集。为了兼容两种指令集，ARM 架构中引入了一种称为 Thumb 嵌入 的机制。</p></li><li><p>Thumb 嵌入允许 ARM 代码中嵌入 Thumb 指令，反之亦然。当 ARM 代码中嵌入 Thumb 指令时，连接器会生成 glue_7 或 glue_7t  section 来将 ARM 代码和 Thumb 代码粘合在一起。</p></li><li><p>eh_frame 是异常处理框架（Exception Handling Frame）的缩写。异常处理框架是用于支持异常处理的一种结构。当程序发生异常时，异常处理框架会保存程序的运行状态，并将程序转到异常处理程序。</p></li><li><p>异常处理框架通常包含以下信息：<br>  程序的堆栈指针（SP）<br>  程序的返回地址（LR）<br>  异常发生时的寄存器值</p></li><li><p>eh_frame section 包含了异常处理框架的信息。当程序发生异常时，连接器会将 eh_frame section 加载到内存中，以便异常处理程序可以访问异常处理框架的信息</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】通过VSCode + GDB 搭建WSL下的嵌入式MCU调试环境</title>
      <link href="/2023/12/04/%E3%80%90MCU%E3%80%91%E9%80%9A%E8%BF%87VSCode-GDB-%E6%90%AD%E5%BB%BAWSL%E4%B8%8B%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8Fmcu%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/12/04/%E3%80%90MCU%E3%80%91%E9%80%9A%E8%BF%87VSCode-GDB-%E6%90%AD%E5%BB%BAWSL%E4%B8%8B%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8Fmcu%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此前在Keil集成IDE环境下开发，编辑编译调试一体化，无须关心过多底层事项。但由于各种原因，需要经常在Linux环境开发，因此也就顺势把工作中MCU开发的相关项目搬到WSL下了，本人使用的是<code>arm-none-eabi-gcc</code>工具链，构建方式为<code>Make</code>，编辑开发方式为 VSCode + Remote Explorer，调试器硬件为 ARM V9 仿真器，调试接口为 SWD。</p><p>其实本人一直很少使用在线调试，一般是通过 串口 信息打印作为维测方法，只要在模板工程成功运行之后，基本就不需要在线调试了。但初次移植、或者搭建工程，程序异常跑飞，甚至串口都无信息输出的情况下，或许就需要在线调试查找原因了。</p><p>本文介绍一种简单的 通过 VSCode + J-Link 调试方法，此过程基本不涉及任何 GDB 命令，纯粹是 VSCode 集成的 GDB 界面操作。</p><h2 id="软件环境准备"><a href="#软件环境准备" class="headerlink" title="软件环境准备"></a>软件环境准备</h2><ul><li>Windows下J-Link软件安装</li><li>WSL</li><li>VSCode<ul><li>插件安装：C&#x2F;C++, WSL,</li></ul></li></ul><p>以上，前提条件是需要先搭建好在 WSL 下的编译开发环境，主要为<code>arm-none-eabi-</code>工具链安装。</p><p>配置调试的思路为：</p><ul><li>在Windows下打开<code>JLinkGDBServer.exe</code>，配置将调试器成功连接目标板，J-Link本地流量端口通常为 2331</li><li>使用 VSCode 登陆 WSL，应用其<code>Run and Debug</code>功能，主要为配置<code>launch.json</code>文件，包括<code>*.elf</code>文件路径、<code>arm-none-eabi-gdb</code>命令路径等</li></ul><p>完成上述两点操作，即可在 VSCode 环境下开启 GDB 调试了</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>将ARM仿真器与目标嵌入式设备连线</li><li>在Windows下J-Link的安装目录下，找到<code>JLinkGDBServer.exe</code>，点击打开，选择目标调试嵌入式设备</li></ol><p><img src="/../pictures/2023-12-04%20J-Link.png" alt="GDB Server config"></p><br><p><img src="/../pictures/2023-12-04%20j-link%20GDB.png" alt="J-Link GDB Server"></p><ol start="3"><li>在Windows下使用VSCode登陆WSL，打开源码所在工程文件夹，作为VSCode工作区</li><li>点击”Run and Debug”，选择GDB（C）调试，并提示需要配置launch.json文件，配置完成即可开始调试</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#launch.json文件</span><br><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Debug with J-Link&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/app.elf&quot;,  // .elf文件路径</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;/home/chenjd/harmony/gcc-arm-none-eabi-9-2019-q4-major/bin/arm-none-eabi-gdb&quot;,   // WSL下的arm-none-eabi-gdb工具链路径</span><br><span class="line">            &quot;miDebuggerServerAddress&quot;: &quot;localhost:2331&quot;,        // J-Link端口，通常为2331</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://hhuysqt.github.io/gdb%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">gdb调试stm32的技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WSL </category>
          
          <category> 环境搭建 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> VSCode </tag>
            
            <tag> GDB </tag>
            
            <tag> J-Link </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【构建】编译/链接原理及其在开发中之体现</title>
      <link href="/2023/12/01/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%88%91%E8%A7%81/"/>
      <url>/2023/12/01/%E3%80%90%E6%9E%84%E5%BB%BA%E3%80%91%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E6%88%91%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="构建C工程中的一些疑惑解答"><a href="#构建C工程中的一些疑惑解答" class="headerlink" title="构建C工程中的一些疑惑解答"></a>构建C工程中的一些疑惑解答</h2><p>#include “.c”文件 可行吗？</p><blockquote><p>#include 指令执行在预处理阶段<br>主要用于包含头文件（.h 文件），以便在编译时插入对应的声明和宏定义等内容<br>理论上可行，但不推荐。要按照规范，.h用于声明，.c用于实现，利于阅读、模块化组织</p></blockquote><p>链接脚本与汇编源文件、C源文件的联系</p><blockquote><p>链接脚本是用于指示链接器如何链接代码、数据的描述文件</p></blockquote><hr><ul><li>四字节对齐：要求数据的存放起始地址必须是4的倍数<br>作用：<br>1、数据结构按照4字节对齐，使得处理器更有效访问，32位系统可以一次读完一个4字节长度变量<br>2、某些硬件要求数据需要在特定的边界上对齐，否则可能出现异常<br>  如STM32，Flash的写入、DMA访问、结构体成员、线程栈PSP、<strong>指针变量</strong>都需要考虑字节对齐<br>3、结构体本身没有4字节对齐，进行特定的跳转读取，可能导致异常</li></ul><hr><h2 id="与编译链接相关之实用小知识"><a href="#与编译链接相关之实用小知识" class="headerlink" title="与编译链接相关之实用小知识"></a>与编译链接相关之实用小知识</h2><h3 id="printf重定向至串口"><a href="#printf重定向至串口" class="headerlink" title="printf重定向至串口"></a>printf重定向至串口</h3><p>开发调试时可以通过printf进行信息打印输出，但是通常编译器默认将printf重定向至屏幕，可以通过重定向至串口来输出：</p><ul><li><code>printf</code>是C标准库用于格式化输出到标准输出(stdout)的函数，其在<strong>C标准库里内会调用到接口<code>_write</code>，该接口是个弱函数，默认实现是输出至屏幕</strong>。</li><li>那么用户可以自行实现<code>_write</code>函数，将数据输出至串口。编译器链接时会链接到用户自行实现的<code>_write</code>函数，而非默认的弱符号修饰的<code>_write</code>函数。</li></ul><p>当然，不同C库的实现方式也不同，这里以<code>gcc nano</code>为例。（其它C库如 ARM-microlib，或者 newlib 等，其重定向时不一定为重写<code>_write</code>函数，可能是<code>_io_putchar</code>函数、<code>_putchar</code>、<code>fputc</code>函数等）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _write(<span class="type">int</span> fd, <span class="type">char</span>* data, <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    drv_uart_write(DEV_UART1, (<span class="type">uint8_t</span> *)data, len);    <span class="comment">// 由开发者自行实现此接口</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非典型知识"><a href="#非典型知识" class="headerlink" title="非典型知识"></a>非典型知识</h2><h3 id="a静态库文件和-o目标文件、-elf文件"><a href="#a静态库文件和-o目标文件、-elf文件" class="headerlink" title=".a静态库文件和.o目标文件、.elf文件"></a>.a静态库文件和.o目标文件、.elf文件</h3><p><strong>ELF文件格式：</strong> 一种广泛使用的文件格式，主要用于UNIX和类UNIX系统，包括Linux。ELF文件格式是Linux系统中程序编译、链接和加载的基础。它允许开发者创建模块化、可重定位的程序，并支持动态链接和加载<br>类型：可执行文件、可重定位文件（.o）、共享对象文件（.so 动态库）</p><p>ELF头部（ELF Header）：描述了文件的总体特性，如文件类型、目标机器架构、程序入口地址、程序头表和节头表的位置等。<br>程序头表（Program Header Table）：列举了所有的段（segments），以及它们的属性，如加载到内存的地址、在文件中的偏移量、大小等。<br>节头表（Section Header Table）：包含了文件中各个节（sections）的描述，每个节包含了程序的一部分，如代码、数据或符号表。<br>节（Sections）：包含了实际的程序代码和数据，以及调试信息、符号表等辅助信息。<br>段（Segments）：在可执行文件或动态链接库中，节被组织成段，每个段代表一个内存区域，如文本段（代码）、数据段（初始化数据）和BSS段（未初始化数据）。<br><br></p><p><strong>.elf文件：</strong> .elf 文件是遵循 ELF 格式的二进制文件，其是链接器处理多个 .o 文件后的产物。.o 文件是构成 .elf 文件的基本单元，多个 .o 文件通过链接器链接成一个 .elf 文件<br>内容：包含完整的可执行或可链接的代码和数据，包括.o文件的内容、重定位信息、节区信息、动态链接信息、调试信息等<br>作用：.elf 文件可以直接在支持ELF格式的操作系统上运行，或者作为动态库被其他程序加载。<br>特点：.elf 文件拥有实际的内存地址信息，因为它经过了链接器的地址分配和重定位</p><blockquote><p>在嵌入式设备上运行时，往往需要将其转换为不含调试信息且更适合加载到目标硬件的 .bin 或 .hex 格式</p></blockquote><br><p><strong>.o文件：</strong> 格式由目标体系结构决定，通常为<code>ELF</code>，.o 文件是编译器（compiler）处理源代码文件（如 .c 或 .cpp）后的结果<br>内容：</p><ul><li>文件头：记录了文件的类型、大小、目标体系结构、编译器版本等</li><li>代码段：包含了函数的代码，如操作码、数据段、代码段</li><li>数据段：包含了函数的静态数据，如全局变量、静态变量</li><li>符号表：记录了.o文件中所有符号的名称和地址，其可以是函数、变量、常量等</li><li>重定位表：记录了.o文件之间相互引用的符号的地址<blockquote><p>如：如果一个.o文件中有一个函数foo()，另一个.o文件中有一个变量a，而变量a的值由函数foo()返回，则需要在两个.o文件之间建立重定位关系</p></blockquote></li></ul><br><p><strong>.a文件格式：</strong> 静态库文件，由多个.o文件链接而成</p><ul><li>.o文件的列表</li><li>符号表：记录了文件中所有符号的名称和地址。符号可以是函数、变量、常量等</li><li>重定位表：用于记录两个文件之间相互引用的符号的地址</li></ul><blockquote><p>程序链接时，链接器会根据.a文件中的符号表和重定位表，将.a文件中的代码和数据链接到程序中</p></blockquote><p><strong>nm命令</strong>：用于查看目标文件（.o文件）和库文件（.a文件）中的符号表<strong>（-a：显示所有符号，-g：显示符号类型、地址、符号表中索引，-r：显示符号的重定位信息）</strong></p><blockquote><p>nm XXX.a</p></blockquote><p><strong>objdump命令</strong>：objdump命令用于反汇编目标文件（.o文件）和库文件（.a文件）<strong>（-d：反汇编代码段，-s：显示数据段，-t：显示符号表）</strong></p><blockquote><p>objdump -t 1.o</p></blockquote><p><strong>readelf命令</strong>：readelf命令用于查看目标文件（.o文件）和库文件（.a文件）的文件头、代码段、数据段等信息（-h：显示文件头信息，-S：显示代码段信息，-D：显示数据段信息）</p><blockquote><p>readelf -h XXX.a</p></blockquote><hr><h2 id="C程序开发注意点"><a href="#C程序开发注意点" class="headerlink" title="C程序开发注意点"></a>C程序开发注意点</h2><h3 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h3><ul><li>避免冗余的头文件包含，只有当用到时才添加其头文件</li><li>头文件在预处理阶段会被复制到源文件中，过多包含不必要头文件会使得编译时间增加</li><li>头文件中定义了相同变量、函数等，可能会引起不必要的冲突；或会使得链接器产出些潜在的错误链接问题</li><li>尽量不要在头文件中包含头文件</li></ul><h3 id="修改编译优化级别"><a href="#修改编译优化级别" class="headerlink" title="修改编译优化级别"></a>修改编译优化级别</h3><ul><li><p>改变编译等级可能会导致程序运行出错</p><ul><li>提高优化级别时出错，可考虑以下：<blockquote><p>程序中没有放置正确的内存屏障，优化导致的乱序执行可能有问题<br>  部分代码设计需要严谨考虑时序性<br>  可能会忽略了链接脚本中指定的四字节对齐</p></blockquote></li><li>降低优化级别时出错：<blockquote><p>线程的堆栈可能偏小，导致栈溢出</p></blockquote></li></ul></li><li><p>修改编译等级后导致运行出错的问题排查思路</p></li></ul><h2 id="C编译过程"><a href="#C编译过程" class="headerlink" title="C编译过程"></a>C编译过程</h2><p>编译器的主要工作流程如下：</p><blockquote><p>源程序(source code)→预处理器(preprocessor)→编译器(compiler)→汇编程序(assembler)→目标程序(object code)→连接器(链接器，Linker)→可执行程序(executables)</p></blockquote><ul><li>配置</li><li>确定标准库和头文件位置</li><li>确定依赖关系</li><li>头文件预编译</li><li>预处理</li><li>编译</li><li>链接</li><li>安装</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://www.cnblogs.com/gongxianjin/p/16906719.html">ELF文件格式简介 — 见过最细致的ELF讲解</a></li><li><a href="https://www.jianshu.com/p/fa7d5554aca3">【硬核干货 | 程序的编译、链接、装载与运行】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Harmony】LiteOS适配及开发笔记</title>
      <link href="/2023/11/29/%E3%80%90Harmony%E3%80%91%E5%BF%83%E5%BE%97%EF%BC%9ALiteOS%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2023/11/29/%E3%80%90Harmony%E3%80%91%E5%BF%83%E5%BE%97%EF%BC%9ALiteOS%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>暂略</p><p>通常用户对LiteOS的初始化调用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main():</span><br><span class="line">    LOS_KernelInit();       // 内核初始化</span><br><span class="line">    LiteOS_Task_sample();   // 用户业务代码，创建初始任务等</span><br><span class="line">    LOS_Start();            // 开启调度</span><br></pre></td></tr></table></figure><h2 id="开发适配"><a href="#开发适配" class="headerlink" title="开发适配"></a>开发适配</h2><h3 id="LiteOS-M的shell组件适配"><a href="#LiteOS-M的shell组件适配" class="headerlink" title="LiteOS-M的shell组件适配"></a>LiteOS-M的shell组件适配</h3><p>LiteOS-M添加shell组件，主要思路为：</p><ul><li>适配对接指定的串口读写接口，并配置串口接收中断触发写指定的shell事件：<code>g_shellInputEvent</code>，使得shell线程能够接收事件读取uart数据</li><li>在配置文件中启用<code>LOSCFG_USE_SHELL</code>相关宏定义，等，使得相关源代码编译链接</li><li>调用指定的初始化接口<code>LosShellInit()</code><br></li></ul><p><strong>以下为本人之适配代码片段摘选，驱动接口参考实现即可，不拘泥于形式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// uart.h</span><br><span class="line">extern EVENT_CB_S g_shellInputEvent;</span><br><span class="line"></span><br><span class="line">VOID ShellUartInit(VOID);</span><br><span class="line">INT32 UartPutc(INT32 c, VOID *file);</span><br><span class="line">uint8_t UartGetc(VOID);</span><br><span class="line"></span><br><span class="line">// uart_shell.c</span><br><span class="line"></span><br><span class="line">// 适配接口</span><br><span class="line">INT32 UartPutc(INT32 ch, VOID *file)</span><br><span class="line">&#123;</span><br><span class="line">    char RL = &#x27;\r&#x27;;</span><br><span class="line">    if (ch == &#x27;\n&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        drv_uart_write(DEV_UART1, (uint8_t *)&amp;RL, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    drv_uart_write(DEV_UART1, (uint8_t *)&amp;ch, 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配接口实现，由用户自己实现</span><br><span class="line">uint8_t UartGetc(void)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t data;</span><br><span class="line"></span><br><span class="line">    if (drv_uart_read(DEV_UART1, &amp;data, 1) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册uart1接收中断，当收到一帧数据时，向shell线程阻塞等的事件写标志，触发shell线程读取接收数据并处理</span><br><span class="line">void uart1_receive_cb(enum uart_dev_name uart_num, uint16_t length)</span><br><span class="line">&#123;</span><br><span class="line">    (void)LOS_EventWrite(&amp;g_shellInputEvent, 0x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID ShellUartInit(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    drv_uart_set_rx_indicate(DEV_UART1, uart1_receive_cb);</span><br><span class="line">    LosShellInit();     // 由用户调用，初始化shell线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LiteOS中断管理之SysTick"><a href="#LiteOS中断管理之SysTick" class="headerlink" title="LiteOS中断管理之SysTick"></a>LiteOS中断管理之SysTick</h3><p>主要介绍LiteOS如何重建中断映射向量、自定义SysTick中断服务函数、初始化SysTick时基</p><h4 id="LiteOS中断映射表初始化"><a href="#LiteOS中断映射表初始化" class="headerlink" title="LiteOS中断映射表初始化"></a>LiteOS中断映射表初始化</h4><ul><li>函数调用顺序：<code>LOS_KernelInit() -&gt; ArchInit() -&gt; HalHwiInit()</code></li></ul><p>如下代码<code>SCB-&gt;VTOR = (UINT32)(UINTPTR)hwiForm;</code>将中断向量映射基地址设为自定义变量地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># arch/arm/cortex-m4/iar/los_interrupt.c &gt; HalHwiInit()</span><br><span class="line"></span><br><span class="line">#if (LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT == 1)</span><br><span class="line">    UINT32 index;</span><br><span class="line">    HWI_PROC_FUNC *hwiForm = (HWI_PROC_FUNC *)ArchGetHwiFrom();</span><br><span class="line">    hwiForm[0] = 0;             /* [0] Top of Stack */</span><br><span class="line">    hwiForm[1] = (HWI_PROC_FUNC)Reset_Handler; /* [1] reset */</span><br><span class="line">    for (index = 2; index &lt; OS_VECTOR_CNT; index++) &#123; /* 2: The starting position of the interrupt */</span><br><span class="line">        hwiForm[index] = (HWI_PROC_FUNC)HalHwiDefaultHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Exception handler register */</span><br><span class="line">    hwiForm[NonMaskableInt_IRQn + OS_SYS_VECTOR_CNT]   = (HWI_PROC_FUNC)HalExcNMI;</span><br><span class="line">    hwiForm[HARDFAULT_IRQN + OS_SYS_VECTOR_CNT]        = (HWI_PROC_FUNC)HalExcHardFault;</span><br><span class="line">    hwiForm[MemoryManagement_IRQn + OS_SYS_VECTOR_CNT] = (HWI_PROC_FUNC)HalExcMemFault;</span><br><span class="line">    hwiForm[BusFault_IRQn + OS_SYS_VECTOR_CNT]         = (HWI_PROC_FUNC)HalExcBusFault;</span><br><span class="line">    hwiForm[UsageFault_IRQn + OS_SYS_VECTOR_CNT]       = (HWI_PROC_FUNC)HalExcUsageFault;</span><br><span class="line">    hwiForm[SVCall_IRQn + OS_SYS_VECTOR_CNT]           = (HWI_PROC_FUNC)HalExcSvcCall;</span><br><span class="line">    hwiForm[PendSV_IRQn + OS_SYS_VECTOR_CNT]           = (HWI_PROC_FUNC)HalPendSV;</span><br><span class="line">    hwiForm[SysTick_IRQn + OS_SYS_VECTOR_CNT]          = (HWI_PROC_FUNC)SysTick_Handler;</span><br><span class="line"></span><br><span class="line">    /* Interrupt vector table location */</span><br><span class="line">    SCB-&gt;VTOR = (UINT32)(UINTPTR)hwiForm;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="配置SysTick中断服务函数"><a href="#配置SysTick中断服务函数" class="headerlink" title="配置SysTick中断服务函数"></a>配置SysTick中断服务函数</h4><ul><li>函数调用顺序：<code>LOS_KernelInit() -&gt; OsTickTimerInit() -&gt; OsTickTimerInit() -&gt; g_sysTickTimer-&gt;init(OsTickHandler) -&gt; SysTickStart(OsTickHandler)</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># kernel/src/los_tick.c</span><br><span class="line">LITE_OS_SEC_TEXT VOID OsTickHandler(VOID)</span><br><span class="line">&#123;</span><br><span class="line">#if (LOSCFG_BASE_CORE_TICK_WTIMER == 0)</span><br><span class="line">    OsUpdateSysTimeBase();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    LOS_SchedTickHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># arch/arm/cortex-m4/gcc/los_timer.c</span><br><span class="line">STATIC UINT32 SysTickStart(HWI_PROC_FUNC handler)</span><br><span class="line">&#123;</span><br><span class="line">    UINT32 ret;</span><br><span class="line">    ArchTickTimer *tick = &amp;g_archTickTimer;</span><br><span class="line"></span><br><span class="line">    tick-&gt;freq = OS_SYS_CLOCK;</span><br><span class="line"></span><br><span class="line">#if (LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT == 1)</span><br><span class="line">#if (LOSCFG_PLATFORM_HWI_WITH_ARG == 1)</span><br><span class="line">    OsSetVector(tick-&gt;irqNum, handler, NULL);</span><br><span class="line">#else</span><br><span class="line">    OsSetVector(tick-&gt;irqNum, handler);     // 设置SysTick的中断向量</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ret = SysTick_Config(LOSCFG_BASE_CORE_TICK_RESPONSE_MAX);   // 在此处配置的SysTick中断无效，后续开启调度时会reload</span><br><span class="line">    if (ret == 1) &#123;</span><br><span class="line">        return LOS_ERRNO_TICK_PER_SEC_TOO_SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return LOS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># arch/arm/common/los_common_interrupt.c</span><br><span class="line">VOID OsSetVector(UINT32 num, HWI_PROC_FUNC vector)</span><br><span class="line">&#123;</span><br><span class="line">    if ((num + OS_SYS_VECTOR_CNT) &lt; OS_VECTOR_CNT) &#123;</span><br><span class="line">        g_hwiForm[num + OS_SYS_VECTOR_CNT] = HalInterrupt;</span><br><span class="line">        g_hwiHandlerForm[num + OS_SYS_VECTOR_CNT] = vector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化SysTick时基"><a href="#初始化SysTick时基" class="headerlink" title="初始化SysTick时基"></a>初始化SysTick时基</h4><ul><li>函数调用顺序：<code>LOS_Start() -&gt; ArchStartSchedule() -&gt; OsSchedStart() -&gt; OsSchedSetNextExpireTime() -&gt; OsTickTimerReload() -&gt; SysTickReload()</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># arch/arm/cortex-m4/gcc/los_timer.c</span><br><span class="line"># 调用此函数，传入的值实际上是</span><br><span class="line">STATIC UINT64 SysTickReload(UINT64 nextResponseTime)</span><br><span class="line">&#123;</span><br><span class="line">    if (nextResponseTime &gt; g_archTickTimer.periodMax) &#123;</span><br><span class="line">        nextResponseTime = g_archTickTimer.periodMax;</span><br><span class="line">    &#125;</span><br><span class="line">    SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">    SysTick-&gt;LOAD = (UINT32)(nextResponseTime - 1UL); /* set reload register */</span><br><span class="line">    SysTick-&gt;VAL = 0UL; /* Load the SysTick Counter Value */</span><br><span class="line">    NVIC_ClearPendingIRQ(SysTick_IRQn);</span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">    return nextResponseTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化调用逻辑总结"><a href="#初始化调用逻辑总结" class="headerlink" title="初始化调用逻辑总结"></a>初始化调用逻辑总结</h4><ol><li>在<code>arch/arm/cortex-m4/iar/los_interrupt.c &gt; HalHwiInit()</code>中执行中断向量表初始化<blockquote><p>但在此处初始化的SysTick_Handler向量是弱函数，并且其在后面会被替换</p></blockquote></li><li>在<code>LOS_KernelInit() -&gt; OsTickTimerInit() -&gt; OsTickTimerInit()</code>重设SysTick中断服务函数</li><li>在<code>LOS_Start() -&gt; ArchStartSchedule() -&gt; OsSchedStart()</code>中调用 重置SysTick中断时基为<code>系统时钟/调度间隔Tick值 （如：时钟源 / 1000 = 1ms时基）</code></li><li>最后开启系统调度</li></ol><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>LiteOS的内核初始化和系统启动都对Systick进行了设置，内核初始化时设置了Systick的重装载值为24位最大值，即0xFFFFFF</li><li>系统启动时，重置Systick累计的节拍，并设置重装载值为 <code>SystemCoreClock / 1000</code>，其中SystemCoreClock为系统时钟源频率。</li></ul><h2 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h2><h4 id="shell交互-uart-dma中断服务函数的配置"><a href="#shell交互-uart-dma中断服务函数的配置" class="headerlink" title="shell交互-uart-dma中断服务函数的配置"></a>shell交互-uart-dma中断服务函数的配置</h4><ul><li>芯片上电执行<code>LOS_KernelInit()</code>，其中会重新定义中断向量，但在这个过程之前和之后都会有日志打印</li><li>如果日志打印是用uart + DMA完成的，其中需要注册中断服务函数。</li><li>但是uart的初始化打开应该在系统初始化前执行，但中断服务函数要在系统初始化后才能注册。给编程带来不便</li></ul><h4 id="软件定时器的使用"><a href="#软件定时器的使用" class="headerlink" title="软件定时器的使用"></a>软件定时器的使用</h4><ul><li><p>鸡肋的软件定时器，只能在初始化时定好时间周期，后续不可更改。</p></li><li><p>其提供的API过少，只有初始化、开始、结束的有限几个接口。用户无法获取当前定时器剩余tick，无法重新设置定时周期，无法在使用过程中更改定时器的 单次或者周期定时等属性</p></li><li><p>该软件定时器中，不支持申请互斥量</p><ul><li>在写私有消息队列过程中，涉及临界区操作，需要申请互斥量，但在定时器的回调函数中申请互斥量会直接返回错误。</li></ul></li><li><p>定时器任务创建源码如下:<br>  如下所示：其中系统在创建定时器线程时会或上<code>OS_TASK_FLAG_SYSTEM_TASK</code>这个标志，然后在申请互斥量、信号量、事件时，都会检查当前是否运行在定时器任务中，如果为真，则直接返回错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LITE_OS_SEC_TEXT_INIT UINT32 OsSwtmrTaskCreate(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    UINT32 ret;</span><br><span class="line">    TSK_INIT_PARAM_S swtmrTask;</span><br><span class="line"></span><br><span class="line">    // Ignore the return code when matching CSEC rule 6.6(4).</span><br><span class="line">    (VOID)memset_s(&amp;swtmrTask, sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));</span><br><span class="line"></span><br><span class="line">    swtmrTask.pfnTaskEntry    = (TSK_ENTRY_FUNC)OsSwtmrTask;</span><br><span class="line">    swtmrTask.uwStackSize     = LOSCFG_BASE_CORE_TSK_SWTMR_STACK_SIZE;</span><br><span class="line">    swtmrTask.pcName          = &quot;Swt_Task&quot;;</span><br><span class="line">    swtmrTask.usTaskPrio      = 0;</span><br><span class="line">    ret = LOS_TaskCreate(&amp;g_swtmrTaskID, &amp;swtmrTask);</span><br><span class="line">    if (ret == LOS_OK) &#123;</span><br><span class="line">        OS_TCB_FROM_TID(g_swtmrTaskID)-&gt;taskStatus |= OS_TASK_FLAG_SYSTEM_TASK;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥量操作时，会进行以下检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">STATIC_INLINE UINT32 OsMuxValidCheck(LosMuxCB *muxPended)</span><br><span class="line">&#123;</span><br><span class="line">    if (muxPended-&gt;muxStat == OS_MUX_UNUSED) &#123;</span><br><span class="line">        return LOS_ERRNO_MUX_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (OS_INT_ACTIVE) &#123;</span><br><span class="line">        return LOS_ERRNO_MUX_IN_INTERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (g_losTaskLock) &#123;</span><br><span class="line">        PRINT_ERR(&quot;!!!LOS_ERRNO_MUX_PEND_IN_LOCK!!!\n&quot;);</span><br><span class="line">        return LOS_ERRNO_MUX_PEND_IN_LOCK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (g_losTask.runTask-&gt;taskStatus &amp; OS_TASK_FLAG_SYSTEM_TASK) &#123;</span><br><span class="line">        return LOS_ERRNO_MUX_PEND_IN_SYSTEM_TASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return LOS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="空闲任务函数"><a href="#空闲任务函数" class="headerlink" title="空闲任务函数"></a>空闲任务函数</h4><pre><code>查看LiteOS之原版api，是存在创建空闲任务钩子函数的，但最新版代码已经删除，代码如下：</code></pre><p>由以下代码可知，空闲任务作用仅为回收结束任务资源，以及可选的电源管理。<br>    - 个人操作：增设一个专门的低优先级任务来执行一些空闲操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LITE_OS_SEC_TEXT VOID OsIdleTask(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        OsRecycleFinishedTask();</span><br><span class="line"></span><br><span class="line">        if (PmEnter != NULL) &#123;</span><br><span class="line">            PmEnter();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (VOID)ArchEnterSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LITE_OS_SEC_TEXT_INIT UINT32 OsIdleTaskCreate(VOID)</span><br><span class="line">&#123;</span><br><span class="line">    UINT32 retVal;</span><br><span class="line">    TSK_INIT_PARAM_S taskInitParam;</span><br><span class="line">    // Ignore the return code when matching CSEC rule 6.6(4).</span><br><span class="line">    (VOID)memset_s((VOID *)(&amp;taskInitParam), sizeof(TSK_INIT_PARAM_S), 0, sizeof(TSK_INIT_PARAM_S));</span><br><span class="line">    taskInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)OsIdleTask;</span><br><span class="line">    taskInitParam.uwStackSize = LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE;</span><br><span class="line">    taskInitParam.pcName = &quot;IdleCore000&quot;;</span><br><span class="line">    taskInitParam.usTaskPrio = OS_TASK_PRIORITY_LOWEST;</span><br><span class="line">    retVal = LOS_TaskCreateOnly(&amp;g_idleTaskID, &amp;taskInitParam);</span><br><span class="line">    if (retVal != LOS_OK) &#123;</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OsSchedSetIdleTaskSchedParam(OS_TCB_FROM_TID(g_idleTaskID));</span><br><span class="line">    return LOS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2>]]></content>
      
      
      <categories>
          
          <category> OpenHarmony </category>
          
          <category> LiteOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LiteOS </tag>
            
            <tag> OpenHarmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂项笔记</title>
      <link href="/2023/11/29/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/29/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="J-Link-J-Flash"><a href="#J-Link-J-Flash" class="headerlink" title="J-Link&#x2F;J-Flash"></a>J-Link&#x2F;J-Flash</h2><h3 id="J-Flash批处理脚本配置烧录"><a href="#J-Flash批处理脚本配置烧录" class="headerlink" title="J-Flash批处理脚本配置烧录"></a>J-Flash批处理脚本配置烧录</h3><p>当然，前提是要添加J-Link的可执行程序路径到<code>$PATH</code>环境变量中</p><ul><li>program.bat脚本代码如下，参考修改即可：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo start...</span><br><span class="line"></span><br><span class="line">JLink -device N32L406CB -if swd -speed 4000 -CommanderScript &quot;C:\Users\Breo\Desktop\Wireless moxibustion\Software\program.jlink&quot;</span><br></pre></td></tr></table></figure></li><li>program.jlink文件代码如下，其中目标设备、文件路径、烧录地址等根据需要配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">connect</span><br><span class="line">device N32L406CB</span><br><span class="line">si SWD</span><br><span class="line">speed 4000</span><br><span class="line">h         // halt-停止</span><br><span class="line">r           // 复位，可以考虑去掉</span><br><span class="line">erase           // 或 erase 0x8002800，去掉也行，但可能会出现error fail address 0x00000000错误提示</span><br><span class="line"></span><br><span class="line">loadfile app.bin 0x8002800      // loadfile app.hex 或 loadfile app.bin 0x8000000</span><br><span class="line">verifybin app.bin 0x8002800</span><br><span class="line">r</span><br><span class="line">go        // r go表示reset and run</span><br><span class="line">q     // 退出J-Link命令行工具</span><br></pre></td></tr></table></figure></li></ul><h3 id="J-Link-J-Flash-读取单片机内部Flash内容"><a href="#J-Link-J-Flash-读取单片机内部Flash内容" class="headerlink" title="J-Link&#x2F;J-Flash 读取单片机内部Flash内容"></a>J-Link&#x2F;J-Flash 读取单片机内部Flash内容</h3><p>打开 J-Flash.exe 程序，进行工程配置并连接成功后，选择<code>Target</code> -&gt; <code>Manual Programming</code> -&gt; <code>Read back</code> -&gt; <code>Entire chip</code> 读取整片内容，也可以选择读取指定地址区的内容</p><p>选择<code>File</code> -&gt; <code>Save file as</code> 保存读取的内容，选择 J-Flash 支持的文件类型如 Hex、Bin 等等</p><p>前提是，芯片需要解除读保护</p><h2 id="hexo主题相关"><a href="#hexo主题相关" class="headerlink" title="hexo主题相关"></a>hexo主题相关</h2><ul><li><code>hexo init</code>，在初始化本地博客时使用，创建一个空白的文件夹并进入，然后执行 hexo init，即完成初始化</li><li><code>hexo new &quot;xxx&quot;</code>，新建一篇博客，相当于手动直接在<code>//source/_posts/</code>目录下新建一个<code>xxx.md</code>文件</li><li><code>hexo clean</code>，用于清理生成的静态网站文件，通常在更新时或者是重新生成网站前会使用</li><li><code>hexo g</code>，生成静态网站文件</li><li><code>hexo d</code>，用于部署静态网站到远程服务器，使得网站可以通过互联网访问</li><li><code>hexo server</code>，用于启动本地服务器以预览生成的静态网站</li><li>若要隐藏某篇博客，屏蔽该文章的渲染，在该文章名称前加个<code>_</code>下划线即可</li></ul><p><strong>草稿编辑：</strong></p><ul><li><code>hexo new draft &quot;xxx&quot;</code>在<code>source/_drafts</code>目录下创建一个新的草稿</li><li><code>hexo server --draft</code>预览草稿</li><li><code>hexo publish &lt;title&gt;</code>发布为博客文章<br>当然，也可以直接手动操作，直接将草稿拖移到<code>source/_posts</code>目录下即可转为博客</li></ul><h3 id="WSL-之-Ubuntu22-搭建Hexo-NexT博客"><a href="#WSL-之-Ubuntu22-搭建Hexo-NexT博客" class="headerlink" title="WSL 之 Ubuntu22 搭建Hexo NexT博客"></a>WSL 之 Ubuntu22 搭建Hexo NexT博客</h3><p>安装Node.JS和npm，通过<code>nodejs --version</code>和<code>npm --version</code>查看是否安装成功，另外版本要尽量高，以下为安装Node.JS命令，作参考用，当然实际过程中可能会遇到各种各样的安装报错问题，自行解决</p><ul><li><code>curl -sL https://deb.nodesource.com/setup_20.x | sudo -E bash -</code></li><li><code>sudo apt-get install -y nodejs</code></li><li><code>sudo apt-get install npm</code><br></li></ul><p>安装Hexo，而后创建一个新的目录&#x2F;新的博客，拉取next主题</p><ul><li><code>sudo npm install hexo-cli -g</code></li><li><code>mkdir blog</code></li><li><code>cd blog</code></li><li><code>hexo init</code></li><li><code>npm install hexo-deployer-git --save</code></li><li><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code><br></li></ul><p>重新关联已有的远端仓库</p><ul><li>前提，已经添加远端与本地的ssh连接</li><li>git初始化本地工程，并关联远端仓库即可，具体操作此处不重复阐述</li><li>全新的初始化流程为：远端创建一个以用户名为名称的仓库，然后将本地初始化为一个git工程，建立与远端仓库的关联关系</li></ul><br><p>配置博客站点及功能</p><ul><li>在<code>//_config.yml</code>添加部署的仓库站点，以及配置相应的界面功能</li><li>在<code>//themes/next/_config.yml</code>配置相应的主题功能</li></ul><br><p>配置本地搜索、标签、目录、字数统计、分页、浏览进度百分比、主题样式、代码块复制等功能，用户自行搜索添加即可</p><p>如：在配置文件中使能搜索功能、字数统计功能前，需要先安装以下插件</p><ul><li><code>npm install hexo-word-counter</code></li><li><code>npm install hexo-generator-search --save</code></li><li>参考<a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/">Hexo-NexT官方站点</a></li></ul><blockquote><p>其中添加搜索功能时，无论怎么样操作，Hexo NexT的搜索都无内容无效，最后发现是search.xml文件格式有误，于是本人另辟蹊径，将<code>//_config.yml</code>的search.xml改为search.json，重新生成即可。可能是该工程配置有问题，建议另起目录，重新初始化生成并配置可能更为省事</p></blockquote><br><h3 id="Windows环境下搭建Hexo博客"><a href="#Windows环境下搭建Hexo博客" class="headerlink" title="Windows环境下搭建Hexo博客"></a>Windows环境下搭建Hexo博客</h3><ul><li><a href="https://blog.csdn.net/qq_31061615/article/details/80743125?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80743125-blog-107513019.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-3-80743125-blog-107513019.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=4">点击参考博客即可</a></li></ul><h3 id="搭建-Hexo-Github-博客小结"><a href="#搭建-Hexo-Github-博客小结" class="headerlink" title="搭建 Hexo + Github 博客小结"></a>搭建 Hexo + Github 博客小结</h3><ul><li>本地安装 Nodejs，npm，hexo 等必要软件</li><li>使用 hexo 本地初始化配置</li><li>在 Github 上创建与用户名同名加指定后缀的仓库，即<code>username.github.io</code>，比如用户名是<code>Chen</code>，则创建仓库名为<code>Chen.github.io</code></li><li>在本地工程的<code>//config.yml</code>文件中进行配置，将要部署的站点设置为<code>username.github.io</code>此仓库对应的站点地址即可</li></ul><h3 id="Hexo-NexT-功能配置"><a href="#Hexo-NexT-功能配置" class="headerlink" title="Hexo + NexT 功能配置"></a>Hexo + NexT 功能配置</h3><p><strong>添加搜索功能：</strong></p><ul><li>在<code>//_config.yml</code>新增片段或片段修改为如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml    # 或者search.json</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li><li>在<code>//themes/next/_config.yml</code>新增片段或片段修改为如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure></li></ul><h2 id="VSCode相关"><a href="#VSCode相关" class="headerlink" title="VSCode相关"></a>VSCode相关</h2><p><strong>绘制流程图：</strong></p><ul><li>安装<code>Draw.io Integration</code>扩展插件</li><li>新建文件<code>xxx.drawio</code>，即可开始编辑<br></li></ul><p><strong>代码绘图：</strong></p><ul><li>安装<code>PlantUML、PlantUML Previewer</code>扩展</li><li>新建文件<code>xxx.plantuml</code>，即可开始编码，编码格式参考官方文档</li><li>以下为示例代码，鼠标光标位于代码其中任意位置，而后点击预览即可(Alt + D)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@startuml filename</span><br><span class="line">Main_task -&gt; Subtask: Delivery control event</span><br><span class="line">Subtask -&gt; Main_task: Reporting internal events</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></li></ul><p><strong>添加Git相关插件</strong><br>安装 GitLens 扩展</p><h2 id="DAP下载调试方式"><a href="#DAP下载调试方式" class="headerlink" title="DAP下载调试方式"></a>DAP下载调试方式</h2>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】STM32启动流程概述</title>
      <link href="/2023/11/28/%E3%80%90MCU%E3%80%91STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/28/%E3%80%90MCU%E3%80%91STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无论是Keil还是Gcc，对于应用了Cortex-M内核的 xx32 单片机，其从Flash启动流程都是从 0x8000000 取栈顶地址存至MSP，而后执行复位中断<code>Reset_Handler()</code>，在复位中断内执行 系统时钟初始化、将可读可写数据从 Flash 搬运到 SRAM、清零 SRAM 的 bss 段数据等，最后跳转至<code>main()</code>函数。<br><br></p><p>当然，芯片为何会从 0x8000000 开始执行，或者说芯片内部的出厂固化的ROM程序是如何执行的，此处暂不过多赘述，详见下文章节。<br><br></p><p>从源文件分析来看，Keil环境下的启动初始化源代码大多集成在库里面，用户不可见，因此本文主要从gcc环境下的源文件进行详细剖析启动流程。<br><br></p><p>另外，Keil下有所谓的<code>$$Super$main</code>&#x2F;<code>$$Sub$main</code>，或者说gcc环境下.s源码最后是跳转至<code>main</code>&#x2F;<code>entry</code>函数，此等都可由用户配置写就，暂不作讲解。<br><br></p><h2 id="Keil环境下的启动文件分析"><a href="#Keil环境下的启动文件分析" class="headerlink" title="Keil环境下的启动文件分析"></a>Keil环境下的启动文件分析</h2><h3 id="初始化栈顶指针"><a href="#初始化栈顶指针" class="headerlink" title="初始化栈顶指针"></a>初始化栈顶指针</h3><p>内核从0x0800 0000读取栈顶地址，并将该地址存入MSP中。</p><ul><li>栈顶地址的值为0x2000 xxxx，工程所生成bin文件的前四个字节即为栈顶地址。（.s 启动文件中说明了程序的第一个字就是<code>__initial_sp</code>栈顶地址，第二个字是<code>Reset_Handler</code>地址）</li><li>从0x2000 0000到0x2000 xxxx即为程序所运行的范围，该段内存分布为：RW段、ZI段：其中RW段为可读写的非0数据段，ZI段包括了0数据段、堆区、栈区。<br></li></ul><p>从0x08000004取出复位中断函数<code>Reset_Handler</code>地址，装载至PC指针，跳转执行<br><br></p><h3 id="复位中断"><a href="#复位中断" class="headerlink" title="复位中断"></a>复位中断</h3><p><strong>Keil环境代码如下：</strong></p><ul><li>先进行系统时钟初始化<blockquote><p>SystemInit()函数定义在system_xxx.c中，主要为初始化系统时钟RCC、重定位中断向量表</p></blockquote></li><li>跳转至_main()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler   PROC</span><br><span class="line">                EXPORT  Reset_Handler             [WEAK]  </span><br><span class="line">                IMPORT  __main</span><br><span class="line">                IMPORT  SystemInit</span><br><span class="line">                LDR     R0, =SystemInit   </span><br><span class="line">                BLX     R0               </span><br><span class="line">                LDR     R0, =__main</span><br><span class="line">                BX      R0    </span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure><h3 id="main-函数"><a href="#main-函数" class="headerlink" title="_main()函数"></a>_main()函数</h3><p><code>__scatterload</code></p><ul><li>将初始化的可读写数据段拷贝从Flash拷贝到SRAM</li><li>初始化清零未初始化数据段<br></li></ul><p><code>__rt_entry</code></p><ul><li>负责初始化堆栈，完成库函数的初始化，</li><li>最后跳转至main()函数<br></li></ul><h2 id="GCC编译环境下的启动文件分析"><a href="#GCC编译环境下的启动文件分析" class="headerlink" title="GCC编译环境下的启动文件分析"></a>GCC编译环境下的启动文件分析</h2><p><strong>程序跳转至复位中断后，执行以下操作：</strong></p><ul><li>将初始化的可读写数据段拷贝从Flash拷贝到SRAM</li><li>初始化清零未初始化数据段</li><li>调用系统时钟初始化函数（SystemInit）</li><li>调用静态构造函数（__libc_init_array） ——参考自CHATGPT<ul><li>调用所有静态构造函数-&gt;调用.preinit_array段中的所有函数指针-&gt;调用.init段中的_init函数-&gt;调用.init_array段中的所有函数指针-&gt;确保在程序执行主函数 main 之前，所有需要初始化的内容都已经完成。</li><li>当然，纯C语言部分不会实际调用到相关构造函数</li><li>其在链接脚本中有体现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.preinit_array     :</span><br><span class="line">&#123;</span><br><span class="line">  PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">  KEEP (*(.preinit_array*))</span><br><span class="line">  PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">&#125; &gt;FLASH</span><br><span class="line">.init_array :</span><br><span class="line">&#123;</span><br><span class="line">  PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">  KEEP (*(SORT(.init_array.*)))</span><br><span class="line">  KEEP (*(.init_array*))</span><br><span class="line">  PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">&#125; &gt;FLASH</span><br></pre></td></tr></table></figure></li><li>链接脚本中，可将用户函数指定链接到相应的init段，从而实现在main前的函数自动初始化？</li></ul></li><li>进入用户函数(main)<br></li></ul><hr><p><strong>复位中断代码如下所示，注意：其中所用变量_sidata、_edata等等须 搭配链接脚本内容 共同参阅</strong></p><h3 id="复位中断起始"><a href="#复位中断起始" class="headerlink" title="复位中断起始"></a>复位中断起始</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reset_Handler:  </span><br><span class="line">  /* 将寄存器r1清零，作为数据段复制的偏移量 */</span><br><span class="line">  movs  r1, #0              </span><br><span class="line">  </span><br><span class="line">  /* 无条件跳转到LoopCopyDataInit标签处 */</span><br><span class="line">  b  LoopCopyDataInit       </span><br></pre></td></tr></table></figure><h3 id="拷贝RW-Data"><a href="#拷贝RW-Data" class="headerlink" title="拷贝RW-Data"></a>拷贝RW-Data</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实际的RW-Data拷贝工作</span><br><span class="line">CopyDataInit:</span><br><span class="line">  ldr  r3, =_sidata         /* 将_sidata的地址加载到寄存器r3，表示初始化数据段的起始地址 */</span><br><span class="line">  ldr  r3, [r3, r1]         /* 从初始化数据段中取出一个32位数据，存储在寄存器r3中。 */</span><br><span class="line">  str  r3, [r0, r1]         /* 将寄存器r3中的数据存储到数据段当前位置。 */</span><br><span class="line">  adds  r1, r1, #4         /* 增加偏移量，移动到下一个32位数据的位置。 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 计算判断是否完成拷贝工作，未完成则继续拷贝，完成则跳转至清零ZI-Data部分</span><br><span class="line">LoopCopyDataInit:</span><br><span class="line">  ldr  r0, =_sdata         /* 将_sdata的地址加载到寄存器r0，表示数据段的起始地址。*/</span><br><span class="line">  ldr  r3, =_edata         /* 将_edata的地址加载到寄存器r3，表示数据段的结束地址。 */</span><br><span class="line">  adds  r2, r0, r1         /* 计算数据段当前位置的地址，存储在寄存器r2中。*/</span><br><span class="line">  cmp  r2, r3         /* 比较当前位置与数据段结束地址的大小关系 */</span><br><span class="line">  bcc  CopyDataInit         /* 如果当前位置小于结束地址，则跳转到CopyDataInit标签处 */</span><br></pre></td></tr></table></figure><h3 id="清零bss段"><a href="#清零bss段" class="headerlink" title="清零bss段"></a>清零bss段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 清零未初始化数据段（bss segment）</span><br><span class="line">  ldr  r2, =_sbss         /* 将_sbss的地址加载到寄存器r2，表示未初始化数据段的起始地址 */</span><br><span class="line">  b  LoopFillZerobss         /* 无条件跳转到LoopFillZerobss标签处 */</span><br><span class="line">FillZerobss:</span><br><span class="line">  movs  r3, #0      /* 将寄存器r3清零，作为未初始化数据段的填充值 */</span><br><span class="line">  str  r3, [r2], #4      /* 将寄存器r3中的数据存储到当前位置，并将当前位置向后移动4个字节 */</span><br><span class="line">    </span><br><span class="line">// 判断是否完成清零工作，是则跳转至系统时钟初始化部分</span><br><span class="line">LoopFillZerobss:         </span><br><span class="line">  ldr  r3, = _ebss        /* 将_ebss的地址加载到寄存器r3，表示未初始化数据段的结束地址 */</span><br><span class="line">  cmp  r2, r3         /* 比较当前位置与结束地址的大小关系 */</span><br><span class="line">  bcc  FillZerobss         /* 如果当前位置小于结束地址，则跳转到FillZerobss标签处 */</span><br></pre></td></tr></table></figure><h3 id="其它初始化及跳转至main"><a href="#其它初始化及跳转至main" class="headerlink" title="其它初始化及跳转至main"></a>其它初始化及跳转至main</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 调用系统时钟初始化函数 */</span><br><span class="line">bl  SystemInit     </span><br><span class="line"></span><br><span class="line">/* 调用静态构造函数 */       </span><br><span class="line">bl __libc_init_array         </span><br><span class="line"></span><br><span class="line">/* 应用程序的入口函数 */</span><br><span class="line">bl  main           </span><br><span class="line"></span><br><span class="line">/* 通过bx lr指令返回到Reset（通常是启动代码的入口处），当然不会执行到此处 */ </span><br><span class="line">bx  lr            </span><br></pre></td></tr></table></figure><h3 id="GCC环境之复位中断源码总览"><a href="#GCC环境之复位中断源码总览" class="headerlink" title="GCC环境之复位中断源码总览"></a>GCC环境之复位中断源码总览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Reset_Handler:  </span><br><span class="line">  movs  r1, #0              /* 将寄存器r1清零，作为数据段复制的偏移量 */</span><br><span class="line">  b  LoopCopyDataInit       /* 无条件跳转到LoopCopyDataInit标签处 */</span><br><span class="line"></span><br><span class="line">CopyDataInit:</span><br><span class="line">  ldr  r3, =_sidata         /* 将_sidata的地址加载到寄存器r3，表示初始化数据段的起始地址 */</span><br><span class="line">  ldr  r3, [r3, r1]         /* 从初始化数据段中取出一个32位数据，存储在寄存器r3中。 */</span><br><span class="line">  str  r3, [r0, r1]         /* 将寄存器r3中的数据存储到数据段当前位置。 */</span><br><span class="line">  adds  r1, r1, #4         /* 增加偏移量，移动到下一个32位数据的位置。 */</span><br><span class="line">    </span><br><span class="line">LoopCopyDataInit:</span><br><span class="line">  ldr  r0, =_sdata         /* 将_sdata的地址加载到寄存器r0，表示数据段的起始地址。*/</span><br><span class="line">  ldr  r3, =_edata         /* 将_edata的地址加载到寄存器r3，表示数据段的结束地址。 */</span><br><span class="line">  adds  r2, r0, r1         /* 计算数据段当前位置的地址，存储在寄存器r2中。*/</span><br><span class="line">  cmp  r2, r3         /* 比较当前位置与数据段结束地址的大小关系 */</span><br><span class="line">  bcc  CopyDataInit         /* 如果当前位置小于结束地址，则跳转到CopyDataInit标签处 */</span><br><span class="line">  </span><br><span class="line">  /*清零未初始化数据段（bss segment）*/</span><br><span class="line">  ldr  r2, =_sbss         /* 将_sbss的地址加载到寄存器r2，表示未初始化数据段的起始地址 */</span><br><span class="line">  b  LoopFillZerobss         /* 无条件跳转到LoopFillZerobss标签处 */</span><br><span class="line">FillZerobss:</span><br><span class="line">  movs  r3, #0      /* 将寄存器r3清零，作为未初始化数据段的填充值 */</span><br><span class="line">  str  r3, [r2], #4      /* 将寄存器r3中的数据存储到当前位置，并将当前位置向后移动4个字节 */</span><br><span class="line">    </span><br><span class="line">LoopFillZerobss:         </span><br><span class="line">  ldr  r3, = _ebss        /* 将_ebss的地址加载到寄存器r3，表示未初始化数据段的结束地址 */</span><br><span class="line">  cmp  r2, r3         /* 比较当前位置与结束地址的大小关系 */</span><br><span class="line">  bcc  FillZerobss         /* 如果当前位置小于结束地址，则跳转到FillZerobss标签处 */</span><br><span class="line"></span><br><span class="line">  bl  SystemInit            /* 调用系统时钟初始化函数 */</span><br><span class="line">  bl __libc_init_array         /* 调用静态构造函数 */</span><br><span class="line">  bl  main            /* 应用程序的入口函数 */</span><br><span class="line">  bx  lr            /* 通过bx lr指令返回到调用者（通常是启动代码的入口处），当然不会执行到此处 */</span><br><span class="line">.size  Reset_Handler, .-Reset_Handler</span><br></pre></td></tr></table></figure><h2 id="常见疑惑解答"><a href="#常见疑惑解答" class="headerlink" title="常见疑惑解答"></a>常见疑惑解答</h2><h3 id="为什么芯片启动时会将栈顶地址存放到-MSP，然后跳转至复位中断执行？"><a href="#为什么芯片启动时会将栈顶地址存放到-MSP，然后跳转至复位中断执行？" class="headerlink" title="为什么芯片启动时会将栈顶地址存放到 MSP，然后跳转至复位中断执行？"></a>为什么芯片启动时会将栈顶地址存放到 MSP，然后跳转至复位中断执行？</h3><p>.s 启动文件和链接脚本已经讲明了所生成的映像文件第一个字是栈顶地址，第二个字就是复位中断的地址。</p><p>有些人可能会疑惑，为什么系统启动会设置栈顶地址，并且会跳转到复位中断呢？（其实，这都是 Cortex-M 内核所实现的）</p><p>以下内容摘选自<code>ARM Cortex-M3与Cortex-M4权威指南</code>的第4.8节：<code>复位和复位流程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在复位后以及处理器开始执行程序前，Cortex-M处理器会从存储器中读出头两个字，如图4.30所示。</span><br><span class="line">向量表位于存储器的开头部分，它的头两个字为主栈指针(MSP)的初始值，以及代表复位处理起始地址的复位向量(参考本书图4.26和4.5.3节)。</span><br><span class="line">处理器读出这两个字后，就会将这些数值赋给MSP和程序计数器(PC)。</span><br></pre></td></tr></table></figure><p><img src="/../pictures/stm32%E5%A4%8D%E4%BD%8D%E6%B5%81%E7%A8%8B.png" alt="stm32复位流程" title="Cortex-M 内核复位流程"></p><p>由此可见，所谓的启动文件和链接脚本 都是根据 内核特性和单片机厂商的设计特性 而制定的，前者是果，后者是因。</p><h3 id="芯片启动时为何都是从-0x8000000-开始？"><a href="#芯片启动时为何都是从-0x8000000-开始？" class="headerlink" title="芯片启动时为何都是从 0x8000000 开始？"></a>芯片启动时为何都是从 0x8000000 开始？</h3><p>Cortex-M 内核复位都是固定从 0x00000000 开始，而在 STM32&#x2F;xx32 中，程序通常存储在 0x8000000 地址并在此开始执行，这一点是由于芯片厂商的设计所决定的。</p><p>以下内容摘选自互联网：</p><p>在 STM32 等微控制器中，可以通过配置 BOOT 引脚或其他方式，将 Flash 的 0x08000000 地址重映射到 0x00000000。</p><p>这样，微控制器就可以在 0x00000000 地址处找到中断向量表，同时，程序代码仍然存储在 Flash 的0x08000000 地址处</p><p>这种设计使得微控制器能够在启动时正确地找到并执行存储在 Flash 中的程序，同时还能满足 ARM Cortex-M 系列微控制器的启动要求</p><h3 id="通过-ISP-编程或者-SWD-JTAG-下载方式时，芯片是如何工作的？"><a href="#通过-ISP-编程或者-SWD-JTAG-下载方式时，芯片是如何工作的？" class="headerlink" title="通过 ISP 编程或者 SWD&#x2F;JTAG 下载方式时，芯片是如何工作的？"></a>通过 ISP 编程或者 SWD&#x2F;JTAG 下载方式时，芯片是如何工作的？</h3><p>在系统编程：毫无疑问，芯片内部是内置固化了一段出厂bootloader程序的，此程序用于实现串口升级，但是用户是不知道其源码实现的</p><p>在电路编程，使用SWD&#x2F;JTAG接口</p><ul><li><a href="https://zhuanlan.zhihu.com/p/59866951#%E6%80%BB%E7%BB%93">如何使用串口来给STM32下载程序</a></li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://bbs.21dianyuan.com/forum.php?mod=viewthread&tid=302606">ARM Cortex-M3与Cortex-M4权威指南</a></li><li><a href="https://blog.csdn.net/weixin_42231514/article/details/106178653">STM32的Flash地址是0x08000000，从0x00000000不可以？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL小贴士</title>
      <link href="/2023/11/28/WSL%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
      <url>/2023/11/28/WSL%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="在windows下访问WSL的目录"><a href="#在windows下访问WSL的目录" class="headerlink" title="在windows下访问WSL的目录"></a>在windows下访问WSL的目录</h4><ul><li>在wwindows的资源管理器输入<code>\\wsl$</code>即可</li><li>直接访问WSL的根路径<ul><li><code>C:\Users\xxx\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\rootfs</code></li><li>其中<code>xxx</code>为个人用户名</li><li>如果过程中没有找到对应的文件夹，请勾选<code>资源管理器-&gt;查看-&gt;隐藏的项目</code><br></li></ul></li></ul><h4 id="重启WSL"><a href="#重启WSL" class="headerlink" title="重启WSL"></a>重启WSL</h4><ul><li>打开PowerShell<ul><li>输入命令<code>Get-Service LxssManager | Restart-Service</code>，重启LxssManager服务</li><li>停止LxssManager服务&#x2F;关机：<code>net stop LxssManager</code></li><li>启动LxssManager服务&#x2F;开机：<code>net start LxssManager</code></li></ul></li></ul><h4 id="WSL下通过命令执行Windows下的bat脚本"><a href="#WSL下通过命令执行Windows下的bat脚本" class="headerlink" title="WSL下通过命令执行Windows下的bat脚本"></a>WSL下通过命令执行Windows下的bat脚本</h4><ul><li><code>wsl.exe -d Ubuntu-18.04 cmd.exe /c &quot;C:\Users\program.bat&quot;</code><ul><li>系统发行版本与脚本路径 替换为实际的即可</li></ul></li></ul><h4 id="恢复误删文件"><a href="#恢复误删文件" class="headerlink" title="恢复误删文件"></a>恢复误删文件</h4><h4 id="开启WSL的NFS服务"><a href="#开启WSL的NFS服务" class="headerlink" title="开启WSL的NFS服务"></a>开启WSL的NFS服务</h4><pre><code>实现u-boot通过nfs服务挂载WSL下的根文件系统</code></pre><h4 id="删除WSL中的一个Linux发行版"><a href="#删除WSL中的一个Linux发行版" class="headerlink" title="删除WSL中的一个Linux发行版"></a>删除WSL中的一个Linux发行版</h4><p>WSL可以同时安装多个Linux发行版，打开PowerShell：</p><ul><li>输入<code>wsl --list</code>列出所有已安装的发行版</li><li>输入<code>wsl --unregister Ubuntu-18.04</code>表示删除其中名为<code>Ubuntu-18.04</code>的发行版，而后静静等待命令执行完毕即可</li></ul><h4 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h4>]]></content>
      
      
      <categories>
          
          <category> WSL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】Linux知识小贴士</title>
      <link href="/2023/11/28/%E3%80%90Linux%E3%80%91Linux%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
      <url>/2023/11/28/%E3%80%90Linux%E3%80%91Linux%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="内网但非同一网段环境下开启NFS服务"><a href="#内网但非同一网段环境下开启NFS服务" class="headerlink" title="内网但非同一网段环境下开启NFS服务"></a>内网但非同一网段环境下开启NFS服务</h4><ul><li>在Linux主机和Windows主机之间开启NFS服务 之 Windows10通过NFS挂载Linux目录<ul><li>在Linux主机上配置NFS服务器<ul><li>输入命令<code>sudo apt-get install nfs-kernel-server rpcbind</code>安装NFS服务器和PRCBIND</li><li>创建共享目录：<code>sudo mkdir /home/jd_chen/nfs_share</code>，其中&#x2F;home&#x2F;jd_chen&#x2F;nfs_share为想要共享的目录<ul><li><code>chmod -R 777 /home/jd_chen/nfs_share</code>将所有权限递归应用于目标目录的所有文件和子目录</li></ul></li><li>配置NFS服务：<code>sudo vim /etc/exports</code><ul><li>在文件中添加<code>/home/jd_chen/nfs_share *(rw,sync,no_root_squash)</code></li><li>其中*表示允许所有的网络段访问，rw表示访问者具有可读写权限，sync表示将缓存写入设备中，表示同步缓存，no_root_squash表示访问者具有root权限</li></ul></li><li>启动NFS服务：<code>sudo service nfs-kernel-server start</code>或者<code>systemctl start nfs-kernel-server</code><ul><li><code>systemctl status nfs-kernel-server</code>验证NFS服务是否已启动</li><li><code>systemctl enable nfs-kernel-server</code>配置在系统启动时自动启动NFS服务</li><li><code>showmount -e</code>查看NFS共享目录</li></ul></li></ul></li></ul></li></ul><br><ul><li><p>在Windows下配置NFS客户湍服务</p><ul><li>打开<code>控制面板\程序\程序和功能</code>，点击<code>启用或关闭Windows功能</code>，找到<code>NFS服务</code>，勾选<code>NFS客户端</code>和<code>管理工具</code></li><li>重启电脑<br></li></ul></li><li><p>在Windows下挂载NFS目录 </p><ul><li>按下<code>Win+R</code>组合键打开运行对话框</li><li>输入<code>mount 192.168.112.240:/home/jd_chen/nfs_share X:</code><ul><li>其中192.168.112.240为Linux主机的ip地址，&#x2F;home&#x2F;jd_chen&#x2F;nfs_share为需要共享的目录，X:为映射到Windows本地的盘符</li></ul></li></ul></li><li><p>将命令mount改为umount即可卸载挂载，或者右键盘符-&gt;断开连接</p></li></ul><hr><ul><li>在Linux主机使用挂载Linux服务器的NFS共享目录<ul><li>客户端执行<code>yum install -y nfs-utils</code></li><li>执行<code>mount &lt;服务器IP&gt;:&lt;share_path&gt; &lt;挂载点&gt;</code><ul><li>如：<code>mount 192.168.1.1:/mnt/nfs /mnt/share</code><ul><li>表示将服务器 192.168.1.1 上的 &#x2F;mnt&#x2F;nfs 目录挂载到客户端 &#x2F;mnt&#x2F;share 目录</li></ul></li><li>如：<code>mount -t nfs -o nolock,nfsvers=3 192.168.1.1:/mnt/nfs /mnt/share</code><ul><li>其中-t nfs指定文件系统类型为NFS，-o nolock表示禁用文件锁定功能，nfsvers&#x3D;3指定使用NFS版本3</li></ul></li></ul></li><li>执行<code>df -h</code>验证NFS共享是否可用</li></ul></li></ul><hr><ul><li>嵌入式Linux开发中，配置NFS挂载根文件系统</li></ul><hr><h4 id="远程端口流量通过SSH映射到本地"><a href="#远程端口流量通过SSH映射到本地" class="headerlink" title="远程端口流量通过SSH映射到本地"></a>远程端口流量通过SSH映射到本地</h4><p>在本地 Windows 打开 PowerShell，输入：<code>ssh -L 4000:localhost:4000 jd_chen@192.168.112.240</code></p><ul><li>其中，4000是要转发的端口以及映射到本地的端口，jd_chen为远程主机用户名</li><li>另外，如果为VSCode + SSH开发环境，可以在VSCode的终端界面<code>PORTS</code>直接添加转发&#x2F;预览</li></ul><h4 id="Linux给根目录扩容"><a href="#Linux给根目录扩容" class="headerlink" title="Linux给根目录扩容"></a>Linux给根目录扩容</h4><h3 id="软件资源获取、下载、安装相关"><a href="#软件资源获取、下载、安装相关" class="headerlink" title="软件资源获取、下载、安装相关"></a>软件资源获取、下载、安装相关</h3><p><em><em>知道</em>.tar.gz文件的URL，则可以使用<code>wget</code>命令直接从网站上下载该文件</em>*</p><ul><li>如想下载的文件的URL是<a href="http://example.com/file.tar.gz">http://example.com/file.tar.gz</a></li><li>则可以<code>wget http://example.com/file.tar.gz</code>在当前目录下下载该文件</li></ul><br><ul><li>下载了*.tar.gz文件后，键入<code>tar -xzvf file.tar.gz</code>命令，解压文件到当前目录</li><li>而后进入其目录<code>cd file</code>，输入如下命令安装，当然以下只是方式之一。或者通常目录下或有安装脚本，使用sudo权限执行其脚本即可</li><li>安装完毕后，可以通过运行其可执行程序，如：xxx –version，检查是否安装成功，提示缺少依赖，则<code>sudo apt-get install xxx</code>安装对应库即可，或者<code>sudo apt --fix-broken install</code>安装缺失的软件包依赖</li></ul><p><strong>通过源代码编译安装的方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>基于.deb文件安装：</strong></p><ul><li>使用dpkg命令，如：<code>sudo dpkg -i file.deb</code></li><li>解决安装过程中的依赖：暂略，<code>sudo apt --fix-broken install</code></li></ul><h3 id="命令行操作相关"><a href="#命令行操作相关" class="headerlink" title="命令行操作相关"></a>命令行操作相关</h3><p>在shell脚本中，<code>#!/bin/bash</code>通常放在第一行，当然也可以放在其它行，也可以去掉该行，或者也可以在该行之前放置其它如注释部分</p><ul><li><code>#!/bin/bash</code>用于告诉系统使用何种shell解释器来解释此脚本，若不指定，则会使用默认shell解释器</li><li>但通常系统默认的解释器即为bash shell</li></ul><h4 id="xxx-sh和sh-xxx-sh"><a href="#xxx-sh和sh-xxx-sh" class="headerlink" title=".&#x2F;xxx.sh和sh xxx.sh"></a>.&#x2F;xxx.sh和sh xxx.sh</h4><p>直接使用.&#x2F;xx.sh会在当前shell中执行shell脚本，而使用sh xx.sh会在一个新的子shell中执行shell脚本。</p><ul><li>在当前shell中执行shell脚本时，shell脚本中的变量和环境会影响当前shell</li><li>在子shell中执行shell脚本时，shell脚本中的变量和环境不会影响当前shell<br></li></ul><p>以下复述自Brad：</p><ul><li>如果shell脚本中定义了一个变量，但没有使用export命令将其导出到环境中，则该变量只在shell脚本中有效，在shell脚本执行完毕后，该变量就会被删除。<blockquote><p>当使用export命令将变量导出到环境中时，该变量会被添加到环境变量列表中。环境变量列表是所有shell共享的，包括父shell和子shell</p></blockquote></li><li>如果shell脚本中定义了一个变量，并使用export命令将其导出到环境中，则该变量会一直存在，直到shell退出。</li><li>如果shell脚本中使用unset命令删除了一个变量，则该变量会立即被删除，无论该变量是否被导出到环境中<blockquote><p>使用unset命令删除一个变量，只会在当前shell中删除该变量。如果该变量被导出到环境中，则该变量会从环境变量列表中删除，但不会从其他shell中删除</p></blockquote></li><li>如果shell使用exit命令退出，则shell脚本中的所有变量和环境都会被删除，无论该变量是否被导出到环境中</li></ul><hr><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><h4 id="解压缩相关"><a href="#解压缩相关" class="headerlink" title="解压缩相关"></a>解压缩相关</h4><p>将 &#x2F;home&#x2F;user&#x2F;test.tar.gz 解压到 &#x2F;home&#x2F;user&#x2F; 目录：<code>tar -zxvf /home/user/test.tar.gz -C /home/user/</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】MCU开发知识点记录与总结</title>
      <link href="/2023/11/28/%E3%80%90MCU%E3%80%91MCU%E5%BC%80%E5%8F%91%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
      <url>/2023/11/28/%E3%80%90MCU%E3%80%91MCU%E5%BC%80%E5%8F%91%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="内核相关部分"><a href="#内核相关部分" class="headerlink" title="内核相关部分"></a>内核相关部分</h2><h3 id="Cortex-M内核异常与中断"><a href="#Cortex-M内核异常与中断" class="headerlink" title="Cortex-M内核异常与中断"></a>Cortex-M内核异常与中断</h3><p><strong>Cortex-M内核主要包括如下几种异常：</strong></p><p>Reset：上电时复位或者热复位时调用，其被视为一种特殊形式的异常，永久启用、固定优先级-3<br><br></p><p>NMI：不可屏蔽中断，永久启用、固定优先级-2，不能被Reset以外的任何异常抢占，其可配置为软件触发或者外设信号触发，通常配置来用于处理严重的异常情况。当然，本人并没用过此异常</p><ul><li>NMI的应用场景由用户配置，如看门狗、<br></li></ul><p>HardFault：优先级-1</p><ul><li>在Cortex-M0内核中，只支持对齐访问，如果所编译的变量类型为非字节对齐（如int变量地址不能被4整除），可能会产生运行错误<br></li></ul><p>MemManage：由于内存保护相关故障触发的异常，可配置触发方式&#x2F;源，如非对齐内存访问、除零异常等</p><ul><li>例：如果指针变量并非为四字节对齐，同时内核使能了非对齐内存方法异常，那么当程序访问该指针变量时，会触发MemManage异常。当然，在GCC编译中也有相应的编译选项–<code>-munaligned-access</code>，为非字节对齐变量生成特定的程序指令</li><li>如下代码所示，表示配置使能Cortex-M4内核的<code>USGFAULT, BUSFAULT, MEMFAULT</code>异常，启用DIV 0和未对齐异常内存访问<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define OS_NVIC_SHCSR                       0xE000ED24</span><br><span class="line">#define OS_NVIC_CCR                         0xE000ED14</span><br><span class="line">#define USGFAULT                        (1 &lt;&lt; 18)</span><br><span class="line">#define BUSFAULT                        (1 &lt;&lt; 17)</span><br><span class="line">#define MEMFAULT                        (1 &lt;&lt; 16)</span><br><span class="line">#define DIV0FAULT                       (1 &lt;&lt; 4)</span><br><span class="line">#define UNALIGNFAULT                    (1 &lt;&lt; 3)</span><br><span class="line"></span><br><span class="line">*(volatile UINT32 *)OS_NVIC_SHCSR |= (USGFAULT | BUSFAULT | MEMFAULT);</span><br><span class="line">*(volatile UINT32 *)OS_NVIC_CCR |= (DIV0FAULT | UNALIGNFAULT);</span><br></pre></td></tr></table></figure></li></ul><br><p>BusFault：内存总线所检测的错误<br><br></p><p>UsageFault：与指令执行相关的故障异常，包括：未定义指令、指令执行状态无效、异常返回错误<br>  如果在实际的函数指针强制转换调用中，传入参数与实际函数入参不一致，可能会导致未定义的行为错误<br><br></p><p>SVCall：由SVC指令触发的异常，操作系统环境中，程序可使用SVC指令主动挂起异常，访问内核和设备驱动<br><br></p><p>PendSV：实时操作系统可通过主动触发PendSV异常进行上下文切换<br><br></p><p>SysTick：系统滴答定时器归零时触发的异常，通常用作系统节拍<br><br></p><p>Interrupt（IRQ）：中断<br><br></p><h3 id="全局开关中断操作"><a href="#全局开关中断操作" class="headerlink" title="全局开关中断操作"></a>全局开关中断操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__disable_irq();    // 将 PRIMASK 寄存器的值设置为 1，禁止所有中断</span><br><span class="line">__enable_irq();     // 将 PRIMASK 寄存器的值设置为 0，开启所有中断</span><br><span class="line">__set_PRIMASK(1);   // PRIMASK 值为 1 ，所有可屏蔽中断的优先级为 1，表示所有可屏蔽中断均不能被中断处理程序处理，只能由 NMI 处理程序处理</span><br><span class="line">__set_PRIMASK(0);</span><br><span class="line"></span><br><span class="line">// 在 Cortex-M 架构中，FAULTMASK 寄存器控制所有异常的优先级</span><br><span class="line">__set_FAULTMASK(1);  // FAULTMASK 寄存器的值为 1 时，所有异常的优先级为 1，表示所有异常均不能被中断处理程序处理，只能由 NMI 处理程序处理</span><br><span class="line">__set_FAULTMASK(0);</span><br><span class="line"></span><br><span class="line">CPSID F        //关异常，FAULTMASK=1</span><br><span class="line">CPSIE F        //开异常，FAULTMASK=0</span><br></pre></td></tr></table></figure><h3 id="MCU获取CPU使用率原理"><a href="#MCU获取CPU使用率原理" class="headerlink" title="MCU获取CPU使用率原理"></a>MCU获取CPU使用率原理</h3><ul><li>理论来说，裸机程序不能获取CPU使用率</li><li>在RTOS下，可以通过计时器来测量CPU在空闲任务的运行时间，计算其占整体运行时间的比率即可得到CPU使用率<ul><li>CPU使用率 &#x3D; (CPU总运行时间 - CPU空闲时间) &#x2F; CPU总运行时间</li><li>通过使用计时器，可以计算上电运行以后的 CPU总使用率，也可以计算 一个时间周期内 CPU的使用率</li></ul></li></ul><h2 id="系统相关部分"><a href="#系统相关部分" class="headerlink" title="系统相关部分"></a>系统相关部分</h2><h3 id="芯片时钟频率选择"><a href="#芯片时钟频率选择" class="headerlink" title="芯片时钟频率选择"></a>芯片时钟频率选择</h3><p>选择芯片时钟频率，可以综合考虑芯片的性能需求、功耗需求、发热需求等</p><ul><li>性能：如果运行任务复杂，如包括图形处理、视频处理、复杂数运算等，须选择高频率</li><li>功耗：如果产品对耗电有要求，可以考虑选用较低同时能够满足使用的频率，需要结合硬件综合评估</li><li>发热：高频率会增加芯片的发热量，产品设计空间密闭狭小情况下，需要考虑芯片可能过热工作</li><li>工艺：芯片制造工艺不够精湛，在高时钟频率下工作，可能会不稳定。 （当然，本人没遇到过相关情况）</li></ul><h2 id="外设接口相关部分"><a href="#外设接口相关部分" class="headerlink" title="外设接口相关部分"></a>外设接口相关部分</h2><h3 id="GPIO的输出速度"><a href="#GPIO的输出速度" class="headerlink" title="GPIO的输出速度"></a>GPIO的输出速度</h3><ul><li>根据外部设备要求进行配置<ul><li>常规的控制LED灯、按键等，采用2MHz即可</li><li>GPIO模拟SPI、I2C等总线，可以配置为10MHz</li><li>控制DDR、USB等超高速接口，配置50MHZ</li></ul></li><li>GPIO的输出速度越高，其驱动电路的功耗就越高</li></ul><h3 id="内部与外部晶振"><a href="#内部与外部晶振" class="headerlink" title="内部与外部晶振"></a>内部与外部晶振</h3><ul><li>内部晶振精度较外部晶振低</li><li>一般情况下，使用内部晶振足以满足常用需求，包括spi、iic、uart的外设通信</li><li>如果要求时钟精度高，或应用于精密仪器等场景，或用到高速外设如usb、sdio的高精度时钟要求场景，考虑用外部晶振<ul><li>SDIO 接口要求时钟信号的精度为 2% 或以下<ul><li>存储卡、扩展卡、无线模块</li><li>高速图像传感器、高速存储卡</li></ul></li><li>USB 接口要求时钟信号的精度为 5% 或以下<ul><li>鼠标、键盘、打印机、网络摄像头、耳机</li><li>高速摄像头、高速打印机、高品质音频设备</li></ul></li></ul></li></ul><h3 id="外设接口的通信频率"><a href="#外设接口的通信频率" class="headerlink" title="外设接口的通信频率"></a>外设接口的通信频率</h3><h4 id="MCU常用外设的通信速率范围"><a href="#MCU常用外设的通信速率范围" class="headerlink" title="MCU常用外设的通信速率范围"></a>MCU常用外设的通信速率范围</h4><table><thead><tr><th>接口类型</th><th>通信频率</th><th>精度</th></tr></thead><tbody><tr><td>SDIO</td><td>25 MHz~50 MHz</td><td>2% 以下</td></tr><tr><td>USB</td><td>12 MHz~480 MHz</td><td>5% 以下</td></tr><tr><td>I2C</td><td>100 kHz~400 kHz</td><td>1% 以下</td></tr><tr><td>SPI</td><td>1 MHz~20 MHz</td><td>1% 以下</td></tr><tr><td>UART</td><td>1200 bps~921600 bps</td><td>1% 以下</td></tr></tbody></table><h3 id="UART外设"><a href="#UART外设" class="headerlink" title="UART外设"></a>UART外设</h3><ul><li>UART(通用异步收发传输器)是一种设备、通信的基础，规定了数据的格式和帧结构；RS232和RS485是基于UART的电气接口标准，其规定了电气特性和物理特性</li><li>TTL电平的通信速率：MCU的UART外设<strong>理论最高速率取决于其外设的时钟源</strong><ul><li>可通过芯片手册查看时钟树，获取外设的时钟频率</li></ul></li><li>RS232为点对点通信，其标准传输速率须在20Kbps下，抗干扰能力差，传输最大距离不超过15m</li><li>RS485的理论最高传输速率为10Mbps，可一对多通信，理论最大传输距离1500米(9600bps)</li><li>测试较高波特率场景要求时，可以<strong>通过示波器抓取uart外设波形，计算其误差是否满足</strong>，或者通过逻辑分析仪在收发两端分别测试验证</li></ul><p>以下转述参考文章: <a href="https://zhuanlan.zhihu.com/p/534135274">UART波特率对时钟精度的要求有多高？</a></p><blockquote><p>分频误差：波特率是根据系统时钟分频产生的，而系统时钟和波特率可能不是整数倍的关系，所以分频时也会产生误差。但是，当系统时钟较高，或者波特率较低时，这个误差影响很小。</p></blockquote><blockquote><p>时钟误差：波特率的主要误差还是取决于系统时钟的误差。串口通讯对时钟误差的要求有多高呢？<br>每一个字节都有一个起始位做同步，所以误差只会在一个字节内累计。在最后一个位采样时，误差最大，允许极限误差为0.5位。<br>按照每个字节10位计算，最大允许误差为±0.5&#x2F;10&#x3D;±0.05，即±5%。<br>考虑到串口通讯涉及收发两端，两端都可能存在误差，所以，每端的误差最好控制在±2.5%以内。当数据位、校验位等较多时，要求的时钟误差就更高一些。<br>考虑到上面所说的分频误差，一般来说，当时钟误差小于±2%时，串口通信是比较可靠的。</p></blockquote><h4 id="UART通信协议"><a href="#UART通信协议" class="headerlink" title="UART通信协议"></a>UART通信协议</h4><ul><li>空闲状态</li><li>起始位</li><li>数据位</li><li>奇偶检验位</li><li>停止位</li></ul><h4 id="空闲位和空闲中断"><a href="#空闲位和空闲中断" class="headerlink" title="空闲位和空闲中断"></a>空闲位和空闲中断</h4><p>空闲位：在UART通信中两个字节或者两个帧之间的 <strong>一位高电平</strong>，用于表示线路的空闲状态；当接收端检测到线路从”1”跳转到”0”(起始位)时，可以知道下一字节开始传输</p><ul><li>当一次发送多个字节时，每字节间会有个空闲位(可配置？看实际设计)，用于区分字节<br></li></ul><p>空闲中断：在接收到数据之后，如果<strong>在一个字节的时间内</strong>没有再接收到数据，就会产生空闲中断</p><ul><li>其一般用于接收不定长数据，用于<strong>标识一个数据包&#x2F;一帧数据</strong></li></ul><h3 id="SPI外设"><a href="#SPI外设" class="headerlink" title="SPI外设"></a>SPI外设</h3><p>SPI 的 MOSI、MISO引脚在空闲状态下为低电平，SCK空闲电平可以指定</p><p>QSPI</p><h3 id="IIS接口"><a href="#IIS接口" class="headerlink" title="IIS接口"></a>IIS接口</h3><p>IIS（Inter-IC Sound），又称集成电路内置音频总线，是飞利浦在1986年定义的数字音频传输标准，与IIC并无相关性。</p><p>相对其它协议，IIS接口协议相对简单，没有地址和片选机制。在总线上，只能同时存在一个主设备和发射设备：提供时钟的为主设备，主设备可以是发射设备、接收设备或者协调两者的其它控制设备皆可。</p><blockquote><p>主要应用于处理器与音频编解码器之间的音频数据传输<br><br></p></blockquote><p>IIS协议定义了三根信号线：<strong>时钟信号SCK、数据信号SD、左右声道选择信号WS</strong></p><ul><li>SCK&#x2F;BCLK 位时钟：等于通道数 * 位宽 * 采样率</li><li>SDIN&#x2F;DIN 数据线：串行数据，以二进制补码形式在数据线上传输，在WS变化后的第一个SCK脉冲先传输最高位</li><li>WS&#x2F;LRCLK 声道选择信号：用于区分左右声道的数据，0表示左声道，1表示右声道。也叫帧时钟，等于声音的采样频率</li><li>MCLK 主时钟（可选）：提供主时钟频率给接收端，确保采样率的准确性。 在高质量音频输出、使用外部音频解码器、多通道音频传输时，主时钟是必须的。</li></ul><h4 id="标准IIS模式"><a href="#标准IIS模式" class="headerlink" title="标准IIS模式"></a>标准IIS模式</h4><h2 id="其它部分"><a href="#其它部分" class="headerlink" title="其它部分"></a>其它部分</h2><h3 id="bin文件合并大小"><a href="#bin文件合并大小" class="headerlink" title="bin文件合并大小"></a>bin文件合并大小</h3><p>假如一个bin文件大小为6KB，烧录地址为0x8000000，另一个bin文件大小为60KB，烧录地址为0x8002800（偏移10KB），那么<strong>此两bin文件合并大小为70KB</strong>，而非66KB</p><h3 id="为什么一个内存地址对应一个字节"><a href="#为什么一个内存地址对应一个字节" class="headerlink" title="为什么一个内存地址对应一个字节"></a>为什么一个内存地址对应一个字节</h3><p>一个内存地址，通常对应一个内存单元，在大部分计算机系统中，一个内存单元通常是一个字节，因为字节是计算机处理数据的基本单位。即一个地址表示的是一个8-bit大小的空间。</p><p>在某些特定硬件或者设计中，一个地址可能会对应不同的数据单位，STM32有特定设计把一片内存映射成位带，一个地址对应 1 位。或者在某些系统设计中，一个地址对应的是16-bit大小空间。</p><h3 id="大端-小端存储"><a href="#大端-小端存储" class="headerlink" title="大端&#x2F;小端存储"></a>大端&#x2F;小端存储</h3><p>多字节数据存储的字节顺序问题：</p><ul><li>大端存储（Big-endian）是指数据的高位字节存储在低地址，低位字节存储在高地址。</li><li>小端存储（Little-endian）是指数据的低位字节存储在低地址，高位字节存储在高地址。</li></ul><p>例，32bit的16进制数 0x12345678 在内存中的存放方式：</p><p>大端内存地址0x10000x10010x10020x1003<br>大端存放内容0x120x340x560x78</p><p>小端内存地址0x10000x10010x10020x1003<br>小端存放内容0x780x560x340x12</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://blog.csdn.net/ssc_zcys/article/details/105871643">内存地址（理解）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【编程】嵌入式MCU软件架构设计</title>
      <link href="/2023/11/04/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/11/04/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入式MCU开发-裸机-RTOS的优缺点"><a href="#嵌入式MCU开发-裸机-RTOS的优缺点" class="headerlink" title="嵌入式MCU开发-裸机&#x2F;RTOS的优缺点"></a>嵌入式MCU开发-裸机&#x2F;RTOS的优缺点</h2><h3 id="裸机程序特点"><a href="#裸机程序特点" class="headerlink" title="裸机程序特点"></a>裸机程序特点</h3><ul><li>轮询执行，通常为每个模块将其核心业务加入时间片周期轮询</li><li>从RTOS的角度理解，相当于仅有软件定时器，通过定时器超时执行 核心业务回调函数，而这个轮询时间由开发者根据实际情况设定</li><li>无法实现非阻塞延时，只用到MSP主堆栈，任务的上下文无法保存</li></ul><h3 id="RTOS程序特性"><a href="#RTOS程序特性" class="headerlink" title="RTOS程序特性"></a>RTOS程序特性</h3><ul><li>对于单核MCU来说，RTOS虽不是真正的并行执行，只是宏观上达到多程序并行的效果</li><li>RTOS能较好地实现模块的分离和隔离，降低耦合，每个任务都有自己的任务栈，这对于业务开发、移植、维护较为友好</li><li>实时性比裸机要强，任务间通信，如事件、消息队列、信号等API阻塞 + Systick调度中断，可以使得任务执行 的实时性大大提高，而不是裸机程序的轮询执行</li></ul><h2 id="程序设计原则"><a href="#程序设计原则" class="headerlink" title="程序设计原则"></a>程序设计原则</h2><h3 id="文件、函数、变量命名"><a href="#文件、函数、变量命名" class="headerlink" title="文件、函数、变量命名"></a>文件、函数、变量命名</h3><ul><li>不同层级的文件命名、函数命名、变量命名要有标识度</li></ul><h3 id="分层以及模块化设计"><a href="#分层以及模块化设计" class="headerlink" title="分层以及模块化设计"></a>分层以及模块化设计</h3><p>层级之间的调用和信息上报</p><ul><li>下层提供直接接口调用，提供注册回调函数，禁止调用上层接口</li></ul><h3 id="避免全局变量之开发设计"><a href="#避免全局变量之开发设计" class="headerlink" title="避免全局变量之开发设计"></a>避免全局变量之开发设计</h3><p>尽量少用多文件共享之全局变量</p><p>变量首选局部变量，其次用静态全局变量（仅能被当前文件访问），全局变量可改为指针传递</p><p>或者是导出接口或者函数指针、句柄</p><p>静态全局变量过多情况下，可用结构体统一封装，称为句柄，可作为指针传递出去</p><h3 id="设计模式的应用"><a href="#设计模式的应用" class="headerlink" title="设计模式的应用"></a>设计模式的应用</h3><ul><li>状态机</li><li>命令模式<br>  事件与匹配函数执行的数组集</li></ul><h2 id="裸机开发"><a href="#裸机开发" class="headerlink" title="裸机开发"></a>裸机开发</h2><ul><li><p>模块间通信</p><ul><li>实时性要求不高的情况下，可以应用 类消息队列 的方式，尽量使用避免跨文件的全局变量</li><li>高实时性要求下，可以采用 订阅-发布模式</li></ul></li><li><p>软件定时器的使用</p><ul><li>以Systick为全局时基</li></ul></li></ul><h2 id="RTOS开发"><a href="#RTOS开发" class="headerlink" title="RTOS开发"></a>RTOS开发</h2><h3 id="代码业务设计"><a href="#代码业务设计" class="headerlink" title="代码业务设计"></a>代码业务设计</h3><ul><li><p>消息队列的应用</p><ul><li>阻塞式消息队列</li></ul></li><li><p>事件的应用</p></li></ul><h3 id="多线程设计注意点"><a href="#多线程设计注意点" class="headerlink" title="多线程设计注意点"></a>多线程设计注意点</h3><ul><li>临界区问题</li><li>高实时性要求场合</li></ul><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5NzM5MjMxNw==&mid=2247515885&idx=1&sn=94e4ac996455859387afe5806b976528&chksm=edf25549f3458e30d413803d53b488db8c8afd900d8b7a67a1adda827c8f8acf7414cb064439&scene=126&sessionid=1713954104#rd">项目中太多全局变量有什么弊端</a></li><li><a href="https://mp.weixin.qq.com/s/x2xGxMGphoGQ2tDUu7aSEA">这种嵌入式软件代码命名，都无需看注解了</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MCU】基于MCU的IAP/OTA升级软件设计思路及流程分析</title>
      <link href="/2023/11/02/%E3%80%90MCU%E3%80%91IAP-OTA%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/02/%E3%80%90MCU%E3%80%91IAP-OTA%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初次接触 IAP 升级时，是直接搬运别人验证过的代码到自己的工程中，没有太过于深究其细节，对其如何保证稳定性的代码过程也是比较模糊的。当时只是知道所移植的 IAP 思路是：<em><strong>在 APP 工程中接收新的 APP 文件，并将其存放到存储区内，而后回到 Bootloader，擦除原有的 App，然后将新的 APP文件 从存储区搬运写入到 APP运行区，最后跳转到 APP 运行区执行。</strong></em></p><p>当然了，上述思路只是 IAP 升级的方法之一，另外实际的升级过程也要稍微复杂一点，要考虑的东西也稍多，譬如：</p><ul><li>如何保证接收的新APP文件是正确的？如何做校验？</li><li>这个从外界（上位机）接收文件的过程是怎样的？通过何种协议？为什么？有没有更好的方法？</li><li>如果在搬运升级的过程中，断电了或者因为其它原因失败了，如何保证设备不会变砖头？</li><li>在这个代码设计过程中，有哪些要注意的重点事项？有哪些具体升级方法和它们的适用环境？</li></ul><br><p>鉴于上述一系列的问题，私以为有必要系统总结一下在 MCU 开发中的 IAP 升级，当然肯定不全是本人原创内容，只能说是基于前人的文章以及个人的实践应用和理解之上，做深度的总结，权当分享或者私人回顾用</p><hr><h2 id="IAP升级方法思路概述"><a href="#IAP升级方法思路概述" class="headerlink" title="IAP升级方法思路概述"></a>IAP升级方法思路概述</h2><p>IAP 升级有多种方法，以下参考其它站点文章，以<em>在哪个运行区应用编程</em>（即以在哪个区进行擦除Flash、搬运App）分类，做进一步的讲述</p><h3 id="在Bootloader应用编程"><a href="#在Bootloader应用编程" class="headerlink" title="在Bootloader应用编程"></a>在Bootloader应用编程</h3><p><strong>思路一：</strong> 程序正常工作在 App 工程中，此时收到上位机的升级指令，MCU 通过复位或者直接跳转的方式回到 Bootloader，在 Bootloader 中直接擦除当前 APP 程序，然后接收新的 APP 并直接写入 APP 运行区中，最后检验通过则跳转至 APP 运行区执行程序。</p><p><strong>优缺点分析：</strong> </p><ul><li>更适用于内存资源小的情况，只使用<strong>一个 Bootloader 区和 一个 APP 运行区</strong></li><li>可用性差，一般建议只用于内部产测或者专用的串口调试升级，不能用于消费者产品端上，当升级过程突然中断，那就代表着只有 Bootloader 程序了，只能一直处于等待升级中</li><li>兼容性、通用性差，如果要做空中 OTA 升级，则要在 Bootloader 工程支持产品的无线连接、传输协议等业务</li></ul><hr><p><strong>思路二：</strong> 程序正常工作在 APP 运行区中，收到上位机的指令，则回到 Bootloader 中，此时不擦除当前的 APP 程序，首先接收新 APP 程序并将其写入到规划好的存储区中（此存储区可以是内部Flash某个空白部分，也可以是外部Flash空间），等新程序接收完毕并且校验无误后，再擦除 APP 运行区，并将新 APP 从存储区搬运复制到原 APP 运行区，最后跳转运行，完成升级</p><p><strong>优缺点分析：</strong></p><ul><li>需要占用额外的空间，使用内部的 Flash 或者外部的空间来作为存储区都可</li><li>安全稳定可靠，无论是传输中断或者是在 Bootloader 搬运过程中断电，都可保障能升级成功。（接收传输中断了，原有 APP 继续工作；即使Bootloader 在搬运过程中断电了，但存储区程序还在，下次上电后 Bootloader 会继续从存储区搬运新程序）</li><li>适用于串口 IAP 升级，可移植性强；不建议用于空中 OTA 升级，那意味着bootloader需要开发无线通信相关的逻辑，换种说法是：不建议把跟业务相关的功能做到 Bootloader</li></ul><hr><p><strong>思路三：</strong> 程序正常工作在 APP1 运行区中，收到上位机的指令，则回到 Bootloader 中，此时并不会擦除 APP1 运行区程序，而是首先擦除 APP2 运行区（内部Flash的另一块预设空间），然后接收新 APP 并将其写入到 APP2 运行区中，等接收完毕并校验无误后，设置 APP2 运行标志位，擦除 APP1 运行标志位，最后跳转至 APP2 运行区中执行程序。（同理：下次则是擦除 APP1 程序，接收新程序到 APP1 运行区中并设置 APP1 标志位，清除 APP2 标志，最后跳转执行 APP1）</p><p><strong>优缺点分析：</strong> </p><ul><li>用到一个 Bootloader、两个 APP 运行区，而是都要是可运行代码的内部 Flash 空间</li><li>操作较思路二绕一点，但安全可靠性是一致的</li><li>升级时不用擦除原有 APP 运行区程序，节省了这一步操作，但其实也不算优势，因为擦除时间本身就很短，建议优先用思路二方法</li></ul><hr><h3 id="在APP应用编程"><a href="#在APP应用编程" class="headerlink" title="在APP应用编程"></a>在APP应用编程</h3><p><strong>思路四：</strong> 程序运行在 APP 中，在 APP 中接收新 APP 程序，并将其写入到规划好的存储区内（可以是内部Flash，也可以是外部存储块），等待接收完毕并且检验通过后，通过复位或者跳转的方式回到 Bootlaoder 中，由 Bootloader 检验新程序无误后，再擦除 APP 运行区程序，然后将新 APP 从存储区搬运到 APP 运行区中，最后跳转至 APP 运行区执行新程序。</p><p><strong>优缺点分析：</strong></p><ul><li>APP 和 Bootloader 均涉及编程</li><li>升级存储区域可采用外部存储区，可选择范围广</li></ul><hr><p><strong>思路五：</strong> 程序运行在 APP1 运行区中，开始接收新的 APP 程序并将其写入到内部Flash的 APP2 运行区，待接收完毕并校验无误后，清除 APP1 运行标志位，设置 APP2 运行标志位，通过复位或者跳转回到 Bootloader，由 Bootloader根据有效标志位选择跳转进入 APP1 或者 APP2 运行区。（同理：下次升级将 APP1 和 APP2 反转即可）</p><p><strong>优缺点分析：</strong> </p><ul><li>只能用于内部 Flash 够大的情况下，建议优先采用思路四</li><li>Bootloader 不涉及编程操作</li></ul><hr><h3 id="IAP升级方法小结"><a href="#IAP升级方法小结" class="headerlink" title="IAP升级方法小结"></a>IAP升级方法小结</h3><p>在 Bootloader 集成传输接收及升级操作</p><ul><li>APP 工程无需涉及升级相关代码，专注于业务即可</li><li>Bootloader 稍为复杂，占用空间大</li><li>Bootloader可移植，使得前期没时间写好 APP 工程时，也能先烧录 Bootloader。后续可以在没有 APP 的情况下也能更新 APP 工程</li></ul><br><p>在 APP 集成接收传输：</p><ul><li>可移植性稍差，每写一个工程，都得把升级相关代码加进工程里并验证</li><li>Bootloader 程序简单，占用空间小</li></ul><br><p><strong>注意：</strong> 上述所说，是基于 MCU 的产品角度，IAP 升级是指产品应用串口 + Ymodem 协议与上位机连接进行升级，OTA 升级特指通过蓝牙或者WiFi与终端建立无线连接后，再通过私有的协议栈与终端交互进行传输升级</p><h2 id="IAP具体设计"><a href="#IAP具体设计" class="headerlink" title="IAP具体设计"></a>IAP具体设计</h2><h3 id="IAP环境及工具配置"><a href="#IAP环境及工具配置" class="headerlink" title="IAP环境及工具配置"></a>IAP环境及工具配置</h3><ul><li><p>Ymodem：通常串口的IAP升级传输都是应用 Ymodem 协议，该协议成熟稳定可靠，且支持单文件传输，多文件传输，断点续传，文件校验等功能，另外重要的一点是许多串口通信软件都内置了对 Ymodem 的支持，而无须开发者自行实现上位机，具有良好的易用性兼容性。</p></li><li><p>上位机软件的应用：SecureCRT，自带 Ymodem 协议，也支持脚本，非常适用自动化升级使用，不过要收费；Windterm ，支持 Ymodem 协议，但是不支持脚本；XShell等</p></li></ul><h3 id="升级详细设计流程"><a href="#升级详细设计流程" class="headerlink" title="升级详细设计流程"></a>升级详细设计流程</h3><p>以思路四为例：</p><ul><li><p>需要设置一个标志位以供判断，用于标志 当前传输是否完成、是否需要搬运升级、搬运是否完毕、升级是否成功</p></li><li><p>bin文件要包头包尾、文件校验码，传输时可以作为验证校对用</p></li><li><p>DCD配置，APP写入一些需要配置的硬件数据到指定的存储空间，Bootloader 读取这部分内容进行相应的配置以实现相应的功能，这样可以使得Bootloader更具可移植性，将与硬件相应的设置部分抽离出来</p></li></ul><h3 id="从APP转至运行Bootloader的方法"><a href="#从APP转至运行Bootloader的方法" class="headerlink" title="从APP转至运行Bootloader的方法"></a>从APP转至运行Bootloader的方法</h3><h4 id="系统复位"><a href="#系统复位" class="headerlink" title="系统复位"></a>系统复位</h4><p>直接调用 CMSIS 提供的接口<code>NVIC_SystemReset()</code>即可，该操作会把内核及所有外设重置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void reboot(void)</span><br><span class="line">&#123;</span><br><span class="line">    __set_FAULTMASK(1);     // 关闭所有中断</span><br><span class="line">    NVIC_SystemReset();     // 系统复位，以上两个函数位于 core_cm3.h 文件或 core_cm4.h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内核复位"><a href="#内核复位" class="headerlink" title="内核复位"></a>内核复位</h4><p>内核复位，主要包括内存、NVIC、Systick等内核部分，而不会复位外设，即当程序复位到 0x8000000 重新执行时，外设比如GPIO引脚、定时器等还保留为 APP 运行时的状态，可以利用这点实现特殊的业务设计：<strong>允许复位，但对外设又有特殊要求：某一个IO状态不能因为复位而改变，某一个定时器计数值不能改变等。</strong></p><p>在内核复位的情况下，不考虑中断的禁用等问题，因为NVIC中断控制器会被重置为激活状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __DSB(); <span class="comment">// ARM汇编语言中的一条指令，用于确保在指令执行期间对内存的访问顺序</span></span><br><span class="line">    __disable_irq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选择在此设置看门狗</span></span><br><span class="line">    <span class="comment">// 关闭或者设置有可能影响 Bootloader 程序运行的外设</span></span><br><span class="line"></span><br><span class="line">    SCB-&gt;AIRCR = ((<span class="number">0x5FA</span> &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      |</span><br><span class="line">                  (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) |</span><br><span class="line">                   SCB_AIRCR_VECTRESET_Msk);</span><br><span class="line">    __DSB();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，使用内核复位要谨慎注意外设状态可能对系统运行状态的影响，如下：</p><ul><li>应用了DMA的外设，要注意可能的问题</li><li>部分外设初始化流程不甚合规的，可能会导致复位后外设初始化失败，建议在配置初始化外设时首先先复位此外设。比如：ADC外设在初始化时，并没有先<code>DeInit</code>进行外设复位，而且在内核复位时也没有复位此外设，那么在内核复位后再次初始化ADC外设可能会失败。</li></ul><h4 id="跳转复位"><a href="#跳转复位" class="headerlink" title="跳转复位"></a>跳转复位</h4><p>设置好中断向量以及配置好栈顶指针后，直接跳转至 Bootloader 的复位中断开始运行，<strong>在这过程中内核及外设都不会自动复位，可由用户根据业务需要进行配置</strong></p><p>示例代码参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*iapfun)(void);</span><br><span class="line"></span><br><span class="line">iapfun jump2bootloader;</span><br><span class="line"></span><br><span class="line">void app_jump2_bootloader(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 可设置看门狗</span><br><span class="line"></span><br><span class="line">    u32 bootxaddr = 0x08000000;</span><br><span class="line">    if(((*(vu32*)bootxaddr)&amp;0x2FFE0000)==0x20000000) //检查栈顶地址是否合法</span><br><span class="line">    &#123;</span><br><span class="line">        __disable_irq();</span><br><span class="line">SysTick-&gt;CTRL = 0;</span><br><span class="line">SysTick-&gt;LOAD = 0;</span><br><span class="line">SysTick-&gt;VAL = 0;</span><br><span class="line">        for (int i = 0; i &lt; 8; i++)</span><br><span class="line">&#123;</span><br><span class="line">NVIC-&gt;ICER[i] = 0xFFFFFFFF;</span><br><span class="line">NVIC-&gt;ICPR[i] = 0xFFFFFFFF;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        // 可配置必要外设  RCC_DeInit();</span><br><span class="line">        </span><br><span class="line">        SCB-&gt;VTOR = 0x08000000;  // 设置中断向量表基地址</span><br><span class="line"></span><br><span class="line">        __set_CONTROL(0);   // 设置使用MSP主堆栈指针</span><br><span class="line">        // __set_PSP(*(volatile unsigned int*) bootxaddr);</span><br><span class="line"></span><br><span class="line">        jump2bootloader = (iapfun)*(vu32*)(bootxaddr+4);      //代码区第二个字为程序开始地址(复位地址)</span><br><span class="line">        MSR_MSP(*(vu32*)bootxaddr);                  //初始化boot堆栈指针(代码区的第一个字用于存放栈顶地址)</span><br><span class="line"></span><br><span class="line">        jump2bootloader();                                 //跳转到bootloader.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bootloader跳转至APP代码片段"><a href="#Bootloader跳转至APP代码片段" class="headerlink" title="Bootloader跳转至APP代码片段"></a>Bootloader跳转至APP代码片段</h3><p>以思路四为例 —— 主要工作流程为芯片上电-&gt;执行bootloader代码-&gt;初始化时钟和配置必要外设-&gt;检测是否需要进行固件更新，是-则将新固件从存储区拷贝替换至应用程序运行区，然后跳转至应用程序入口；否-则直接跳转至应用程序入口开始执行业务。</p><p><strong>适用于ARM-CC：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*iapfun)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置栈顶地址</span></span><br><span class="line"><span class="comment">//addr:栈顶地址</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">MSR_MSP</span><span class="params">(u32 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    MSR MSP, r0             <span class="comment">//set Main Stack value</span></span><br><span class="line">    BX r14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到应用程序段</span></span><br><span class="line"><span class="comment">//appxaddr:用户代码起始地址.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iap_load_app</span><span class="params">(u32 appxaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(((*(vu32*)appxaddr)&amp;<span class="number">0x2FFE0000</span>)==<span class="number">0x20000000</span>) <span class="comment">//检查栈顶地址是否合法.</span></span><br><span class="line">    &#123;</span><br><span class="line">        jump2app=(iapfun)*(vu32*)(appxaddr+<span class="number">4</span>);      <span class="comment">//用户代码区第二个字为程序开始地址(复位地址)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// SCB-&gt;VTOR  = appxaddr;</span></span><br><span class="line">        </span><br><span class="line">        MSR_MSP(*(vu32*)appxaddr);                  <span class="comment">//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)</span></span><br><span class="line">        jump2app();                                 <span class="comment">//跳转到APP.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>适用于arm-none-eabi-gcc：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置栈顶地址</span></span><br><span class="line"><span class="comment">//addr:栈顶地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSR_MSP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;MSR MSP, %[addr] \n\t&quot;</span>  <span class="comment">// 设置主堆栈指针</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;BX LR \n\t&quot;</span>             <span class="comment">// 返回</span></span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : [addr] <span class="string">&quot;r&quot;</span> (addr)</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到应用程序段</span></span><br><span class="line"><span class="comment">//appxaddr:用户代码起始地址.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iap_load_app</span><span class="params">(u32 appxaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(((*(vu32*)appxaddr)&amp;<span class="number">0x2FFE0000</span>)==<span class="number">0x20000000</span>) <span class="comment">//检查栈顶地址是否合法.</span></span><br><span class="line">    &#123;</span><br><span class="line">        jump2app=(iapfun)*(vu32*)(appxaddr+<span class="number">4</span>);      <span class="comment">//用户代码区第二个字为程序开始地址(复位地址)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// SCB-&gt;VTOR  = appxaddr;</span></span><br><span class="line">        </span><br><span class="line">        MSR_MSP(*(vu32*)appxaddr);                  <span class="comment">//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)</span></span><br><span class="line">        jump2app();                                 <span class="comment">//跳转到APP.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注意点及疑惑解答"><a href="#注意点及疑惑解答" class="headerlink" title="注意点及疑惑解答"></a>注意点及疑惑解答</h2><h3 id="常规编码注意点"><a href="#常规编码注意点" class="headerlink" title="常规编码注意点"></a>常规编码注意点</h3><ul><li><p>内部Flash和片外Flash的擦除单位可能不一致，2K、4K字节不等</p></li><li><p>SPI Flash的写，写内部Flash要以4的倍数字节写进，外部不限制</p></li><li><p>写Flash须考虑4字节对齐</p><blockquote><p>内部Flash编程以一个字为单位，如果非4字节对齐，会导致硬件错误</p></blockquote></li><li><p>内核复位需要关闭相应的外设，如DMA、等等</p><blockquote><p>跳转复位需要关中断、清标志位<br>另外在外设初始化时，需要deinit或者disable一下，否则可能会导致ADC、DMA配置失败</p></blockquote></li><li><p>看门狗的喂狗问题，即使在ymodem传输过程中，也要保证喂狗避免芯片复位</p></li></ul><h3 id="文件升级如何进行保密"><a href="#文件升级如何进行保密" class="headerlink" title="文件升级如何进行保密"></a>文件升级如何进行保密</h3><p><strong>加密升级包：</strong>在服务器上对固件镜像进行加密，然后传输到设备。设备拥有正确的密钥，解密升级包，然后进行升级。</p><p><strong>设备认证</strong>：升级前对设备进行身份验证，可以通过设备证书、密钥对验证、或者设备ID是否在数据库等方法。</p><p>此外，芯片也要加上读写保护，如L1 L2级别的保护</p><h3 id="内核复位-IAP升级失败原因分析"><a href="#内核复位-IAP升级失败原因分析" class="headerlink" title="内核复位-IAP升级失败原因分析"></a>内核复位-IAP升级失败原因分析</h3><p>常规原因排查：</p><ul><li>跳转前未关中断；</li><li>中断控制器没复位清零；</li><li>中断向量表偏移未设置正确；</li><li>部分会影响到程序运行的外设未关闭，如DMA会刷新SRAM，可能会影响到bootloader程序的运行，导致crash</li><li>系统时钟配置不一致，bootloader与APP的系统时钟初始化应该保持一致</li><li>可能的原因：bootloader与APP的编译链接选项尽可能保持一致，如硬件浮点、函数&#x2F;数据编译分小节、所用C库、优化选项等<br></li></ul><hr><p>在实际应用上述<strong>思路四</strong>的IAP升级时，使用内核复位至 bootloader 搬运更新 APP 程序，而后跳转至 APP 程序，在此过程中程序跑飞，未能成功升级，排查初步分析如下：</p><ul><li>程序内核复位至bootloader后，能够正常擦除原有APP，并已将新APP写入APP运行区。所以推测认为是<strong>bootloader程序在跳转至新APP时，跑飞，导致升级失败</strong>。</li><li>有时发现测试IAP能够成功，发现如果原有APP跟升级APP的<code>text</code>代码段大小一样，则升级成功。如果原有APP跟升级APP的<code>text</code>段大小不一样，则升级失败。（若代码段发生变化必会失败，但<strong>常量字符串大小变化即.rodata变化</strong>仍能够升级成功）</li><li>如果是完全的系统复位至bootloader则能升级成功，所以初步认为是<strong>原APP对运行环境的影响导致的升级后跳转失败</strong>。</li><li>在bootloader跳转后并无任何信息打印，可以得出<strong>新APP在串口初始化时或之前已经跑飞</strong>。</li><li>有可能是：向量中断偏移错误导致，需要在bootloader跳转前就将向量中断偏移更新，APP代码段的变化会导致出错，因为代码段的变化会导致实际的中断服务函数地址变化</li><li>跟中断应该无关，内核复位时已经复位所有中断，且bootloader能够正常编程。所以有可能是外设或者某些代码片段重复初始化，且会涉及到代码段以及flash，从而才导致异常。</li><li><strong>可能是系统时钟设置不一致问题</strong>，目前APP初始化时会重新设置系统时钟，如果没有这部分设置，会导致程序异常。</li><li>不同存储区跳转运行，需要关闭ICACHE</li><li>对比此前已成功实现内核复位升级的工程，有何区别？</li><li>移植CmBacktrace至bootloader，查看具体跑飞原因</li><li>用GDB在线调试运行bootloader查看hardfault时候的寄存器值，PC指针在何处，LR指针</li></ul><p>问题排查解决分析结论：</p><ul><li>跟芯片型号有关系，此前实现内核复位升级成功的型号为N32L406，而现型号为N32G452RC，后续与原厂FAE进行沟通联系</li></ul><hr><h3 id="如何保证bootloader升级失败不会导致设备变砖？"><a href="#如何保证bootloader升级失败不会导致设备变砖？" class="headerlink" title="如何保证bootloader升级失败不会导致设备变砖？"></a>如何保证bootloader升级失败不会导致设备变砖？</h3><p>保证接收到的新APP是正确的，传输完毕后校验文件无误</p><p>保证在搬运编程过程中，即使是突然断电或者复位后，也能继续搬运或者重新搬运至完成</p><h3 id="在实时操作系统环境中，如何执行跳转操作？"><a href="#在实时操作系统环境中，如何执行跳转操作？" class="headerlink" title="在实时操作系统环境中，如何执行跳转操作？"></a>在实时操作系统环境中，如何执行跳转操作？</h3><p>操作系统在线程中使用PSP堆栈指针，在中断中使用MSP主堆栈指针</p><p>设置CONTROL寄存器的<code>bit[1]</code>选择使用哪个堆栈指针。<code>CONTROL[1]=0</code>选择主堆栈指针；<code>CONTROL[1]=1</code>选择进程堆栈指针</p><p>直接PC跳转复位，实际上内核并不会自动切换MSP和PSP，因为此过程没有触发内核Handler模式，需要用户手动切换</p><h2 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h2><ul><li><a href="https://mp.weixin.qq.com/s/8eXIi0Lo4ZgsmNGQI0X96g">常用的几种 IAP 升级技术方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】嵌入式Qt环境搭建概述</title>
      <link href="/2023/11/01/%E3%80%90Linux%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FQt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/01/%E3%80%90Linux%E3%80%91%E5%B5%8C%E5%85%A5%E5%BC%8FQt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>1、下载安装通用交叉编译器<br>2、获取和编译tslib<br>    嵌入式Qt要支持触摸插件则需要编译tslib<br>3、编译ARM平台Qt5.12.9源码<br>4、移植Qt库到文件系统<br>5、在ubuntu上搭建 ARM平台的Qt开发环境</p><p>总结：<br>1、需要下载交叉编译器并安装、使能相应的环境变量<br>2、在ubuntu上交叉编译tslib库和ARM Qt库源码后，将编译生成的库文件移植到嵌入式平台文件系统中<br>3、在ubuntu下编写Qt应用程序，并使用交叉工具链编译，然后拷贝到嵌入式平台上运行即可</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="陈进渡"><a href="#陈进渡" class="headerlink" title="陈进渡"></a>陈进渡</h2><p>男 | 25岁 </p><p>18898517377 | <a href="mailto:&#99;&#104;&#x65;&#x6e;&#x6a;&#105;&#x6e;&#100;&#x75;&#x40;&#x31;&#50;&#x36;&#46;&#x63;&#111;&#109;">&#99;&#104;&#x65;&#x6e;&#x6a;&#105;&#x6e;&#100;&#x75;&#x40;&#x31;&#50;&#x36;&#46;&#x63;&#111;&#109;</a> | <a href="https://jindu-chen.github.io/">https://jindu-chen.github.io</a></p><p>嵌入式软件工程师</p><p>深圳大学 本科 机电与控制工程（2018.09 - 2022.06）</p><!-- ### 教育经历深圳大学 本科 机电与控制工程（2018.09 - 2022.06）### 个人技能- 熟练使用 ST、国民技术等 MCU 进行驱动与应用开发；掌握 SPI、IIC、UART 等外设原理及使用；- 熟练掌握C语言编程，熟悉 C++ 和汇编语言；- 熟练使用实时操作系统进行开发，如RT-Thread、OpenHarmony轻量系统或其它RTOS内核等；- 熟悉嵌入式Linux系统开发，熟悉设备驱动框架；- 熟悉软件分层设计、模块化设计、业务组件、芯片通用驱动编写；- 能看懂常用原理图，能熟练使用万用表、示波器、逻辑分析仪等测试工具；- 熟练应用开发/构建/辅助工具如 Keil、Git、Make、GCC、Markdown 等；具备良好的英文阅读能力（CET-6）### 工作经历**深圳市倍轻松科技股份有限公司 (2022.05 - 至今)**     嵌入式软件工程师 电子开发部<br>1. 通用业务模块代码编写及维护，分离代码层次结构，输出业务组件，以缩减同类型产品软件开发周期2. 国产32位芯片通用外设驱动代码编写及维护3. 独立完成多款新品项目软件设计，跟进技术立项、产品研发、生产上市4. 对接、维护公司现有项目工程，并进行迭代开发，包括颈部、眼部、头部按摩器等电子消费产品5. 进行产品适配OpenHarmony轻量系统开发，并通过OpenHarmony兼容性测评6. 编写及完善公司嵌入式业务开发规范文档### 项目经历#### 颈部按摩器 (2022.06 - 2022.11)**项目描述：**该产品为旗舰级电子消费产品，功能模块主要包含有蓝牙模组、无刷电机组、加热片、触摸IC、RGB-LED、IAP等，应用外设驱动主要有uart、iic、spi、pwm等。**责任描述：**1. 基于裸机的多任务轮询框架进行开发，应用回调函数、消息队列等方式实现子任务事件上报、主任务分发控制的业务框架，较好地实现了模块化设计，大大提高了工程的可读性以及可维护性。2. 编写各功能模块业务，封装可复用的代码，并整理输出，以缩减同类型产品功能开发进度。3. 对接app控制，整机联调，跟进产品测试以及生产上市流程**项目业绩：**为公司2022年度主打新品之一，后进行多次迭代开发及批量生产#### 颈部按摩器 (2022.10 - 2023.03)**项目描述：**  该产品采用国产32位MCU，基于RT-Thread操作系统开发，包括有无刷电机、加热热敷、BLE控制、OTA升级等功能，拥有多模式业务设计，并向用户提供丰富的自定义控制接口**责任描述：**1. 软件框架构建，代码设计应用包含状态模式、观察者模式、命令模式、面向对象等设计思想；编写统一接口的通用驱动，缩减芯片替换开发进程。2. 灵活运用命令行交互以及日志打印，高效完成业务逻辑开发以及软件调试，并便于后续bug查找，缩减开发周期。3. 软硬联调，紧密对接需求，跟进项目量产、维护与后续迭代开发工作4. 进行移植适配OpenHarmony轻量系统开发，并通过开放原子基金会的产品兼容性测评**项目业绩：**1. 主动积极挖掘需求，运用多层链表，使得按摩模式动作具备高扩展性；产品功能设计得到业务领导赞赏，在年中总结会中获得创新之星奖2. 该产品在2023年3月实现量产上市，截止至2023年5月，销售额已超一千万元3. 此项目后多次迭代开发，并获得开源鸿蒙生态产品兼容性证书，2023年度累计销售额超过五千万元，在公司自研产品中排名第二#### 电子灸疗器械系列**基于I.MX6ULL/RK3566的灸疗仪 (2023.03 - 2023.11)****项目描述：**  该项目是一款II类电子医疗器械，内置了屏幕触控、多通道温控、联网升级等功能。该产品通过电子灸疗片搭配药物，作用于人体穴位，主要应用于预防或治疗疾病。产品已通过医疗所前期检验，进入试产阶段**责任描述：**1. 私有协议开发，对接主机通讯，主要负责下位机的控制2. 对接客户需求与外协，参与嵌入式Linux系统和Qt界面的设计与开发3. 进行基于I.MX6ULL芯片的方案预研，完成u-boot、dtb、kernel、rootfs的修改与编译，组件驱动添加和裁剪**基于N32L40x的无线灸疗仪 (2023.10 - 至今)****项目描述：**  该产品为一拖二的设计，主要业务功能为热敷、蓝牙BLE控制、按键、灯光、主从机私有协议通信、OTA升级等**责任描述：**1. 进行主机及从机的软件架构设计，应用抽象程度高的裸机定时/任务链表轮询框架，较好地实现系统分层设计、业务模块化设计2. 应用开源组件 Letter_Shell、Log、Flexible_button、SFUD 等### 自我评价- 能够快速熟悉业务代码逻辑并具有独立开发能力- 热爱技术，喜欢接受挑战，具有强大的自驱力 -->]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
